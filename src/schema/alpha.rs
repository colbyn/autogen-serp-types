// AUTOGENERATED: strict types + deserializers
use serde::{Deserialize, Deserializer};
use serde::de::{Error as DeError};
use once_cell::sync::Lazy;
use regex::Regex;

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Null;

impl<'de> Deserialize<'de> for Null {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        struct V;
        impl<'de> serde::de::Visitor<'de> for V {
            type Value = Null;
            fn expecting(&self, f:&mut std::fmt::Formatter) -> std::fmt::Result { write!(f, "null") }
            fn visit_unit<E>(self) -> Result<Null, E> where E: DeError { Ok(Null) }
            fn visit_none<E>(self) -> Result<Null, E> where E: DeError { Ok(Null) }
            fn visit_some<D>(self, _d: D) -> Result<Null, D::Error> where D: Deserializer<'de> {
                Err(DeError::invalid_type(serde::de::Unexpected::Other("non-null"), &"null"))
            }
        }
        de.deserialize_option(V)
    }
}
/// tuple len=4 (required first 1 slots)
#[derive(Debug, Deserialize)]
pub struct Root2(
    pub String,
    pub Option<String>,
    pub Option<String>,
    pub Option<String>,
);

#[repr(transparent)]
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct Root430(pub String);
impl std::ops::Deref for Root430 {
    type Target = String;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root430 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let s = String::deserialize(de)?;
        if !(s.starts_with("http://") || s.starts_with("https://") || s.starts_with("mailto:") || s.starts_with("tel:")) {
            return Err(DeError::custom("Root430: expected URI scheme"));
        }
        Ok(Root430(s))
    }
}
/// tuple len=4 (required first 4 slots)
#[derive(Debug, Deserialize)]
pub struct Root43(
    pub Root430,
    pub String,
    pub Null,
    pub String,
);

#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub struct Root47(pub f64);
impl std::ops::Deref for Root47 {
    type Target = f64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root47 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = f64::deserialize(de)?;
        if !x.is_finite() { return Err(DeError::custom("Root47: non-finite number")); }
        if x < 1.0 { return Err(DeError::custom("Root47: number below minimum")); }
        if x > 5.0 { return Err(DeError::custom("Root47: number above maximum")); }
        
        Ok(Root47(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root48(pub i64);
impl std::ops::Deref for Root48 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root48 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 1 { return Err(DeError::custom("Root48: integer below minimum")); }
        if x > 7104 { return Err(DeError::custom("Root48: integer above maximum")); }
        
        Ok(Root48(x))
    }
}
/// tuple len=11 (required first 10 slots)
#[derive(Debug, Deserialize)]
pub struct Root4(
    pub Null,
    pub Null,
    pub Option<String>,
    pub Root43,
    pub Option<String>,
    pub Null,
    pub Null,
    pub Root47,
    pub Root48,
    pub Null,
    pub Option<String>,
);

#[repr(transparent)]
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct Root70(pub String);
impl std::ops::Deref for Root70 {
    type Target = String;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root70 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let s = String::deserialize(de)?;
        if !(s.starts_with("http://") || s.starts_with("https://") || s.starts_with("mailto:") || s.starts_with("tel:")) {
            return Err(DeError::custom("Root70: expected URI scheme"));
        }
        Ok(Root70(s))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct Root74(pub String);
impl std::ops::Deref for Root74 {
    type Target = String;
    fn deref(&self) -> &Self::Target { &self.0 }
}
static RE_ROOT74: Lazy<Regex> = Lazy::new(|| Regex::new("^,AOvVaw.*").unwrap());
impl<'de> Deserialize<'de> for Root74 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let s = String::deserialize(de)?;
        if !RE_ROOT74.is_match(&s) {
            return Err(DeError::custom("Root74: string failed pattern"));
        }
        Ok(Root74(s))
    }
}
/// tuple len=5 (required first 5 slots)
#[derive(Debug, Deserialize)]
pub struct Root7(
    pub Root70,
    pub String,
    pub Null,
    pub Null,
    pub Root74,
);

#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub struct Root92(pub f64);
impl std::ops::Deref for Root92 {
    type Target = f64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root92 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = f64::deserialize(de)?;
        if !x.is_finite() { return Err(DeError::custom("Root92: non-finite number")); }
        if x < 35.976811399999995 { return Err(DeError::custom("Root92: number below minimum")); }
        if x > 51.2072 { return Err(DeError::custom("Root92: number above maximum")); }
        
        Ok(Root92(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub struct Root93(pub f64);
impl std::ops::Deref for Root93 {
    type Target = f64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root93 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = f64::deserialize(de)?;
        if !x.is_finite() { return Err(DeError::custom("Root93: non-finite number")); }
        if x < -129.942708600000003 { return Err(DeError::custom("Root93: number below minimum")); }
        if x > -106.677120000000002 { return Err(DeError::custom("Root93: number above maximum")); }
        
        Ok(Root93(x))
    }
}
/// tuple len=4 (required first 4 slots)
#[derive(Debug, Deserialize)]
pub struct Root9(
    pub Null,
    pub Null,
    pub Root92,
    pub Root93,
);

#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root17(pub i64);
impl std::ops::Deref for Root17 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root17 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 1 { return Err(DeError::custom("Root17: integer below minimum")); }
        if x > 1 { return Err(DeError::custom("Root17: integer above maximum")); }
        
        Ok(Root17(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root24ItemItemItemItem0(pub i64);
impl std::ops::Deref for Root24ItemItemItemItem0 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root24ItemItemItemItem0 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 2 { return Err(DeError::custom("Root24ItemItemItemItem0: integer below minimum")); }
        if x > 2 { return Err(DeError::custom("Root24ItemItemItemItem0: integer above maximum")); }
        
        Ok(Root24ItemItemItemItem0(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root24ItemItemItemItem51(pub i64);
impl std::ops::Deref for Root24ItemItemItemItem51 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root24ItemItemItemItem51 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 0 { return Err(DeError::custom("Root24ItemItemItemItem51: integer below minimum")); }
        if x > 30 { return Err(DeError::custom("Root24ItemItemItemItem51: integer above maximum")); }
        
        Ok(Root24ItemItemItemItem51(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root24ItemItemItemItem52(pub i64);
impl std::ops::Deref for Root24ItemItemItemItem52 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root24ItemItemItemItem52 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 0 { return Err(DeError::custom("Root24ItemItemItemItem52: integer below minimum")); }
        if x > 18 { return Err(DeError::custom("Root24ItemItemItemItem52: integer above maximum")); }
        
        Ok(Root24ItemItemItemItem52(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root24ItemItemItemItem53(pub i64);
impl std::ops::Deref for Root24ItemItemItemItem53 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root24ItemItemItemItem53 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 0 { return Err(DeError::custom("Root24ItemItemItemItem53: integer below minimum")); }
        if x > 6 { return Err(DeError::custom("Root24ItemItemItemItem53: integer above maximum")); }
        
        Ok(Root24ItemItemItemItem53(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root24ItemItemItemItem54(pub i64);
impl std::ops::Deref for Root24ItemItemItemItem54 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root24ItemItemItemItem54 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 0 { return Err(DeError::custom("Root24ItemItemItemItem54: integer below minimum")); }
        if x > 0 { return Err(DeError::custom("Root24ItemItemItemItem54: integer above maximum")); }
        
        Ok(Root24ItemItemItemItem54(x))
    }
}
/// tuple len=5 (required first 1 slots)
#[derive(Debug, Deserialize)]
pub struct Root24ItemItemItemItem5(
    pub Null,
    pub Option<Root24ItemItemItemItem51>,
    pub Option<Root24ItemItemItemItem52>,
    pub Option<Root24ItemItemItemItem53>,
    pub Option<Root24ItemItemItemItem54>,
);

#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root24ItemItemItemItem61(pub i64);
impl std::ops::Deref for Root24ItemItemItemItem61 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root24ItemItemItemItem61 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 0 { return Err(DeError::custom("Root24ItemItemItemItem61: integer below minimum")); }
        if x > 59 { return Err(DeError::custom("Root24ItemItemItemItem61: integer above maximum")); }
        
        Ok(Root24ItemItemItemItem61(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root24ItemItemItemItem62(pub i64);
impl std::ops::Deref for Root24ItemItemItemItem62 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root24ItemItemItemItem62 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 5 { return Err(DeError::custom("Root24ItemItemItemItem62: integer below minimum")); }
        if x > 24 { return Err(DeError::custom("Root24ItemItemItemItem62: integer above maximum")); }
        
        Ok(Root24ItemItemItemItem62(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root24ItemItemItemItem63(pub i64);
impl std::ops::Deref for Root24ItemItemItemItem63 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root24ItemItemItemItem63 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 1 { return Err(DeError::custom("Root24ItemItemItemItem63: integer below minimum")); }
        if x > 7 { return Err(DeError::custom("Root24ItemItemItemItem63: integer above maximum")); }
        
        Ok(Root24ItemItemItemItem63(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root24ItemItemItemItem64(pub i64);
impl std::ops::Deref for Root24ItemItemItemItem64 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root24ItemItemItemItem64 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 0 { return Err(DeError::custom("Root24ItemItemItemItem64: integer below minimum")); }
        if x > 0 { return Err(DeError::custom("Root24ItemItemItemItem64: integer above maximum")); }
        
        Ok(Root24ItemItemItemItem64(x))
    }
}
/// tuple len=5 (required first 1 slots)
#[derive(Debug, Deserialize)]
pub struct Root24ItemItemItemItem6(
    pub Null,
    pub Option<Root24ItemItemItemItem61>,
    pub Option<Root24ItemItemItemItem62>,
    pub Option<Root24ItemItemItemItem63>,
    pub Option<Root24ItemItemItemItem64>,
);

/// tuple len=7 (required first 7 slots)
#[derive(Debug, Deserialize)]
pub struct Root24ItemItemItemItem(
    pub Root24ItemItemItemItem0,
    pub Null,
    pub Null,
    pub Null,
    pub Null,
    pub Root24ItemItemItemItem5,
    pub Root24ItemItemItemItem6,
);

#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root2518Item0Item(pub i64);
impl std::ops::Deref for Root2518Item0Item {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root2518Item0Item {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 1 { return Err(DeError::custom("Root2518Item0Item: integer below minimum")); }
        if x > 8 { return Err(DeError::custom("Root2518Item0Item: integer above maximum")); }
        
        Ok(Root2518Item0Item(x))
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum Root2518Item1 {
    Favorites,
    SavedPlaces,
    StarredPlaces,
    TravelPlans,
    WantToGo,
}
impl<'de> Deserialize<'de> for Root2518Item1 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let s = String::deserialize(de)?;
        match s.as_str() {
            "Favorites" => Ok(Root2518Item1::Favorites),
            "Saved places" => Ok(Root2518Item1::SavedPlaces),
            "Starred places" => Ok(Root2518Item1::StarredPlaces),
            "Travel plans" => Ok(Root2518Item1::TravelPlans),
            "Want to go" => Ok(Root2518Item1::WantToGo),
            _ => Err(DeError::unknown_variant(&s, &[])),
        }
    }
}
impl serde::Serialize for Root2518Item1 {
    fn serialize<S>(&self, ser: S) -> Result<S::Ok, S::Error> where S: serde::Serializer {
        match self {
            Root2518Item1::Favorites => ser.serialize_str("Favorites"),
            Root2518Item1::SavedPlaces => ser.serialize_str("Saved places"),
            Root2518Item1::StarredPlaces => ser.serialize_str("Starred places"),
            Root2518Item1::TravelPlans => ser.serialize_str("Travel plans"),
            Root2518Item1::WantToGo => ser.serialize_str("Want to go"),
        }
    }
}

#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root2518Item3(pub i64);
impl std::ops::Deref for Root2518Item3 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root2518Item3 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 1 { return Err(DeError::custom("Root2518Item3: integer below minimum")); }
        if x > 1 { return Err(DeError::custom("Root2518Item3: integer above maximum")); }
        
        Ok(Root2518Item3(x))
    }
}
/// tuple len=12 (required first 12 slots)
#[derive(Debug, Deserialize)]
pub struct Root2518Item(
    pub Vec<Root2518Item0Item>,
    pub Root2518Item1,
    pub Null,
    pub Root2518Item3,
    pub Null,
    pub Null,
    pub Null,
    pub Null,
    pub Null,
    pub Null,
    pub Null,
    pub String,
);

/// tuple len=23 (required first 23 slots)
#[derive(Debug, Deserialize)]
pub struct Root25(
    pub Null,
    pub Null,
    pub Null,
    pub Null,
    pub Null,
    pub Null,
    pub Null,
    pub Null,
    pub Null,
    pub Null,
    pub Null,
    pub Null,
    pub Null,
    pub Null,
    pub Null,
    pub Null,
    pub Null,
    pub Null,
    pub Vec<Root2518Item>,
    pub Null,
    pub Null,
    pub Null,
    pub String,
);

#[repr(transparent)]
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct Root30(pub String);
impl std::ops::Deref for Root30 {
    type Target = String;
    fn deref(&self) -> &Self::Target { &self.0 }
}
static RE_ROOT30: Lazy<Regex> = Lazy::new(|| Regex::new("^America/.*").unwrap());
impl<'de> Deserialize<'de> for Root30 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let s = String::deserialize(de)?;
        if !RE_ROOT30.is_match(&s) {
            return Err(DeError::custom("Root30: string failed pattern"));
        }
        Ok(Root30(s))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root3205(pub i64);
impl std::ops::Deref for Root3205 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root3205 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 1 { return Err(DeError::custom("Root3205: integer below minimum")); }
        if x > 1 { return Err(DeError::custom("Root3205: integer above maximum")); }
        
        Ok(Root3205(x))
    }
}
/// tuple len=6 (required first 6 slots)
#[derive(Debug, Deserialize)]
pub struct Root320(
    pub Null,
    pub String,
    pub Null,
    pub Null,
    pub Null,
    pub Root3205,
);

#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root3215(pub i64);
impl std::ops::Deref for Root3215 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root3215 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 1 { return Err(DeError::custom("Root3215: integer below minimum")); }
        if x > 1 { return Err(DeError::custom("Root3215: integer above maximum")); }
        
        Ok(Root3215(x))
    }
}
/// tuple len=6 (required first 6 slots)
#[derive(Debug, Deserialize)]
pub struct Root321(
    pub Null,
    pub String,
    pub Null,
    pub Null,
    pub Null,
    pub Root3215,
);

#[repr(transparent)]
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct Root323(pub String);
impl std::ops::Deref for Root323 {
    type Target = String;
    fn deref(&self) -> &Self::Target { &self.0 }
}
static RE_ROOT323: Lazy<Regex> = Lazy::new(|| Regex::new("^https://www\\.google\\.com/local/review/rap/report\\?d=286732321&t=5&postId=0x8.*").unwrap());
impl<'de> Deserialize<'de> for Root323 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let s = String::deserialize(de)?;
        if !RE_ROOT323.is_match(&s) {
            return Err(DeError::custom("Root323: string failed pattern"));
        }
        Ok(Root323(s))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct Root324(pub String);
impl std::ops::Deref for Root324 {
    type Target = String;
    fn deref(&self) -> &Self::Target { &self.0 }
}
static RE_ROOT324: Lazy<Regex> = Lazy::new(|| Regex::new("^https://support\\.google\\.com/local-listings/answer/9851099.*").unwrap());
impl<'de> Deserialize<'de> for Root324 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let s = String::deserialize(de)?;
        if !RE_ROOT324.is_match(&s) {
            return Err(DeError::custom("Root324: string failed pattern"));
        }
        Ok(Root324(s))
    }
}
/// tuple len=5 (required first 5 slots)
#[derive(Debug, Deserialize)]
pub struct Root32(
    pub Root320,
    pub Root321,
    pub Null,
    pub Root323,
    pub Root324,
);

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum Root341Item0 {
    Friday,
    Monday,
    Saturday,
    Sunday,
    Thursday,
    Tuesday,
    Wednesday,
}
impl<'de> Deserialize<'de> for Root341Item0 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let s = String::deserialize(de)?;
        match s.as_str() {
            "Friday" => Ok(Root341Item0::Friday),
            "Monday" => Ok(Root341Item0::Monday),
            "Saturday" => Ok(Root341Item0::Saturday),
            "Sunday" => Ok(Root341Item0::Sunday),
            "Thursday" => Ok(Root341Item0::Thursday),
            "Tuesday" => Ok(Root341Item0::Tuesday),
            "Wednesday" => Ok(Root341Item0::Wednesday),
            _ => Err(DeError::unknown_variant(&s, &[])),
        }
    }
}
impl serde::Serialize for Root341Item0 {
    fn serialize<S>(&self, ser: S) -> Result<S::Ok, S::Error> where S: serde::Serializer {
        match self {
            Root341Item0::Friday => ser.serialize_str("Friday"),
            Root341Item0::Monday => ser.serialize_str("Monday"),
            Root341Item0::Saturday => ser.serialize_str("Saturday"),
            Root341Item0::Sunday => ser.serialize_str("Sunday"),
            Root341Item0::Thursday => ser.serialize_str("Thursday"),
            Root341Item0::Tuesday => ser.serialize_str("Tuesday"),
            Root341Item0::Wednesday => ser.serialize_str("Wednesday"),
        }
    }
}

#[repr(transparent)]
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct Root341Item4(pub String);
impl std::ops::Deref for Root341Item4 {
    type Target = String;
    fn deref(&self) -> &Self::Target { &self.0 }
}
static RE_ROOT341ITEM4: Lazy<Regex> = Lazy::new(|| Regex::new("^2025-09-.*").unwrap());
impl<'de> Deserialize<'de> for Root341Item4 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let s = String::deserialize(de)?;
        if !RE_ROOT341ITEM4.is_match(&s) {
            return Err(DeError::custom("Root341Item4: string failed pattern"));
        }
        Ok(Root341Item4(s))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root341Item5(pub i64);
impl std::ops::Deref for Root341Item5 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root341Item5 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 1 { return Err(DeError::custom("Root341Item5: integer below minimum")); }
        if x > 2 { return Err(DeError::custom("Root341Item5: integer above maximum")); }
        
        Ok(Root341Item5(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root341Item6ItemItem(pub i64);
impl std::ops::Deref for Root341Item6ItemItem {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root341Item6ItemItem {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 0 { return Err(DeError::custom("Root341Item6ItemItem: integer below minimum")); }
        if x > 59 { return Err(DeError::custom("Root341Item6ItemItem: integer above maximum")); }
        
        Ok(Root341Item6ItemItem(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root341Item7(pub i64);
impl std::ops::Deref for Root341Item7 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root341Item7 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 0 { return Err(DeError::custom("Root341Item7: integer below minimum")); }
        if x > 1 { return Err(DeError::custom("Root341Item7: integer above maximum")); }
        
        Ok(Root341Item7(x))
    }
}
/// tuple len=8 (required first 8 slots)
#[derive(Debug, Deserialize)]
pub struct Root341Item(
    pub Root341Item0,
    pub Vec<String>,
    pub Null,
    pub Null,
    pub Root341Item4,
    pub Root341Item5,
    pub Option<Vec<Vec<Root341Item6ItemItem>>>,
    pub Root341Item7,
);

#[repr(transparent)]
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct Root34400(pub String);
impl std::ops::Deref for Root34400 {
    type Target = String;
    fn deref(&self) -> &Self::Target { &self.0 }
}
static RE_ROOT34400: Lazy<Regex> = Lazy::new(|| Regex::new("^Friday.*").unwrap());
impl<'de> Deserialize<'de> for Root34400 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let s = String::deserialize(de)?;
        if !RE_ROOT34400.is_match(&s) {
            return Err(DeError::custom("Root34400: string failed pattern"));
        }
        Ok(Root34400(s))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct Root34404(pub String);
impl std::ops::Deref for Root34404 {
    type Target = String;
    fn deref(&self) -> &Self::Target { &self.0 }
}
static RE_ROOT34404: Lazy<Regex> = Lazy::new(|| Regex::new("^2025-09-05.*").unwrap());
impl<'de> Deserialize<'de> for Root34404 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let s = String::deserialize(de)?;
        if !RE_ROOT34404.is_match(&s) {
            return Err(DeError::custom("Root34404: string failed pattern"));
        }
        Ok(Root34404(s))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root34405(pub i64);
impl std::ops::Deref for Root34405 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root34405 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 1 { return Err(DeError::custom("Root34405: integer below minimum")); }
        if x > 2 { return Err(DeError::custom("Root34405: integer above maximum")); }
        
        Ok(Root34405(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root34406ItemItem(pub i64);
impl std::ops::Deref for Root34406ItemItem {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root34406ItemItem {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 0 { return Err(DeError::custom("Root34406ItemItem: integer below minimum")); }
        if x > 59 { return Err(DeError::custom("Root34406ItemItem: integer above maximum")); }
        
        Ok(Root34406ItemItem(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root34407(pub i64);
impl std::ops::Deref for Root34407 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root34407 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 0 { return Err(DeError::custom("Root34407: integer below minimum")); }
        if x > 0 { return Err(DeError::custom("Root34407: integer above maximum")); }
        
        Ok(Root34407(x))
    }
}
/// tuple len=8 (required first 8 slots)
#[derive(Debug, Deserialize)]
pub struct Root3440(
    pub Root34400,
    pub Vec<String>,
    pub Null,
    pub Null,
    pub Root34404,
    pub Root34405,
    pub Option<Vec<Vec<Root34406ItemItem>>>,
    pub Root34407,
);

#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root3441(pub i64);
impl std::ops::Deref for Root3441 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root3441 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 1 { return Err(DeError::custom("Root3441: integer below minimum")); }
        if x > 2 { return Err(DeError::custom("Root3441: integer above maximum")); }
        
        Ok(Root3441(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root3442(pub i64);
impl std::ops::Deref for Root3442 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root3442 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 1 { return Err(DeError::custom("Root3442: integer below minimum")); }
        if x > 6 { return Err(DeError::custom("Root3442: integer above maximum")); }
        
        Ok(Root3442(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root3443(pub i64);
impl std::ops::Deref for Root3443 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root3443 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 0 { return Err(DeError::custom("Root3443: integer below minimum")); }
        if x > 1 { return Err(DeError::custom("Root3443: integer above maximum")); }
        
        Ok(Root3443(x))
    }
}
/// tuple len=5 (required first 5 slots)
#[derive(Debug, Deserialize)]
pub struct Root344(
    pub Root3440,
    pub Root3441,
    pub Root3442,
    pub Option<Root3443>,
    pub String,
);

#[repr(transparent)]
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct Root3460(pub String);
impl std::ops::Deref for Root3460 {
    type Target = String;
    fn deref(&self) -> &Self::Target { &self.0 }
}
static RE_ROOT3460: Lazy<Regex> = Lazy::new(|| Regex::new("^Friday.*").unwrap());
impl<'de> Deserialize<'de> for Root3460 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let s = String::deserialize(de)?;
        if !RE_ROOT3460.is_match(&s) {
            return Err(DeError::custom("Root3460: string failed pattern"));
        }
        Ok(Root3460(s))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct Root3464(pub String);
impl std::ops::Deref for Root3464 {
    type Target = String;
    fn deref(&self) -> &Self::Target { &self.0 }
}
static RE_ROOT3464: Lazy<Regex> = Lazy::new(|| Regex::new("^2025-09-05.*").unwrap());
impl<'de> Deserialize<'de> for Root3464 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let s = String::deserialize(de)?;
        if !RE_ROOT3464.is_match(&s) {
            return Err(DeError::custom("Root3464: string failed pattern"));
        }
        Ok(Root3464(s))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root3465(pub i64);
impl std::ops::Deref for Root3465 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root3465 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 1 { return Err(DeError::custom("Root3465: integer below minimum")); }
        if x > 2 { return Err(DeError::custom("Root3465: integer above maximum")); }
        
        Ok(Root3465(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root3466ItemItem(pub i64);
impl std::ops::Deref for Root3466ItemItem {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root3466ItemItem {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 0 { return Err(DeError::custom("Root3466ItemItem: integer below minimum")); }
        if x > 59 { return Err(DeError::custom("Root3466ItemItem: integer above maximum")); }
        
        Ok(Root3466ItemItem(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root3467(pub i64);
impl std::ops::Deref for Root3467 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root3467 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 0 { return Err(DeError::custom("Root3467: integer below minimum")); }
        if x > 0 { return Err(DeError::custom("Root3467: integer above maximum")); }
        
        Ok(Root3467(x))
    }
}
/// tuple len=8 (required first 8 slots)
#[derive(Debug, Deserialize)]
pub struct Root346(
    pub Root3460,
    pub Vec<String>,
    pub Null,
    pub Null,
    pub Root3464,
    pub Root3465,
    pub Option<Vec<Vec<Root3466ItemItem>>>,
    pub Root3467,
);

/// tuple len=7 (required first 7 slots)
#[derive(Debug, Deserialize)]
pub struct Root34(
    pub Null,
    pub Vec<Root341Item>,
    pub Null,
    pub Null,
    pub Root344,
    pub Null,
    pub Root346,
);

#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root35ItemAlt0(pub i64);
impl std::ops::Deref for Root35ItemAlt0 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root35ItemAlt0 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 0 { return Err(DeError::custom("Root35ItemAlt0: integer below minimum")); }
        if x > 0 { return Err(DeError::custom("Root35ItemAlt0: integer above maximum")); }
        
        Ok(Root35ItemAlt0(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct Root35ItemAlt20Alt0(pub String);
impl std::ops::Deref for Root35ItemAlt20Alt0 {
    type Target = String;
    fn deref(&self) -> &Self::Target { &self.0 }
}
static RE_ROOT35ITEMALT20ALT0: Lazy<Regex> = Lazy::new(|| Regex::new("^2025-09-06.*").unwrap());
impl<'de> Deserialize<'de> for Root35ItemAlt20Alt0 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let s = String::deserialize(de)?;
        if !RE_ROOT35ITEMALT20ALT0.is_match(&s) {
            return Err(DeError::custom("Root35ItemAlt20Alt0: string failed pattern"));
        }
        Ok(Root35ItemAlt20Alt0(s))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root35ItemAlt20Alt1Item0Alt0(pub i64);
impl std::ops::Deref for Root35ItemAlt20Alt1Item0Alt0 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root35ItemAlt20Alt1Item0Alt0 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 2 { return Err(DeError::custom("Root35ItemAlt20Alt1Item0Alt0: integer below minimum")); }
        if x > 2 { return Err(DeError::custom("Root35ItemAlt20Alt1Item0Alt0: integer above maximum")); }
        
        Ok(Root35ItemAlt20Alt1Item0Alt0(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct Root35ItemAlt20Alt1Item0Alt10(pub String);
impl std::ops::Deref for Root35ItemAlt20Alt1Item0Alt10 {
    type Target = String;
    fn deref(&self) -> &Self::Target { &self.0 }
}
static RE_ROOT35ITEMALT20ALT1ITEM0ALT10: Lazy<Regex> = Lazy::new(|| Regex::new("^0ahUKEwj1x5fr9MKPAxWiEEQIHUTDLPsQjqADCN.*").unwrap());
impl<'de> Deserialize<'de> for Root35ItemAlt20Alt1Item0Alt10 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let s = String::deserialize(de)?;
        if !RE_ROOT35ITEMALT20ALT1ITEM0ALT10.is_match(&s) {
            return Err(DeError::custom("Root35ItemAlt20Alt1Item0Alt10: string failed pattern"));
        }
        Ok(Root35ItemAlt20Alt1Item0Alt10(s))
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum Root35ItemAlt20Alt1Item0Alt12 {
    V,
}
impl<'de> Deserialize<'de> for Root35ItemAlt20Alt1Item0Alt12 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let s = String::deserialize(de)?;
        match s.as_str() {
            "" => Ok(Root35ItemAlt20Alt1Item0Alt12::V),
            _ => Err(DeError::unknown_variant(&s, &[])),
        }
    }
}
impl serde::Serialize for Root35ItemAlt20Alt1Item0Alt12 {
    fn serialize<S>(&self, ser: S) -> Result<S::Ok, S::Error> where S: serde::Serializer {
        match self {
            Root35ItemAlt20Alt1Item0Alt12::V => ser.serialize_str(""),
        }
    }
}

#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub struct Root35ItemAlt20Alt1Item0Alt132(pub f64);
impl std::ops::Deref for Root35ItemAlt20Alt1Item0Alt132 {
    type Target = f64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root35ItemAlt20Alt1Item0Alt132 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = f64::deserialize(de)?;
        if !x.is_finite() { return Err(DeError::custom("Root35ItemAlt20Alt1Item0Alt132: non-finite number")); }
        if x < 39.084305000000001 { return Err(DeError::custom("Root35ItemAlt20Alt1Item0Alt132: number below minimum")); }
        if x > 39.095188 { return Err(DeError::custom("Root35ItemAlt20Alt1Item0Alt132: number above maximum")); }
        
        Ok(Root35ItemAlt20Alt1Item0Alt132(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub struct Root35ItemAlt20Alt1Item0Alt133(pub f64);
impl std::ops::Deref for Root35ItemAlt20Alt1Item0Alt133 {
    type Target = f64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root35ItemAlt20Alt1Item0Alt133 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = f64::deserialize(de)?;
        if !x.is_finite() { return Err(DeError::custom("Root35ItemAlt20Alt1Item0Alt133: non-finite number")); }
        if x < -111.154128999999998 { return Err(DeError::custom("Root35ItemAlt20Alt1Item0Alt133: number below minimum")); }
        if x > -111.133292999999995 { return Err(DeError::custom("Root35ItemAlt20Alt1Item0Alt133: number above maximum")); }
        
        Ok(Root35ItemAlt20Alt1Item0Alt133(x))
    }
}
/// tuple len=4 (required first 4 slots)
#[derive(Debug, Deserialize)]
pub struct Root35ItemAlt20Alt1Item0Alt13(
    pub Null,
    pub Null,
    pub Root35ItemAlt20Alt1Item0Alt132,
    pub Root35ItemAlt20Alt1Item0Alt133,
);

#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root35ItemAlt20Alt1Item0Alt16Item10(pub i64);
impl std::ops::Deref for Root35ItemAlt20Alt1Item0Alt16Item10 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root35ItemAlt20Alt1Item0Alt16Item10 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 1 { return Err(DeError::custom("Root35ItemAlt20Alt1Item0Alt16Item10: integer below minimum")); }
        if x > 1 { return Err(DeError::custom("Root35ItemAlt20Alt1Item0Alt16Item10: integer above maximum")); }
        
        Ok(Root35ItemAlt20Alt1Item0Alt16Item10(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct Root35ItemAlt20Alt1Item0Alt16Item11(pub String);
impl std::ops::Deref for Root35ItemAlt20Alt1Item0Alt16Item11 {
    type Target = String;
    fn deref(&self) -> &Self::Target { &self.0 }
}
static RE_ROOT35ITEMALT20ALT1ITEM0ALT16ITEM11: Lazy<Regex> = Lazy::new(|| Regex::new("^http.*").unwrap());
impl<'de> Deserialize<'de> for Root35ItemAlt20Alt1Item0Alt16Item11 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let s = String::deserialize(de)?;
        if !RE_ROOT35ITEMALT20ALT1ITEM0ALT16ITEM11.is_match(&s) {
            return Err(DeError::custom("Root35ItemAlt20Alt1Item0Alt16Item11: string failed pattern"));
        }
        Ok(Root35ItemAlt20Alt1Item0Alt16Item11(s))
    }
}
/// tuple len=2 (required first 2 slots)
#[derive(Debug, Deserialize)]
pub struct Root35ItemAlt20Alt1Item0Alt16Item1(
    pub Root35ItemAlt20Alt1Item0Alt16Item10,
    pub Root35ItemAlt20Alt1Item0Alt16Item11,
);

#[repr(transparent)]
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct Root35ItemAlt20Alt1Item0Alt16Item21(pub String);
impl std::ops::Deref for Root35ItemAlt20Alt1Item0Alt16Item21 {
    type Target = String;
    fn deref(&self) -> &Self::Target { &self.0 }
}
static RE_ROOT35ITEMALT20ALT1ITEM0ALT16ITEM21: Lazy<Regex> = Lazy::new(|| Regex::new("^//lh.*").unwrap());
impl<'de> Deserialize<'de> for Root35ItemAlt20Alt1Item0Alt16Item21 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let s = String::deserialize(de)?;
        if !RE_ROOT35ITEMALT20ALT1ITEM0ALT16ITEM21.is_match(&s) {
            return Err(DeError::custom("Root35ItemAlt20Alt1Item0Alt16Item21: string failed pattern"));
        }
        Ok(Root35ItemAlt20Alt1Item0Alt16Item21(s))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root35ItemAlt20Alt1Item0Alt16Item220(pub i64);
impl std::ops::Deref for Root35ItemAlt20Alt1Item0Alt16Item220 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root35ItemAlt20Alt1Item0Alt16Item220 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 331 { return Err(DeError::custom("Root35ItemAlt20Alt1Item0Alt16Item220: integer below minimum")); }
        if x > 437 { return Err(DeError::custom("Root35ItemAlt20Alt1Item0Alt16Item220: integer above maximum")); }
        
        Ok(Root35ItemAlt20Alt1Item0Alt16Item220(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root35ItemAlt20Alt1Item0Alt16Item221(pub i64);
impl std::ops::Deref for Root35ItemAlt20Alt1Item0Alt16Item221 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root35ItemAlt20Alt1Item0Alt16Item221 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 240 { return Err(DeError::custom("Root35ItemAlt20Alt1Item0Alt16Item221: integer below minimum")); }
        if x > 240 { return Err(DeError::custom("Root35ItemAlt20Alt1Item0Alt16Item221: integer above maximum")); }
        
        Ok(Root35ItemAlt20Alt1Item0Alt16Item221(x))
    }
}
/// tuple len=2 (required first 2 slots)
#[derive(Debug, Deserialize)]
pub struct Root35ItemAlt20Alt1Item0Alt16Item22(
    pub Root35ItemAlt20Alt1Item0Alt16Item220,
    pub Root35ItemAlt20Alt1Item0Alt16Item221,
);

/// tuple len=3 (required first 3 slots)
#[derive(Debug, Deserialize)]
pub struct Root35ItemAlt20Alt1Item0Alt16Item2(
    pub Null,
    pub Root35ItemAlt20Alt1Item0Alt16Item21,
    pub Root35ItemAlt20Alt1Item0Alt16Item22,
);

/// tuple len=3 (required first 3 slots)
#[derive(Debug, Deserialize)]
pub struct Root35ItemAlt20Alt1Item0Alt16Item(
    pub Null,
    pub Root35ItemAlt20Alt1Item0Alt16Item1,
    pub Root35ItemAlt20Alt1Item0Alt16Item2,
);

#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub struct Root35ItemAlt20Alt1Item0Alt17(pub f64);
impl std::ops::Deref for Root35ItemAlt20Alt1Item0Alt17 {
    type Target = f64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root35ItemAlt20Alt1Item0Alt17 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = f64::deserialize(de)?;
        if !x.is_finite() { return Err(DeError::custom("Root35ItemAlt20Alt1Item0Alt17: non-finite number")); }
        if x < 0.0 { return Err(DeError::custom("Root35ItemAlt20Alt1Item0Alt17: number below minimum")); }
        if x > 4.85 { return Err(DeError::custom("Root35ItemAlt20Alt1Item0Alt17: number above maximum")); }
        
        Ok(Root35ItemAlt20Alt1Item0Alt17(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root35ItemAlt20Alt1Item0Alt18(pub i64);
impl std::ops::Deref for Root35ItemAlt20Alt1Item0Alt18 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root35ItemAlt20Alt1Item0Alt18 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 0 { return Err(DeError::custom("Root35ItemAlt20Alt1Item0Alt18: integer below minimum")); }
        if x > 14 { return Err(DeError::custom("Root35ItemAlt20Alt1Item0Alt18: integer above maximum")); }
        
        Ok(Root35ItemAlt20Alt1Item0Alt18(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct Root35ItemAlt20Alt1Item0Alt113(pub String);
impl std::ops::Deref for Root35ItemAlt20Alt1Item0Alt113 {
    type Target = String;
    fn deref(&self) -> &Self::Target { &self.0 }
}
static RE_ROOT35ITEMALT20ALT1ITEM0ALT113: Lazy<Regex> = Lazy::new(|| Regex::new("^/g/11.*").unwrap());
impl<'de> Deserialize<'de> for Root35ItemAlt20Alt1Item0Alt113 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let s = String::deserialize(de)?;
        if !RE_ROOT35ITEMALT20ALT1ITEM0ALT113.is_match(&s) {
            return Err(DeError::custom("Root35ItemAlt20Alt1Item0Alt113: string failed pattern"));
        }
        Ok(Root35ItemAlt20Alt1Item0Alt113(s))
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum Root35ItemAlt20Alt1Item0Alt12300 {
    V,
}
impl<'de> Deserialize<'de> for Root35ItemAlt20Alt1Item0Alt12300 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let s = String::deserialize(de)?;
        match s.as_str() {
            "" => Ok(Root35ItemAlt20Alt1Item0Alt12300::V),
            _ => Err(DeError::unknown_variant(&s, &[])),
        }
    }
}
impl serde::Serialize for Root35ItemAlt20Alt1Item0Alt12300 {
    fn serialize<S>(&self, ser: S) -> Result<S::Ok, S::Error> where S: serde::Serializer {
        match self {
            Root35ItemAlt20Alt1Item0Alt12300::V => ser.serialize_str(""),
        }
    }
}

#[repr(transparent)]
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct Root35ItemAlt20Alt1Item0Alt12303(pub String);
impl std::ops::Deref for Root35ItemAlt20Alt1Item0Alt12303 {
    type Target = String;
    fn deref(&self) -> &Self::Target { &self.0 }
}
static RE_ROOT35ITEMALT20ALT1ITEM0ALT12303: Lazy<Regex> = Lazy::new(|| Regex::new("^/g/11.*").unwrap());
impl<'de> Deserialize<'de> for Root35ItemAlt20Alt1Item0Alt12303 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let s = String::deserialize(de)?;
        if !RE_ROOT35ITEMALT20ALT1ITEM0ALT12303.is_match(&s) {
            return Err(DeError::custom("Root35ItemAlt20Alt1Item0Alt12303: string failed pattern"));
        }
        Ok(Root35ItemAlt20Alt1Item0Alt12303(s))
    }
}
/// tuple len=4 (required first 4 slots)
#[derive(Debug, Deserialize)]
pub struct Root35ItemAlt20Alt1Item0Alt1230(
    pub Root35ItemAlt20Alt1Item0Alt12300,
    pub Null,
    pub Null,
    pub Root35ItemAlt20Alt1Item0Alt12303,
);

#[repr(transparent)]
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct Root35ItemAlt20Alt1Item0Alt1231(pub String);
impl std::ops::Deref for Root35ItemAlt20Alt1Item0Alt1231 {
    type Target = String;
    fn deref(&self) -> &Self::Target { &self.0 }
}
static RE_ROOT35ITEMALT20ALT1ITEM0ALT1231: Lazy<Regex> = Lazy::new(|| Regex::new("^Q0FF.*").unwrap());
impl<'de> Deserialize<'de> for Root35ItemAlt20Alt1Item0Alt1231 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let s = String::deserialize(de)?;
        if !RE_ROOT35ITEMALT20ALT1ITEM0ALT1231.is_match(&s) {
            return Err(DeError::custom("Root35ItemAlt20Alt1Item0Alt1231: string failed pattern"));
        }
        Ok(Root35ItemAlt20Alt1Item0Alt1231(s))
    }
}
/// tuple len=2 (required first 2 slots)
#[derive(Debug, Deserialize)]
pub struct Root35ItemAlt20Alt1Item0Alt123(
    pub Root35ItemAlt20Alt1Item0Alt1230,
    pub Root35ItemAlt20Alt1Item0Alt1231,
);

/// tuple len=24 (required first 24 slots)
#[derive(Debug, Deserialize)]
pub struct Root35ItemAlt20Alt1Item0Alt1(
    pub Root35ItemAlt20Alt1Item0Alt10,
    pub Null,
    pub Root35ItemAlt20Alt1Item0Alt12,
    pub Root35ItemAlt20Alt1Item0Alt13,
    pub String,
    pub Null,
    pub Vec<Root35ItemAlt20Alt1Item0Alt16Item>,
    pub Root35ItemAlt20Alt1Item0Alt17,
    pub Root35ItemAlt20Alt1Item0Alt18,
    pub Vec<Vec<String>>,
    pub Null,
    pub Null,
    pub Null,
    pub Root35ItemAlt20Alt1Item0Alt113,
    pub Null,
    pub Null,
    pub Null,
    pub Null,
    pub Null,
    pub Null,
    pub Null,
    pub Null,
    pub Null,
    pub Root35ItemAlt20Alt1Item0Alt123,
);

#[derive(Debug)]
pub enum Root35ItemAlt20Alt1Item0 {
    V0(Root35ItemAlt20Alt1Item0Alt0),
    V1(Root35ItemAlt20Alt1Item0Alt1),
}

impl<'de> Deserialize<'de> for Root35ItemAlt20Alt1Item0 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        // deserialize into a serde_json::Value once, then attempt each arm (strict)
        let val = serde_json::Value::deserialize(de)?;
        if let Ok(x) = <Root35ItemAlt20Alt1Item0Alt0 as serde::Deserialize>::deserialize(val.clone()) { return Ok(Root35ItemAlt20Alt1Item0::V0(x)); }
        if let Ok(x) = <Root35ItemAlt20Alt1Item0Alt1 as serde::Deserialize>::deserialize(val.clone()) { return Ok(Root35ItemAlt20Alt1Item0::V1(x)); }
        Err(DeError::custom("no union arm matched"))
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum Root35ItemAlt20Alt1Item1Alt1ItemItem2 {
    AirConditioned,
    Breakfast,
    FreeWiFi,
    FreeParking,
}
impl<'de> Deserialize<'de> for Root35ItemAlt20Alt1Item1Alt1ItemItem2 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let s = String::deserialize(de)?;
        match s.as_str() {
            "Air-conditioned" => Ok(Root35ItemAlt20Alt1Item1Alt1ItemItem2::AirConditioned),
            "Breakfast" => Ok(Root35ItemAlt20Alt1Item1Alt1ItemItem2::Breakfast),
            "Free Wi-Fi" => Ok(Root35ItemAlt20Alt1Item1Alt1ItemItem2::FreeWiFi),
            "Free parking" => Ok(Root35ItemAlt20Alt1Item1Alt1ItemItem2::FreeParking),
            _ => Err(DeError::unknown_variant(&s, &[])),
        }
    }
}
impl serde::Serialize for Root35ItemAlt20Alt1Item1Alt1ItemItem2 {
    fn serialize<S>(&self, ser: S) -> Result<S::Ok, S::Error> where S: serde::Serializer {
        match self {
            Root35ItemAlt20Alt1Item1Alt1ItemItem2::AirConditioned => ser.serialize_str("Air-conditioned"),
            Root35ItemAlt20Alt1Item1Alt1ItemItem2::Breakfast => ser.serialize_str("Breakfast"),
            Root35ItemAlt20Alt1Item1Alt1ItemItem2::FreeWiFi => ser.serialize_str("Free Wi-Fi"),
            Root35ItemAlt20Alt1Item1Alt1ItemItem2::FreeParking => ser.serialize_str("Free parking"),
        }
    }
}

#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root35ItemAlt20Alt1Item1Alt1ItemItem3(pub i64);
impl std::ops::Deref for Root35ItemAlt20Alt1Item1Alt1ItemItem3 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root35ItemAlt20Alt1Item1Alt1ItemItem3 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 1 { return Err(DeError::custom("Root35ItemAlt20Alt1Item1Alt1ItemItem3: integer below minimum")); }
        if x > 1 { return Err(DeError::custom("Root35ItemAlt20Alt1Item1Alt1ItemItem3: integer above maximum")); }
        
        Ok(Root35ItemAlt20Alt1Item1Alt1ItemItem3(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root35ItemAlt20Alt1Item1Alt1ItemItem4(pub i64);
impl std::ops::Deref for Root35ItemAlt20Alt1Item1Alt1ItemItem4 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root35ItemAlt20Alt1Item1Alt1ItemItem4 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 2 { return Err(DeError::custom("Root35ItemAlt20Alt1Item1Alt1ItemItem4: integer below minimum")); }
        if x > 22 { return Err(DeError::custom("Root35ItemAlt20Alt1Item1Alt1ItemItem4: integer above maximum")); }
        
        Ok(Root35ItemAlt20Alt1Item1Alt1ItemItem4(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root35ItemAlt20Alt1Item1Alt1ItemItem5(pub i64);
impl std::ops::Deref for Root35ItemAlt20Alt1Item1Alt1ItemItem5 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root35ItemAlt20Alt1Item1Alt1ItemItem5 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 2 { return Err(DeError::custom("Root35ItemAlt20Alt1Item1Alt1ItemItem5: integer below minimum")); }
        if x > 2 { return Err(DeError::custom("Root35ItemAlt20Alt1Item1Alt1ItemItem5: integer above maximum")); }
        
        Ok(Root35ItemAlt20Alt1Item1Alt1ItemItem5(x))
    }
}
/// tuple len=6 (required first 5 slots)
#[derive(Debug, Deserialize)]
pub struct Root35ItemAlt20Alt1Item1Alt1ItemItem(
    pub Null,
    pub Null,
    pub Root35ItemAlt20Alt1Item1Alt1ItemItem2,
    pub Root35ItemAlt20Alt1Item1Alt1ItemItem3,
    pub Root35ItemAlt20Alt1Item1Alt1ItemItem4,
    pub Option<Root35ItemAlt20Alt1Item1Alt1ItemItem5>,
);

#[derive(Debug)]
pub enum Root35ItemAlt20Alt1Item1 {
    V0(String),
    V1(Vec<Vec<Root35ItemAlt20Alt1Item1Alt1ItemItem>>),
}

impl<'de> Deserialize<'de> for Root35ItemAlt20Alt1Item1 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        // deserialize into a serde_json::Value once, then attempt each arm (strict)
        let val = serde_json::Value::deserialize(de)?;
        if let Ok(x) = <String as serde::Deserialize>::deserialize(val.clone()) { return Ok(Root35ItemAlt20Alt1Item1::V0(x)); }
        if let Ok(x) = <Vec<Vec<Root35ItemAlt20Alt1Item1Alt1ItemItem>> as serde::Deserialize>::deserialize(val.clone()) { return Ok(Root35ItemAlt20Alt1Item1::V1(x)); }
        Err(DeError::custom("no union arm matched"))
    }
}

#[repr(transparent)]
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct Root35ItemAlt20Alt1Item6(pub String);
impl std::ops::Deref for Root35ItemAlt20Alt1Item6 {
    type Target = String;
    fn deref(&self) -> &Self::Target { &self.0 }
}
static RE_ROOT35ITEMALT20ALT1ITEM6: Lazy<Regex> = Lazy::new(|| Regex::new("^Q0FF.*").unwrap());
impl<'de> Deserialize<'de> for Root35ItemAlt20Alt1Item6 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let s = String::deserialize(de)?;
        if !RE_ROOT35ITEMALT20ALT1ITEM6.is_match(&s) {
            return Err(DeError::custom("Root35ItemAlt20Alt1Item6: string failed pattern"));
        }
        Ok(Root35ItemAlt20Alt1Item6(s))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root35ItemAlt20Alt1Item11(pub i64);
impl std::ops::Deref for Root35ItemAlt20Alt1Item11 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root35ItemAlt20Alt1Item11 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 86917 { return Err(DeError::custom("Root35ItemAlt20Alt1Item11: integer below minimum")); }
        if x > 86917 { return Err(DeError::custom("Root35ItemAlt20Alt1Item11: integer above maximum")); }
        
        Ok(Root35ItemAlt20Alt1Item11(x))
    }
}
/// tuple len=12 (required first 11 slots)
#[derive(Debug, Deserialize)]
pub struct Root35ItemAlt20Alt1Item(
    pub Root35ItemAlt20Alt1Item0,
    pub Root35ItemAlt20Alt1Item1,
    pub Option<String>,
    pub Null,
    pub Null,
    pub Null,
    pub Option<Root35ItemAlt20Alt1Item6>,
    pub Null,
    pub Null,
    pub Null,
    pub Null,
    pub Option<Root35ItemAlt20Alt1Item11>,
);

#[derive(Debug)]
pub enum Root35ItemAlt20 {
    V0(Root35ItemAlt20Alt0),
    V1(Vec<Root35ItemAlt20Alt1Item>),
}

impl<'de> Deserialize<'de> for Root35ItemAlt20 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        // deserialize into a serde_json::Value once, then attempt each arm (strict)
        let val = serde_json::Value::deserialize(de)?;
        if let Ok(x) = <Root35ItemAlt20Alt0 as serde::Deserialize>::deserialize(val.clone()) { return Ok(Root35ItemAlt20::V0(x)); }
        if let Ok(x) = <Vec<Root35ItemAlt20Alt1Item> as serde::Deserialize>::deserialize(val.clone()) { return Ok(Root35ItemAlt20::V1(x)); }
        Err(DeError::custom("no union arm matched"))
    }
}

#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root35ItemAlt21Alt0(pub i64);
impl std::ops::Deref for Root35ItemAlt21Alt0 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root35ItemAlt21Alt0 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 1 { return Err(DeError::custom("Root35ItemAlt21Alt0: integer below minimum")); }
        if x > 1 { return Err(DeError::custom("Root35ItemAlt21Alt0: integer above maximum")); }
        
        Ok(Root35ItemAlt21Alt0(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct Root35ItemAlt21Alt1(pub String);
impl std::ops::Deref for Root35ItemAlt21Alt1 {
    type Target = String;
    fn deref(&self) -> &Self::Target { &self.0 }
}
static RE_ROOT35ITEMALT21ALT1: Lazy<Regex> = Lazy::new(|| Regex::new("^Q2lBSWtvWDQ4ZWJUaDhqb0FRamRyNDNUMkk2dXdyOEJDTExXN3BqOTBkWExXakFC.*").unwrap());
impl<'de> Deserialize<'de> for Root35ItemAlt21Alt1 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let s = String::deserialize(de)?;
        if !RE_ROOT35ITEMALT21ALT1.is_match(&s) {
            return Err(DeError::custom("Root35ItemAlt21Alt1: string failed pattern"));
        }
        Ok(Root35ItemAlt21Alt1(s))
    }
}
#[derive(Debug)]
pub enum Root35ItemAlt21 {
    V0(Root35ItemAlt21Alt0),
    V1(Root35ItemAlt21Alt1),
}

impl<'de> Deserialize<'de> for Root35ItemAlt21 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        // deserialize into a serde_json::Value once, then attempt each arm (strict)
        let val = serde_json::Value::deserialize(de)?;
        if let Ok(x) = <Root35ItemAlt21Alt0 as serde::Deserialize>::deserialize(val.clone()) { return Ok(Root35ItemAlt21::V0(x)); }
        if let Ok(x) = <Root35ItemAlt21Alt1 as serde::Deserialize>::deserialize(val.clone()) { return Ok(Root35ItemAlt21::V1(x)); }
        Err(DeError::custom("no union arm matched"))
    }
}

#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root35ItemAlt23(pub i64);
impl std::ops::Deref for Root35ItemAlt23 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root35ItemAlt23 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 1 { return Err(DeError::custom("Root35ItemAlt23: integer below minimum")); }
        if x > 1 { return Err(DeError::custom("Root35ItemAlt23: integer above maximum")); }
        
        Ok(Root35ItemAlt23(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root35ItemAlt28Item(pub i64);
impl std::ops::Deref for Root35ItemAlt28Item {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root35ItemAlt28Item {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 0 { return Err(DeError::custom("Root35ItemAlt28Item: integer below minimum")); }
        if x > 4 { return Err(DeError::custom("Root35ItemAlt28Item: integer above maximum")); }
        
        Ok(Root35ItemAlt28Item(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root35ItemAlt214Item(pub i64);
impl std::ops::Deref for Root35ItemAlt214Item {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root35ItemAlt214Item {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 2 { return Err(DeError::custom("Root35ItemAlt214Item: integer below minimum")); }
        if x > 2 { return Err(DeError::custom("Root35ItemAlt214Item: integer above maximum")); }
        
        Ok(Root35ItemAlt214Item(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root35ItemAlt215(pub i64);
impl std::ops::Deref for Root35ItemAlt215 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root35ItemAlt215 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 1 { return Err(DeError::custom("Root35ItemAlt215: integer below minimum")); }
        if x > 1 { return Err(DeError::custom("Root35ItemAlt215: integer above maximum")); }
        
        Ok(Root35ItemAlt215(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root35ItemAlt216ItemAlt0(pub i64);
impl std::ops::Deref for Root35ItemAlt216ItemAlt0 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root35ItemAlt216ItemAlt0 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 0 { return Err(DeError::custom("Root35ItemAlt216ItemAlt0: integer below minimum")); }
        if x > 0 { return Err(DeError::custom("Root35ItemAlt216ItemAlt0: integer above maximum")); }
        
        Ok(Root35ItemAlt216ItemAlt0(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root35ItemAlt216ItemAlt10(pub i64);
impl std::ops::Deref for Root35ItemAlt216ItemAlt10 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root35ItemAlt216ItemAlt10 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 2025 { return Err(DeError::custom("Root35ItemAlt216ItemAlt10: integer below minimum")); }
        if x > 2025 { return Err(DeError::custom("Root35ItemAlt216ItemAlt10: integer above maximum")); }
        
        Ok(Root35ItemAlt216ItemAlt10(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root35ItemAlt216ItemAlt11(pub i64);
impl std::ops::Deref for Root35ItemAlt216ItemAlt11 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root35ItemAlt216ItemAlt11 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 9 { return Err(DeError::custom("Root35ItemAlt216ItemAlt11: integer below minimum")); }
        if x > 9 { return Err(DeError::custom("Root35ItemAlt216ItemAlt11: integer above maximum")); }
        
        Ok(Root35ItemAlt216ItemAlt11(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root35ItemAlt216ItemAlt12(pub i64);
impl std::ops::Deref for Root35ItemAlt216ItemAlt12 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root35ItemAlt216ItemAlt12 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 6 { return Err(DeError::custom("Root35ItemAlt216ItemAlt12: integer below minimum")); }
        if x > 7 { return Err(DeError::custom("Root35ItemAlt216ItemAlt12: integer above maximum")); }
        
        Ok(Root35ItemAlt216ItemAlt12(x))
    }
}
/// tuple len=3 (required first 3 slots)
#[derive(Debug, Deserialize)]
pub struct Root35ItemAlt216ItemAlt1(
    pub Root35ItemAlt216ItemAlt10,
    pub Root35ItemAlt216ItemAlt11,
    pub Root35ItemAlt216ItemAlt12,
);

#[derive(Debug)]
pub enum Root35ItemAlt216Item {
    V0(Root35ItemAlt216ItemAlt0),
    V1(Root35ItemAlt216ItemAlt1),
}

impl<'de> Deserialize<'de> for Root35ItemAlt216Item {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        // deserialize into a serde_json::Value once, then attempt each arm (strict)
        let val = serde_json::Value::deserialize(de)?;
        if let Ok(x) = <Root35ItemAlt216ItemAlt0 as serde::Deserialize>::deserialize(val.clone()) { return Ok(Root35ItemAlt216Item::V0(x)); }
        if let Ok(x) = <Root35ItemAlt216ItemAlt1 as serde::Deserialize>::deserialize(val.clone()) { return Ok(Root35ItemAlt216Item::V1(x)); }
        Err(DeError::custom("no union arm matched"))
    }
}

#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root35ItemAlt218(pub i64);
impl std::ops::Deref for Root35ItemAlt218 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root35ItemAlt218 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 0 { return Err(DeError::custom("Root35ItemAlt218: integer below minimum")); }
        if x > 0 { return Err(DeError::custom("Root35ItemAlt218: integer above maximum")); }
        
        Ok(Root35ItemAlt218(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct Root35ItemAlt221(pub String);
impl std::ops::Deref for Root35ItemAlt221 {
    type Target = String;
    fn deref(&self) -> &Self::Target { &self.0 }
}
static RE_ROOT35ITEMALT221: Lazy<Regex> = Lazy::new(|| Regex::new("^Q2hVU0V3ajUxYVhyOU1LUEF4VjJnMzhFSFlyMEdYTQ==.*").unwrap());
impl<'de> Deserialize<'de> for Root35ItemAlt221 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let s = String::deserialize(de)?;
        if !RE_ROOT35ITEMALT221.is_match(&s) {
            return Err(DeError::custom("Root35ItemAlt221: string failed pattern"));
        }
        Ok(Root35ItemAlt221(s))
    }
}
/// tuple len=22 (required first 21 slots)
#[derive(Debug, Deserialize)]
pub struct Root35ItemAlt2(
    pub Option<Root35ItemAlt20>,
    pub Option<Root35ItemAlt21>,
    pub Null,
    pub Option<Root35ItemAlt23>,
    pub Null,
    pub Null,
    pub Null,
    pub Null,
    pub Option<Vec<Root35ItemAlt28Item>>,
    pub Null,
    pub Null,
    pub Null,
    pub Null,
    pub Null,
    pub Option<Vec<Root35ItemAlt214Item>>,
    pub Option<Root35ItemAlt215>,
    pub Option<Vec<Option<Root35ItemAlt216Item>>>,
    pub Null,
    pub Option<Root35ItemAlt218>,
    pub Null,
    pub Null,
    pub Option<Root35ItemAlt221>,
);

#[derive(Debug)]
pub enum Root35Item {
    V0(Root35ItemAlt0),
    V1(String),
    V2(Root35ItemAlt2),
}

impl<'de> Deserialize<'de> for Root35Item {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        // deserialize into a serde_json::Value once, then attempt each arm (strict)
        let val = serde_json::Value::deserialize(de)?;
        if let Ok(x) = <Root35ItemAlt0 as serde::Deserialize>::deserialize(val.clone()) { return Ok(Root35Item::V0(x)); }
        if let Ok(x) = <String as serde::Deserialize>::deserialize(val.clone()) { return Ok(Root35Item::V1(x)); }
        if let Ok(x) = <Root35ItemAlt2 as serde::Deserialize>::deserialize(val.clone()) { return Ok(Root35Item::V2(x)); }
        Err(DeError::custom("no union arm matched"))
    }
}

#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root370Item1(pub i64);
impl std::ops::Deref for Root370Item1 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root370Item1 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 0 { return Err(DeError::custom("Root370Item1: integer below minimum")); }
        if x > 10 { return Err(DeError::custom("Root370Item1: integer above maximum")); }
        
        Ok(Root370Item1(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root370Item2(pub i64);
impl std::ops::Deref for Root370Item2 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root370Item2 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 1 { return Err(DeError::custom("Root370Item2: integer below minimum")); }
        if x > 27 { return Err(DeError::custom("Root370Item2: integer above maximum")); }
        
        Ok(Root370Item2(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct Root370Item60(pub String);
impl std::ops::Deref for Root370Item60 {
    type Target = String;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root370Item60 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let s = String::deserialize(de)?;
        if !(s.starts_with("http://") || s.starts_with("https://") || s.starts_with("mailto:") || s.starts_with("tel:")) {
            return Err(DeError::custom("Root370Item60: expected URI scheme"));
        }
        Ok(Root370Item60(s))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root370Item62Item(pub i64);
impl std::ops::Deref for Root370Item62Item {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root370Item62Item {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 250 { return Err(DeError::custom("Root370Item62Item: integer below minimum")); }
        if x > 13312 { return Err(DeError::custom("Root370Item62Item: integer above maximum")); }
        
        Ok(Root370Item62Item(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root370Item630(pub i64);
impl std::ops::Deref for Root370Item630 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root370Item630 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 80 { return Err(DeError::custom("Root370Item630: integer below minimum")); }
        if x > 80 { return Err(DeError::custom("Root370Item630: integer above maximum")); }
        
        Ok(Root370Item630(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root370Item631(pub i64);
impl std::ops::Deref for Root370Item631 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root370Item631 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 92 { return Err(DeError::custom("Root370Item631: integer below minimum")); }
        if x > 92 { return Err(DeError::custom("Root370Item631: integer above maximum")); }
        
        Ok(Root370Item631(x))
    }
}
/// tuple len=2 (required first 2 slots)
#[derive(Debug, Deserialize)]
pub struct Root370Item63(
    pub Root370Item630,
    pub Root370Item631,
);

/// tuple len=4 (required first 4 slots)
#[derive(Debug, Deserialize)]
pub struct Root370Item6(
    pub Root370Item60,
    pub String,
    pub Option<Vec<Root370Item62Item>>,
    pub Root370Item63,
);

#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root370Item800(pub i64);
impl std::ops::Deref for Root370Item800 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root370Item800 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 3 { return Err(DeError::custom("Root370Item800: integer below minimum")); }
        if x > 3 { return Err(DeError::custom("Root370Item800: integer above maximum")); }
        
        Ok(Root370Item800(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub struct Root370Item801(pub f64);
impl std::ops::Deref for Root370Item801 {
    type Target = f64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root370Item801 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = f64::deserialize(de)?;
        if !x.is_finite() { return Err(DeError::custom("Root370Item801: non-finite number")); }
        if x < -115.005603699999995 { return Err(DeError::custom("Root370Item801: number below minimum")); }
        if x > 0.0 { return Err(DeError::custom("Root370Item801: number above maximum")); }
        
        Ok(Root370Item801(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub struct Root370Item802(pub f64);
impl std::ops::Deref for Root370Item802 {
    type Target = f64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root370Item802 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = f64::deserialize(de)?;
        if !x.is_finite() { return Err(DeError::custom("Root370Item802: non-finite number")); }
        if x < 0.0 { return Err(DeError::custom("Root370Item802: number below minimum")); }
        if x > 42.395631000000002 { return Err(DeError::custom("Root370Item802: number above maximum")); }
        
        Ok(Root370Item802(x))
    }
}
/// tuple len=3 (required first 3 slots)
#[derive(Debug, Deserialize)]
pub struct Root370Item80(
    pub Root370Item800,
    pub Root370Item801,
    pub Root370Item802,
);

#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub struct Root370Item810(pub f64);
impl std::ops::Deref for Root370Item810 {
    type Target = f64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root370Item810 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = f64::deserialize(de)?;
        if !x.is_finite() { return Err(DeError::custom("Root370Item810: non-finite number")); }
        if x < 0.0 { return Err(DeError::custom("Root370Item810: number below minimum")); }
        if x > 358.973880000000008 { return Err(DeError::custom("Root370Item810: number above maximum")); }
        
        Ok(Root370Item810(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root370Item811(pub i64);
impl std::ops::Deref for Root370Item811 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root370Item811 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 90 { return Err(DeError::custom("Root370Item811: integer below minimum")); }
        if x > 110 { return Err(DeError::custom("Root370Item811: integer above maximum")); }
        
        Ok(Root370Item811(x))
    }
}
/// tuple len=2 (required first 2 slots)
#[derive(Debug, Deserialize)]
pub struct Root370Item81(
    pub Root370Item810,
    pub Root370Item811,
);

#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root370Item82Item(pub i64);
impl std::ops::Deref for Root370Item82Item {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root370Item82Item {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 250 { return Err(DeError::custom("Root370Item82Item: integer below minimum")); }
        if x > 13312 { return Err(DeError::custom("Root370Item82Item: integer above maximum")); }
        
        Ok(Root370Item82Item(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root370Item83(pub i64);
impl std::ops::Deref for Root370Item83 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root370Item83 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 75 { return Err(DeError::custom("Root370Item83: integer below minimum")); }
        if x > 75 { return Err(DeError::custom("Root370Item83: integer above maximum")); }
        
        Ok(Root370Item83(x))
    }
}
/// tuple len=4 (required first 4 slots)
#[derive(Debug, Deserialize)]
pub struct Root370Item8(
    pub Root370Item80,
    pub Root370Item81,
    pub Vec<Root370Item82Item>,
    pub Root370Item83,
);

#[repr(transparent)]
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct Root370Item10(pub String);
impl std::ops::Deref for Root370Item10 {
    type Target = String;
    fn deref(&self) -> &Self::Target { &self.0 }
}
static RE_ROOT370ITEM10: Lazy<Regex> = Lazy::new(|| Regex::new("^0ahUKEwi.*").unwrap());
impl<'de> Deserialize<'de> for Root370Item10 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let s = String::deserialize(de)?;
        if !RE_ROOT370ITEM10.is_match(&s) {
            return Err(DeError::custom("Root370Item10: string failed pattern"));
        }
        Ok(Root370Item10(s))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct Root370Item15ItemItemItem(pub String);
impl std::ops::Deref for Root370Item15ItemItemItem {
    type Target = String;
    fn deref(&self) -> &Self::Target { &self.0 }
}
static RE_ROOT370ITEM15ITEMITEMITEM: Lazy<Regex> = Lazy::new(|| Regex::new("^0x8.*").unwrap());
impl<'de> Deserialize<'de> for Root370Item15ItemItemItem {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let s = String::deserialize(de)?;
        if !RE_ROOT370ITEM15ITEMITEMITEM.is_match(&s) {
            return Err(DeError::custom("Root370Item15ItemItemItem: string failed pattern"));
        }
        Ok(Root370Item15ItemItemItem(s))
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum Root370Item20 {
    Photo,
    StreetView,
}
impl<'de> Deserialize<'de> for Root370Item20 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let s = String::deserialize(de)?;
        match s.as_str() {
            "Photo" => Ok(Root370Item20::Photo),
            "Street View" => Ok(Root370Item20::StreetView),
            _ => Err(DeError::unknown_variant(&s, &[])),
        }
    }
}
impl serde::Serialize for Root370Item20 {
    fn serialize<S>(&self, ser: S) -> Result<S::Ok, S::Error> where S: serde::Serializer {
        match self {
            Root370Item20::Photo => ser.serialize_str("Photo"),
            Root370Item20::StreetView => ser.serialize_str("Street View"),
        }
    }
}

#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root370Item2110(pub i64);
impl std::ops::Deref for Root370Item2110 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root370Item2110 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 1 { return Err(DeError::custom("Root370Item2110: integer below minimum")); }
        if x > 10 { return Err(DeError::custom("Root370Item2110: integer above maximum")); }
        
        Ok(Root370Item2110(x))
    }
}
/// tuple len=2 (required first 2 slots)
#[derive(Debug, Deserialize)]
pub struct Root370Item211(
    pub Root370Item2110,
    pub String,
);

#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root370Item2120(pub i64);
impl std::ops::Deref for Root370Item2120 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root370Item2120 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 1 { return Err(DeError::custom("Root370Item2120: integer below minimum")); }
        if x > 10 { return Err(DeError::custom("Root370Item2120: integer above maximum")); }
        
        Ok(Root370Item2120(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root370Item2121(pub i64);
impl std::ops::Deref for Root370Item2121 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root370Item2121 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 2 { return Err(DeError::custom("Root370Item2121: integer below minimum")); }
        if x > 3 { return Err(DeError::custom("Root370Item2121: integer above maximum")); }
        
        Ok(Root370Item2121(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root370Item2122Item(pub i64);
impl std::ops::Deref for Root370Item2122Item {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root370Item2122Item {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 250 { return Err(DeError::custom("Root370Item2122Item: integer below minimum")); }
        if x > 13312 { return Err(DeError::custom("Root370Item2122Item: integer above maximum")); }
        
        Ok(Root370Item2122Item(x))
    }
}
/// tuple len=4 (required first 2 slots)
#[derive(Debug, Deserialize)]
pub struct Root370Item212(
    pub Root370Item2120,
    pub Root370Item2121,
    pub Option<Vec<Root370Item2122Item>>,
    pub Option<Vec<Null>>,
);

#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root370Item215ItemItem0Alt0(pub i64);
impl std::ops::Deref for Root370Item215ItemItem0Alt0 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root370Item215ItemItem0Alt0 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 2 { return Err(DeError::custom("Root370Item215ItemItem0Alt0: integer below minimum")); }
        if x > 2 { return Err(DeError::custom("Root370Item215ItemItem0Alt0: integer above maximum")); }
        
        Ok(Root370Item215ItemItem0Alt0(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub struct Root370Item215ItemItem0Alt12(pub f64);
impl std::ops::Deref for Root370Item215ItemItem0Alt12 {
    type Target = f64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root370Item215ItemItem0Alt12 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = f64::deserialize(de)?;
        if !x.is_finite() { return Err(DeError::custom("Root370Item215ItemItem0Alt12: non-finite number")); }
        if x < 0.0 { return Err(DeError::custom("Root370Item215ItemItem0Alt12: number below minimum")); }
        if x > 42.395631000000002 { return Err(DeError::custom("Root370Item215ItemItem0Alt12: number above maximum")); }
        
        Ok(Root370Item215ItemItem0Alt12(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub struct Root370Item215ItemItem0Alt13(pub f64);
impl std::ops::Deref for Root370Item215ItemItem0Alt13 {
    type Target = f64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root370Item215ItemItem0Alt13 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = f64::deserialize(de)?;
        if !x.is_finite() { return Err(DeError::custom("Root370Item215ItemItem0Alt13: non-finite number")); }
        if x < -115.005603699999995 { return Err(DeError::custom("Root370Item215ItemItem0Alt13: number below minimum")); }
        if x > 0.0 { return Err(DeError::custom("Root370Item215ItemItem0Alt13: number above maximum")); }
        
        Ok(Root370Item215ItemItem0Alt13(x))
    }
}
/// tuple len=4 (required first 4 slots)
#[derive(Debug, Deserialize)]
pub struct Root370Item215ItemItem0Alt1(
    pub Null,
    pub Null,
    pub Root370Item215ItemItem0Alt12,
    pub Root370Item215ItemItem0Alt13,
);

#[derive(Debug)]
pub enum Root370Item215ItemItem0 {
    V0(Root370Item215ItemItem0Alt0),
    V1(Root370Item215ItemItem0Alt1),
}

impl<'de> Deserialize<'de> for Root370Item215ItemItem0 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        // deserialize into a serde_json::Value once, then attempt each arm (strict)
        let val = serde_json::Value::deserialize(de)?;
        if let Ok(x) = <Root370Item215ItemItem0Alt0 as serde::Deserialize>::deserialize(val.clone()) { return Ok(Root370Item215ItemItem0::V0(x)); }
        if let Ok(x) = <Root370Item215ItemItem0Alt1 as serde::Deserialize>::deserialize(val.clone()) { return Ok(Root370Item215ItemItem0::V1(x)); }
        Err(DeError::custom("no union arm matched"))
    }
}

#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub struct Root370Item215ItemItem12(pub f64);
impl std::ops::Deref for Root370Item215ItemItem12 {
    type Target = f64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root370Item215ItemItem12 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = f64::deserialize(de)?;
        if !x.is_finite() { return Err(DeError::custom("Root370Item215ItemItem12: non-finite number")); }
        if x < 0.0 { return Err(DeError::custom("Root370Item215ItemItem12: number below minimum")); }
        if x > 2146.032000000000153 { return Err(DeError::custom("Root370Item215ItemItem12: number above maximum")); }
        
        Ok(Root370Item215ItemItem12(x))
    }
}
/// tuple len=3 (required first 3 slots)
#[derive(Debug, Deserialize)]
pub struct Root370Item215ItemItem1(
    pub Null,
    pub Null,
    pub Root370Item215ItemItem12,
);

#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub struct Root370Item215ItemItem20(pub f64);
impl std::ops::Deref for Root370Item215ItemItem20 {
    type Target = f64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root370Item215ItemItem20 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = f64::deserialize(de)?;
        if !x.is_finite() { return Err(DeError::custom("Root370Item215ItemItem20: non-finite number")); }
        if x < 0.0 { return Err(DeError::custom("Root370Item215ItemItem20: number below minimum")); }
        if x > 359.994000000000028 { return Err(DeError::custom("Root370Item215ItemItem20: number above maximum")); }
        
        Ok(Root370Item215ItemItem20(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub struct Root370Item215ItemItem21(pub f64);
impl std::ops::Deref for Root370Item215ItemItem21 {
    type Target = f64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root370Item215ItemItem21 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = f64::deserialize(de)?;
        if !x.is_finite() { return Err(DeError::custom("Root370Item215ItemItem21: non-finite number")); }
        if x < 83.816469999999995 { return Err(DeError::custom("Root370Item215ItemItem21: number below minimum")); }
        if x > 94.725830000000002 { return Err(DeError::custom("Root370Item215ItemItem21: number above maximum")); }
        
        Ok(Root370Item215ItemItem21(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub struct Root370Item215ItemItem22(pub f64);
impl std::ops::Deref for Root370Item215ItemItem22 {
    type Target = f64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root370Item215ItemItem22 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = f64::deserialize(de)?;
        if !x.is_finite() { return Err(DeError::custom("Root370Item215ItemItem22: non-finite number")); }
        if x < 0.0 { return Err(DeError::custom("Root370Item215ItemItem22: number below minimum")); }
        if x > 359.969879999999989 { return Err(DeError::custom("Root370Item215ItemItem22: number above maximum")); }
        
        Ok(Root370Item215ItemItem22(x))
    }
}
/// tuple len=3 (required first 3 slots)
#[derive(Debug, Deserialize)]
pub struct Root370Item215ItemItem2(
    pub Root370Item215ItemItem20,
    pub Root370Item215ItemItem21,
    pub Root370Item215ItemItem22,
);

/// tuple len=3 (required first 1 slots)
#[derive(Debug, Deserialize)]
pub struct Root370Item215ItemItem(
    pub Root370Item215ItemItem0,
    pub Option<Root370Item215ItemItem1>,
    pub Option<Root370Item215ItemItem2>,
);

#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root370Item2160(pub i64);
impl std::ops::Deref for Root370Item2160 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root370Item2160 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 1 { return Err(DeError::custom("Root370Item2160: integer below minimum")); }
        if x > 3 { return Err(DeError::custom("Root370Item2160: integer above maximum")); }
        
        Ok(Root370Item2160(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root370Item21630(pub i64);
impl std::ops::Deref for Root370Item21630 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root370Item21630 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 1 { return Err(DeError::custom("Root370Item21630: integer below minimum")); }
        if x > 14 { return Err(DeError::custom("Root370Item21630: integer above maximum")); }
        
        Ok(Root370Item21630(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root370Item21631(pub i64);
impl std::ops::Deref for Root370Item21631 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root370Item21631 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 1 { return Err(DeError::custom("Root370Item21631: integer below minimum")); }
        if x > 14 { return Err(DeError::custom("Root370Item21631: integer above maximum")); }
        
        Ok(Root370Item21631(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root370Item21632(pub i64);
impl std::ops::Deref for Root370Item21632 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root370Item21632 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 9 { return Err(DeError::custom("Root370Item21632: integer below minimum")); }
        if x > 9 { return Err(DeError::custom("Root370Item21632: integer above maximum")); }
        
        Ok(Root370Item21632(x))
    }
}
/// tuple len=3 (required first 1 slots)
#[derive(Debug, Deserialize)]
pub struct Root370Item2163(
    pub Root370Item21630,
    pub Option<Root370Item21631>,
    pub Option<Root370Item21632>,
);

#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root370Item216530(pub i64);
impl std::ops::Deref for Root370Item216530 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root370Item216530 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 6 { return Err(DeError::custom("Root370Item216530: integer below minimum")); }
        if x > 6 { return Err(DeError::custom("Root370Item216530: integer above maximum")); }
        
        Ok(Root370Item216530(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root370Item216531(pub i64);
impl std::ops::Deref for Root370Item216531 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root370Item216531 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 7 { return Err(DeError::custom("Root370Item216531: integer below minimum")); }
        if x > 8 { return Err(DeError::custom("Root370Item216531: integer above maximum")); }
        
        Ok(Root370Item216531(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root370Item216532(pub i64);
impl std::ops::Deref for Root370Item216532 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root370Item216532 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 4 { return Err(DeError::custom("Root370Item216532: integer below minimum")); }
        if x > 4 { return Err(DeError::custom("Root370Item216532: integer above maximum")); }
        
        Ok(Root370Item216532(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root370Item216533(pub i64);
impl std::ops::Deref for Root370Item216533 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root370Item216533 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 1 { return Err(DeError::custom("Root370Item216533: integer below minimum")); }
        if x > 5 { return Err(DeError::custom("Root370Item216533: integer above maximum")); }
        
        Ok(Root370Item216533(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root370Item216534(pub i64);
impl std::ops::Deref for Root370Item216534 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root370Item216534 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 2 { return Err(DeError::custom("Root370Item216534: integer below minimum")); }
        if x > 3 { return Err(DeError::custom("Root370Item216534: integer above maximum")); }
        
        Ok(Root370Item216534(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root370Item216535(pub i64);
impl std::ops::Deref for Root370Item216535 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root370Item216535 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 3 { return Err(DeError::custom("Root370Item216535: integer below minimum")); }
        if x > 3 { return Err(DeError::custom("Root370Item216535: integer above maximum")); }
        
        Ok(Root370Item216535(x))
    }
}
/// tuple len=6 (required first 1 slots)
#[derive(Debug, Deserialize)]
pub struct Root370Item21653(
    pub Root370Item216530,
    pub Option<Root370Item216531>,
    pub Option<Root370Item216532>,
    pub Option<Root370Item216533>,
    pub Option<Root370Item216534>,
    pub Option<Root370Item216535>,
);

/// tuple len=4 (required first 4 slots)
#[derive(Debug, Deserialize)]
pub struct Root370Item2165(
    pub Null,
    pub Null,
    pub String,
    pub Root370Item21653,
);

#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root370Item21680(pub i64);
impl std::ops::Deref for Root370Item21680 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root370Item21680 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 2007 { return Err(DeError::custom("Root370Item21680: integer below minimum")); }
        if x > 2025 { return Err(DeError::custom("Root370Item21680: integer above maximum")); }
        
        Ok(Root370Item21680(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root370Item21681(pub i64);
impl std::ops::Deref for Root370Item21681 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root370Item21681 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 1 { return Err(DeError::custom("Root370Item21681: integer below minimum")); }
        if x > 12 { return Err(DeError::custom("Root370Item21681: integer above maximum")); }
        
        Ok(Root370Item21681(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root370Item21682(pub i64);
impl std::ops::Deref for Root370Item21682 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root370Item21682 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 1 { return Err(DeError::custom("Root370Item21682: integer below minimum")); }
        if x > 31 { return Err(DeError::custom("Root370Item21682: integer above maximum")); }
        
        Ok(Root370Item21682(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root370Item21683(pub i64);
impl std::ops::Deref for Root370Item21683 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root370Item21683 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 0 { return Err(DeError::custom("Root370Item21683: integer below minimum")); }
        if x > 23 { return Err(DeError::custom("Root370Item21683: integer above maximum")); }
        
        Ok(Root370Item21683(x))
    }
}
/// tuple len=4 (required first 4 slots)
#[derive(Debug, Deserialize)]
pub struct Root370Item2168(
    pub Root370Item21680,
    pub Root370Item21681,
    pub Root370Item21682,
    pub Root370Item21683,
);

/// tuple len=9 (required first 9 slots)
#[derive(Debug, Deserialize)]
pub struct Root370Item216(
    pub Root370Item2160,
    pub Null,
    pub Null,
    pub Option<Root370Item2163>,
    pub Null,
    pub Root370Item2165,
    pub Null,
    pub Null,
    pub Root370Item2168,
);

/// tuple len=20 (required first 20 slots)
#[derive(Debug, Deserialize)]
pub struct Root370Item21(
    pub Null,
    pub Root370Item211,
    pub Root370Item212,
    pub Null,
    pub Null,
    pub Vec<Vec<Root370Item215ItemItem>>,
    pub Root370Item216,
    pub Null,
    pub Null,
    pub Null,
    pub Null,
    pub Null,
    pub Null,
    pub Null,
    pub Null,
    pub Null,
    pub Null,
    pub Null,
    pub Null,
    pub Vec<String>,
);

#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root370Item22(pub i64);
impl std::ops::Deref for Root370Item22 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root370Item22 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 1 { return Err(DeError::custom("Root370Item22: integer below minimum")); }
        if x > 3 { return Err(DeError::custom("Root370Item22: integer above maximum")); }
        
        Ok(Root370Item22(x))
    }
}
/// tuple len=32 (required first 32 slots)
#[derive(Debug, Deserialize)]
pub struct Root370Item(
    pub String,
    pub Root370Item1,
    pub Root370Item2,
    pub Option<String>,
    pub Null,
    pub Null,
    pub Root370Item6,
    pub Null,
    pub Root370Item8,
    pub String,
    pub Root370Item10,
    pub Null,
    pub Null,
    pub Null,
    pub Null,
    pub Vec<Vec<Vec<Root370Item15ItemItemItem>>>,
    pub Null,
    pub Option<Vec<String>>,
    pub Null,
    pub Null,
    pub Option<Root370Item20>,
    pub Root370Item21,
    pub Root370Item22,
    pub Null,
    pub Null,
    pub Null,
    pub Null,
    pub Null,
    pub Null,
    pub Vec<String>,
    pub Null,
    pub String,
);

#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root371(pub i64);
impl std::ops::Deref for Root371 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root371 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 1 { return Err(DeError::custom("Root371: integer below minimum")); }
        if x > 5490 { return Err(DeError::custom("Root371: integer above maximum")); }
        
        Ok(Root371(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct Root375(pub String);
impl std::ops::Deref for Root375 {
    type Target = String;
    fn deref(&self) -> &Self::Target { &self.0 }
}
static RE_ROOT375: Lazy<Regex> = Lazy::new(|| Regex::new("^EvgDKYQi49-NlUMIDwAAAAEAAAMAAAAAA.*").unwrap());
impl<'de> Deserialize<'de> for Root375 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let s = String::deserialize(de)?;
        if !RE_ROOT375.is_match(&s) {
            return Err(DeError::custom("Root375: string failed pattern"));
        }
        Ok(Root375(s))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root3780Item0(pub i64);
impl std::ops::Deref for Root3780Item0 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root3780Item0 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 1 { return Err(DeError::custom("Root3780Item0: integer below minimum")); }
        if x > 1 { return Err(DeError::custom("Root3780Item0: integer above maximum")); }
        
        Ok(Root3780Item0(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root3780Item1(pub i64);
impl std::ops::Deref for Root3780Item1 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root3780Item1 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 0 { return Err(DeError::custom("Root3780Item1: integer below minimum")); }
        if x > 199 { return Err(DeError::custom("Root3780Item1: integer above maximum")); }
        
        Ok(Root3780Item1(x))
    }
}
/// tuple len=2 (required first 2 slots)
#[derive(Debug, Deserialize)]
pub struct Root3780Item(
    pub Root3780Item0,
    pub Root3780Item1,
);

#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root3781(pub i64);
impl std::ops::Deref for Root3781 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root3781 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 0 { return Err(DeError::custom("Root3781: integer below minimum")); }
        if x > 60 { return Err(DeError::custom("Root3781: integer above maximum")); }
        
        Ok(Root3781(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root3783(pub i64);
impl std::ops::Deref for Root3783 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root3783 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 0 { return Err(DeError::custom("Root3783: integer below minimum")); }
        if x > 199 { return Err(DeError::custom("Root3783: integer above maximum")); }
        
        Ok(Root3783(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root3784(pub i64);
impl std::ops::Deref for Root3784 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root3784 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 0 { return Err(DeError::custom("Root3784: integer below minimum")); }
        if x > 200 { return Err(DeError::custom("Root3784: integer above maximum")); }
        
        Ok(Root3784(x))
    }
}
/// tuple len=5 (required first 5 slots)
#[derive(Debug, Deserialize)]
pub struct Root378(
    pub Vec<Root3780Item>,
    pub Root3781,
    pub Null,
    pub Root3783,
    pub Root3784,
);

/// tuple len=9 (required first 8 slots)
#[derive(Debug, Deserialize)]
pub struct Root37(
    pub Option<Vec<Root370Item>>,
    pub Option<Root371>,
    pub Null,
    pub String,
    pub Null,
    pub Option<Root375>,
    pub Null,
    pub Null,
    pub Option<Root378>,
);

#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root40(pub i64);
impl std::ops::Deref for Root40 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root40 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 1 { return Err(DeError::custom("Root40: integer below minimum")); }
        if x > 1 { return Err(DeError::custom("Root40: integer above maximum")); }
        
        Ok(Root40(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct Root490(pub String);
impl std::ops::Deref for Root490 {
    type Target = String;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root490 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let s = String::deserialize(de)?;
        if !(s.starts_with("http://") || s.starts_with("https://") || s.starts_with("mailto:") || s.starts_with("tel:")) {
            return Err(DeError::custom("Root490: expected URI scheme"));
        }
        Ok(Root490(s))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct Root491(pub String);
impl std::ops::Deref for Root491 {
    type Target = String;
    fn deref(&self) -> &Self::Target { &self.0 }
}
static RE_ROOT491: Lazy<Regex> = Lazy::new(|| Regex::new("^Claim this business.*").unwrap());
impl<'de> Deserialize<'de> for Root491 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let s = String::deserialize(de)?;
        if !RE_ROOT491.is_match(&s) {
            return Err(DeError::custom("Root491: string failed pattern"));
        }
        Ok(Root491(s))
    }
}
/// tuple len=4 (required first 4 slots)
#[derive(Debug, Deserialize)]
pub struct Root49(
    pub Root490,
    pub Root491,
    pub Null,
    pub String,
);

/// tuple len=9 (required first 9 slots)
#[derive(Debug, Deserialize)]
pub struct Root57(
    pub Null,
    pub String,
    pub Option<String>,
    pub Null,
    pub Null,
    pub Null,
    pub Null,
    pub Null,
    pub String,
);

#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root61(pub i64);
impl std::ops::Deref for Root61 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root61 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 1 { return Err(DeError::custom("Root61: integer below minimum")); }
        if x > 1 { return Err(DeError::custom("Root61: integer above maximum")); }
        
        Ok(Root61(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root64ItemAlt0(pub i64);
impl std::ops::Deref for Root64ItemAlt0 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root64ItemAlt0 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 1 { return Err(DeError::custom("Root64ItemAlt0: integer below minimum")); }
        if x > 2 { return Err(DeError::custom("Root64ItemAlt0: integer above maximum")); }
        
        Ok(Root64ItemAlt0(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct Root64ItemAlt1(pub String);
impl std::ops::Deref for Root64ItemAlt1 {
    type Target = String;
    fn deref(&self) -> &Self::Target { &self.0 }
}
static RE_ROOT64ITEMALT1: Lazy<Regex> = Lazy::new(|| Regex::new("^2-star hotel.*").unwrap());
impl<'de> Deserialize<'de> for Root64ItemAlt1 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let s = String::deserialize(de)?;
        if !RE_ROOT64ITEMALT1.is_match(&s) {
            return Err(DeError::custom("Root64ItemAlt1: string failed pattern"));
        }
        Ok(Root64ItemAlt1(s))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root64ItemAlt2ItemItemAlt0(pub i64);
impl std::ops::Deref for Root64ItemAlt2ItemItemAlt0 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root64ItemAlt2ItemItemAlt0 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 1 { return Err(DeError::custom("Root64ItemAlt2ItemItemAlt0: integer below minimum")); }
        if x > 22 { return Err(DeError::custom("Root64ItemAlt2ItemItemAlt0: integer above maximum")); }
        
        Ok(Root64ItemAlt2ItemItemAlt0(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct Root64ItemAlt2ItemItemAlt1(pub String);
impl std::ops::Deref for Root64ItemAlt2ItemItemAlt1 {
    type Target = String;
    fn deref(&self) -> &Self::Target { &self.0 }
}
static RE_ROOT64ITEMALT2ITEMITEMALT1: Lazy<Regex> = Lazy::new(|| Regex::new("^Free Wi-Fi.*").unwrap());
impl<'de> Deserialize<'de> for Root64ItemAlt2ItemItemAlt1 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let s = String::deserialize(de)?;
        if !RE_ROOT64ITEMALT2ITEMITEMALT1.is_match(&s) {
            return Err(DeError::custom("Root64ItemAlt2ItemItemAlt1: string failed pattern"));
        }
        Ok(Root64ItemAlt2ItemItemAlt1(s))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root64ItemAlt2ItemItemAlt2ItemItem(pub i64);
impl std::ops::Deref for Root64ItemAlt2ItemItemAlt2ItemItem {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root64ItemAlt2ItemItemAlt2ItemItem {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 1 { return Err(DeError::custom("Root64ItemAlt2ItemItemAlt2ItemItem: integer below minimum")); }
        if x > 2 { return Err(DeError::custom("Root64ItemAlt2ItemItemAlt2ItemItem: integer above maximum")); }
        
        Ok(Root64ItemAlt2ItemItemAlt2ItemItem(x))
    }
}
#[derive(Debug)]
pub enum Root64ItemAlt2ItemItem {
    V0(Root64ItemAlt2ItemItemAlt0),
    V1(Root64ItemAlt2ItemItemAlt1),
    V2(Vec<Vec<Root64ItemAlt2ItemItemAlt2ItemItem>>),
}

impl<'de> Deserialize<'de> for Root64ItemAlt2ItemItem {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        // deserialize into a serde_json::Value once, then attempt each arm (strict)
        let val = serde_json::Value::deserialize(de)?;
        if let Ok(x) = <Root64ItemAlt2ItemItemAlt0 as serde::Deserialize>::deserialize(val.clone()) { return Ok(Root64ItemAlt2ItemItem::V0(x)); }
        if let Ok(x) = <Root64ItemAlt2ItemItemAlt1 as serde::Deserialize>::deserialize(val.clone()) { return Ok(Root64ItemAlt2ItemItem::V1(x)); }
        if let Ok(x) = <Vec<Vec<Root64ItemAlt2ItemItemAlt2ItemItem>> as serde::Deserialize>::deserialize(val.clone()) { return Ok(Root64ItemAlt2ItemItem::V2(x)); }
        Err(DeError::custom("no union arm matched"))
    }
}

#[derive(Debug)]
pub enum Root64Item {
    V0(Root64ItemAlt0),
    V1(Root64ItemAlt1),
    V2(Vec<Vec<Option<Root64ItemAlt2ItemItem>>>),
}

impl<'de> Deserialize<'de> for Root64Item {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        // deserialize into a serde_json::Value once, then attempt each arm (strict)
        let val = serde_json::Value::deserialize(de)?;
        if let Ok(x) = <Root64ItemAlt0 as serde::Deserialize>::deserialize(val.clone()) { return Ok(Root64Item::V0(x)); }
        if let Ok(x) = <Root64ItemAlt1 as serde::Deserialize>::deserialize(val.clone()) { return Ok(Root64Item::V1(x)); }
        if let Ok(x) = <Vec<Vec<Option<Root64ItemAlt2ItemItem>>> as serde::Deserialize>::deserialize(val.clone()) { return Ok(Root64Item::V2(x)); }
        Err(DeError::custom("no union arm matched"))
    }
}

#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root67(pub i64);
impl std::ops::Deref for Root67 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root67 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 1 { return Err(DeError::custom("Root67: integer below minimum")); }
        if x > 1 { return Err(DeError::custom("Root67: integer above maximum")); }
        
        Ok(Root67(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root72ItemItem1(pub i64);
impl std::ops::Deref for Root72ItemItem1 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root72ItemItem1 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 0 { return Err(DeError::custom("Root72ItemItem1: integer below minimum")); }
        if x > 10 { return Err(DeError::custom("Root72ItemItem1: integer above maximum")); }
        
        Ok(Root72ItemItem1(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root72ItemItem2(pub i64);
impl std::ops::Deref for Root72ItemItem2 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root72ItemItem2 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 1 { return Err(DeError::custom("Root72ItemItem2: integer below minimum")); }
        if x > 27 { return Err(DeError::custom("Root72ItemItem2: integer above maximum")); }
        
        Ok(Root72ItemItem2(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct Root72ItemItem60(pub String);
impl std::ops::Deref for Root72ItemItem60 {
    type Target = String;
    fn deref(&self) -> &Self::Target { &self.0 }
}
static RE_ROOT72ITEMITEM60: Lazy<Regex> = Lazy::new(|| Regex::new("^https://.*").unwrap());
impl<'de> Deserialize<'de> for Root72ItemItem60 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let s = String::deserialize(de)?;
        if !RE_ROOT72ITEMITEM60.is_match(&s) {
            return Err(DeError::custom("Root72ItemItem60: string failed pattern"));
        }
        Ok(Root72ItemItem60(s))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root72ItemItem62Item(pub i64);
impl std::ops::Deref for Root72ItemItem62Item {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root72ItemItem62Item {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 250 { return Err(DeError::custom("Root72ItemItem62Item: integer below minimum")); }
        if x > 13312 { return Err(DeError::custom("Root72ItemItem62Item: integer above maximum")); }
        
        Ok(Root72ItemItem62Item(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root72ItemItem63Item(pub i64);
impl std::ops::Deref for Root72ItemItem63Item {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root72ItemItem63Item {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 86 { return Err(DeError::custom("Root72ItemItem63Item: integer below minimum")); }
        if x > 408 { return Err(DeError::custom("Root72ItemItem63Item: integer above maximum")); }
        
        Ok(Root72ItemItem63Item(x))
    }
}
/// tuple len=4 (required first 4 slots)
#[derive(Debug, Deserialize)]
pub struct Root72ItemItem6(
    pub Root72ItemItem60,
    pub String,
    pub Option<Vec<Root72ItemItem62Item>>,
    pub Vec<Root72ItemItem63Item>,
);

#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root72ItemItem800(pub i64);
impl std::ops::Deref for Root72ItemItem800 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root72ItemItem800 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 3 { return Err(DeError::custom("Root72ItemItem800: integer below minimum")); }
        if x > 3 { return Err(DeError::custom("Root72ItemItem800: integer above maximum")); }
        
        Ok(Root72ItemItem800(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub struct Root72ItemItem801(pub f64);
impl std::ops::Deref for Root72ItemItem801 {
    type Target = f64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root72ItemItem801 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = f64::deserialize(de)?;
        if !x.is_finite() { return Err(DeError::custom("Root72ItemItem801: non-finite number")); }
        if x < -115.005603699999995 { return Err(DeError::custom("Root72ItemItem801: number below minimum")); }
        if x > 0.0 { return Err(DeError::custom("Root72ItemItem801: number above maximum")); }
        
        Ok(Root72ItemItem801(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub struct Root72ItemItem802(pub f64);
impl std::ops::Deref for Root72ItemItem802 {
    type Target = f64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root72ItemItem802 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = f64::deserialize(de)?;
        if !x.is_finite() { return Err(DeError::custom("Root72ItemItem802: non-finite number")); }
        if x < 0.0 { return Err(DeError::custom("Root72ItemItem802: number below minimum")); }
        if x > 42.395631000000002 { return Err(DeError::custom("Root72ItemItem802: number above maximum")); }
        
        Ok(Root72ItemItem802(x))
    }
}
/// tuple len=3 (required first 3 slots)
#[derive(Debug, Deserialize)]
pub struct Root72ItemItem80(
    pub Root72ItemItem800,
    pub Root72ItemItem801,
    pub Root72ItemItem802,
);

#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub struct Root72ItemItem810(pub f64);
impl std::ops::Deref for Root72ItemItem810 {
    type Target = f64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root72ItemItem810 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = f64::deserialize(de)?;
        if !x.is_finite() { return Err(DeError::custom("Root72ItemItem810: non-finite number")); }
        if x < 0.0 { return Err(DeError::custom("Root72ItemItem810: number below minimum")); }
        if x > 358.973880000000008 { return Err(DeError::custom("Root72ItemItem810: number above maximum")); }
        
        Ok(Root72ItemItem810(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root72ItemItem811(pub i64);
impl std::ops::Deref for Root72ItemItem811 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root72ItemItem811 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 90 { return Err(DeError::custom("Root72ItemItem811: integer below minimum")); }
        if x > 100 { return Err(DeError::custom("Root72ItemItem811: integer above maximum")); }
        
        Ok(Root72ItemItem811(x))
    }
}
/// tuple len=2 (required first 2 slots)
#[derive(Debug, Deserialize)]
pub struct Root72ItemItem81(
    pub Root72ItemItem810,
    pub Root72ItemItem811,
);

#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root72ItemItem82Item(pub i64);
impl std::ops::Deref for Root72ItemItem82Item {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root72ItemItem82Item {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 250 { return Err(DeError::custom("Root72ItemItem82Item: integer below minimum")); }
        if x > 13312 { return Err(DeError::custom("Root72ItemItem82Item: integer above maximum")); }
        
        Ok(Root72ItemItem82Item(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root72ItemItem83(pub i64);
impl std::ops::Deref for Root72ItemItem83 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root72ItemItem83 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 75 { return Err(DeError::custom("Root72ItemItem83: integer below minimum")); }
        if x > 75 { return Err(DeError::custom("Root72ItemItem83: integer above maximum")); }
        
        Ok(Root72ItemItem83(x))
    }
}
/// tuple len=4 (required first 4 slots)
#[derive(Debug, Deserialize)]
pub struct Root72ItemItem8(
    pub Root72ItemItem80,
    pub Root72ItemItem81,
    pub Vec<Root72ItemItem82Item>,
    pub Root72ItemItem83,
);

#[repr(transparent)]
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct Root72ItemItem15ItemItemItem(pub String);
impl std::ops::Deref for Root72ItemItem15ItemItemItem {
    type Target = String;
    fn deref(&self) -> &Self::Target { &self.0 }
}
static RE_ROOT72ITEMITEM15ITEMITEMITEM: Lazy<Regex> = Lazy::new(|| Regex::new("^0x8.*").unwrap());
impl<'de> Deserialize<'de> for Root72ItemItem15ItemItemItem {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let s = String::deserialize(de)?;
        if !RE_ROOT72ITEMITEM15ITEMITEMITEM.is_match(&s) {
            return Err(DeError::custom("Root72ItemItem15ItemItemItem: string failed pattern"));
        }
        Ok(Root72ItemItem15ItemItemItem(s))
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum Root72ItemItem20 {
    Photo,
    StreetView,
    Video,
}
impl<'de> Deserialize<'de> for Root72ItemItem20 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let s = String::deserialize(de)?;
        match s.as_str() {
            "Photo" => Ok(Root72ItemItem20::Photo),
            "Street View" => Ok(Root72ItemItem20::StreetView),
            "Video" => Ok(Root72ItemItem20::Video),
            _ => Err(DeError::unknown_variant(&s, &[])),
        }
    }
}
impl serde::Serialize for Root72ItemItem20 {
    fn serialize<S>(&self, ser: S) -> Result<S::Ok, S::Error> where S: serde::Serializer {
        match self {
            Root72ItemItem20::Photo => ser.serialize_str("Photo"),
            Root72ItemItem20::StreetView => ser.serialize_str("Street View"),
            Root72ItemItem20::Video => ser.serialize_str("Video"),
        }
    }
}

#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root72ItemItem2110(pub i64);
impl std::ops::Deref for Root72ItemItem2110 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root72ItemItem2110 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 1 { return Err(DeError::custom("Root72ItemItem2110: integer below minimum")); }
        if x > 10 { return Err(DeError::custom("Root72ItemItem2110: integer above maximum")); }
        
        Ok(Root72ItemItem2110(x))
    }
}
/// tuple len=2 (required first 2 slots)
#[derive(Debug, Deserialize)]
pub struct Root72ItemItem211(
    pub Root72ItemItem2110,
    pub String,
);

#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root72ItemItem2120(pub i64);
impl std::ops::Deref for Root72ItemItem2120 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root72ItemItem2120 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 1 { return Err(DeError::custom("Root72ItemItem2120: integer below minimum")); }
        if x > 10 { return Err(DeError::custom("Root72ItemItem2120: integer above maximum")); }
        
        Ok(Root72ItemItem2120(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root72ItemItem2121(pub i64);
impl std::ops::Deref for Root72ItemItem2121 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root72ItemItem2121 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 2 { return Err(DeError::custom("Root72ItemItem2121: integer below minimum")); }
        if x > 4 { return Err(DeError::custom("Root72ItemItem2121: integer above maximum")); }
        
        Ok(Root72ItemItem2121(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root72ItemItem2122Item(pub i64);
impl std::ops::Deref for Root72ItemItem2122Item {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root72ItemItem2122Item {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 250 { return Err(DeError::custom("Root72ItemItem2122Item: integer below minimum")); }
        if x > 13312 { return Err(DeError::custom("Root72ItemItem2122Item: integer above maximum")); }
        
        Ok(Root72ItemItem2122Item(x))
    }
}
/// tuple len=4 (required first 2 slots)
#[derive(Debug, Deserialize)]
pub struct Root72ItemItem212(
    pub Root72ItemItem2120,
    pub Root72ItemItem2121,
    pub Option<Vec<Root72ItemItem2122Item>>,
    pub Option<Vec<Null>>,
);

#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root72ItemItem215ItemItem0Alt0(pub i64);
impl std::ops::Deref for Root72ItemItem215ItemItem0Alt0 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root72ItemItem215ItemItem0Alt0 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 2 { return Err(DeError::custom("Root72ItemItem215ItemItem0Alt0: integer below minimum")); }
        if x > 2 { return Err(DeError::custom("Root72ItemItem215ItemItem0Alt0: integer above maximum")); }
        
        Ok(Root72ItemItem215ItemItem0Alt0(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub struct Root72ItemItem215ItemItem0Alt12(pub f64);
impl std::ops::Deref for Root72ItemItem215ItemItem0Alt12 {
    type Target = f64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root72ItemItem215ItemItem0Alt12 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = f64::deserialize(de)?;
        if !x.is_finite() { return Err(DeError::custom("Root72ItemItem215ItemItem0Alt12: non-finite number")); }
        if x < 0.0 { return Err(DeError::custom("Root72ItemItem215ItemItem0Alt12: number below minimum")); }
        if x > 42.395631000000002 { return Err(DeError::custom("Root72ItemItem215ItemItem0Alt12: number above maximum")); }
        
        Ok(Root72ItemItem215ItemItem0Alt12(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub struct Root72ItemItem215ItemItem0Alt13(pub f64);
impl std::ops::Deref for Root72ItemItem215ItemItem0Alt13 {
    type Target = f64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root72ItemItem215ItemItem0Alt13 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = f64::deserialize(de)?;
        if !x.is_finite() { return Err(DeError::custom("Root72ItemItem215ItemItem0Alt13: non-finite number")); }
        if x < -115.005603699999995 { return Err(DeError::custom("Root72ItemItem215ItemItem0Alt13: number below minimum")); }
        if x > 0.0 { return Err(DeError::custom("Root72ItemItem215ItemItem0Alt13: number above maximum")); }
        
        Ok(Root72ItemItem215ItemItem0Alt13(x))
    }
}
/// tuple len=4 (required first 4 slots)
#[derive(Debug, Deserialize)]
pub struct Root72ItemItem215ItemItem0Alt1(
    pub Null,
    pub Null,
    pub Root72ItemItem215ItemItem0Alt12,
    pub Root72ItemItem215ItemItem0Alt13,
);

#[derive(Debug)]
pub enum Root72ItemItem215ItemItem0 {
    V0(Root72ItemItem215ItemItem0Alt0),
    V1(Root72ItemItem215ItemItem0Alt1),
}

impl<'de> Deserialize<'de> for Root72ItemItem215ItemItem0 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        // deserialize into a serde_json::Value once, then attempt each arm (strict)
        let val = serde_json::Value::deserialize(de)?;
        if let Ok(x) = <Root72ItemItem215ItemItem0Alt0 as serde::Deserialize>::deserialize(val.clone()) { return Ok(Root72ItemItem215ItemItem0::V0(x)); }
        if let Ok(x) = <Root72ItemItem215ItemItem0Alt1 as serde::Deserialize>::deserialize(val.clone()) { return Ok(Root72ItemItem215ItemItem0::V1(x)); }
        Err(DeError::custom("no union arm matched"))
    }
}

#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub struct Root72ItemItem215ItemItem12(pub f64);
impl std::ops::Deref for Root72ItemItem215ItemItem12 {
    type Target = f64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root72ItemItem215ItemItem12 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = f64::deserialize(de)?;
        if !x.is_finite() { return Err(DeError::custom("Root72ItemItem215ItemItem12: non-finite number")); }
        if x < 0.0 { return Err(DeError::custom("Root72ItemItem215ItemItem12: number below minimum")); }
        if x > 2146.032000000000153 { return Err(DeError::custom("Root72ItemItem215ItemItem12: number above maximum")); }
        
        Ok(Root72ItemItem215ItemItem12(x))
    }
}
/// tuple len=3 (required first 3 slots)
#[derive(Debug, Deserialize)]
pub struct Root72ItemItem215ItemItem1(
    pub Null,
    pub Null,
    pub Root72ItemItem215ItemItem12,
);

#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub struct Root72ItemItem215ItemItem20(pub f64);
impl std::ops::Deref for Root72ItemItem215ItemItem20 {
    type Target = f64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root72ItemItem215ItemItem20 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = f64::deserialize(de)?;
        if !x.is_finite() { return Err(DeError::custom("Root72ItemItem215ItemItem20: non-finite number")); }
        if x < 0.0 { return Err(DeError::custom("Root72ItemItem215ItemItem20: number below minimum")); }
        if x > 359.994000000000028 { return Err(DeError::custom("Root72ItemItem215ItemItem20: number above maximum")); }
        
        Ok(Root72ItemItem215ItemItem20(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub struct Root72ItemItem215ItemItem21(pub f64);
impl std::ops::Deref for Root72ItemItem215ItemItem21 {
    type Target = f64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root72ItemItem215ItemItem21 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = f64::deserialize(de)?;
        if !x.is_finite() { return Err(DeError::custom("Root72ItemItem215ItemItem21: non-finite number")); }
        if x < 85.543099999999995 { return Err(DeError::custom("Root72ItemItem215ItemItem21: number below minimum")); }
        if x > 94.725830000000002 { return Err(DeError::custom("Root72ItemItem215ItemItem21: number above maximum")); }
        
        Ok(Root72ItemItem215ItemItem21(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub struct Root72ItemItem215ItemItem22(pub f64);
impl std::ops::Deref for Root72ItemItem215ItemItem22 {
    type Target = f64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root72ItemItem215ItemItem22 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = f64::deserialize(de)?;
        if !x.is_finite() { return Err(DeError::custom("Root72ItemItem215ItemItem22: non-finite number")); }
        if x < 0.0 { return Err(DeError::custom("Root72ItemItem215ItemItem22: number below minimum")); }
        if x > 359.969879999999989 { return Err(DeError::custom("Root72ItemItem215ItemItem22: number above maximum")); }
        
        Ok(Root72ItemItem215ItemItem22(x))
    }
}
/// tuple len=3 (required first 3 slots)
#[derive(Debug, Deserialize)]
pub struct Root72ItemItem215ItemItem2(
    pub Root72ItemItem215ItemItem20,
    pub Root72ItemItem215ItemItem21,
    pub Root72ItemItem215ItemItem22,
);

/// tuple len=3 (required first 1 slots)
#[derive(Debug, Deserialize)]
pub struct Root72ItemItem215ItemItem(
    pub Root72ItemItem215ItemItem0,
    pub Option<Root72ItemItem215ItemItem1>,
    pub Option<Root72ItemItem215ItemItem2>,
);

#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root72ItemItem2160(pub i64);
impl std::ops::Deref for Root72ItemItem2160 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root72ItemItem2160 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 1 { return Err(DeError::custom("Root72ItemItem2160: integer below minimum")); }
        if x > 3 { return Err(DeError::custom("Root72ItemItem2160: integer above maximum")); }
        
        Ok(Root72ItemItem2160(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root72ItemItem21630(pub i64);
impl std::ops::Deref for Root72ItemItem21630 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root72ItemItem21630 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 1 { return Err(DeError::custom("Root72ItemItem21630: integer below minimum")); }
        if x > 14 { return Err(DeError::custom("Root72ItemItem21630: integer above maximum")); }
        
        Ok(Root72ItemItem21630(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root72ItemItem21631(pub i64);
impl std::ops::Deref for Root72ItemItem21631 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root72ItemItem21631 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 1 { return Err(DeError::custom("Root72ItemItem21631: integer below minimum")); }
        if x > 14 { return Err(DeError::custom("Root72ItemItem21631: integer above maximum")); }
        
        Ok(Root72ItemItem21631(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root72ItemItem21632(pub i64);
impl std::ops::Deref for Root72ItemItem21632 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root72ItemItem21632 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 9 { return Err(DeError::custom("Root72ItemItem21632: integer below minimum")); }
        if x > 9 { return Err(DeError::custom("Root72ItemItem21632: integer above maximum")); }
        
        Ok(Root72ItemItem21632(x))
    }
}
/// tuple len=3 (required first 1 slots)
#[derive(Debug, Deserialize)]
pub struct Root72ItemItem2163(
    pub Root72ItemItem21630,
    pub Option<Root72ItemItem21631>,
    pub Option<Root72ItemItem21632>,
);

#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root72ItemItem216530(pub i64);
impl std::ops::Deref for Root72ItemItem216530 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root72ItemItem216530 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 6 { return Err(DeError::custom("Root72ItemItem216530: integer below minimum")); }
        if x > 6 { return Err(DeError::custom("Root72ItemItem216530: integer above maximum")); }
        
        Ok(Root72ItemItem216530(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root72ItemItem216531(pub i64);
impl std::ops::Deref for Root72ItemItem216531 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root72ItemItem216531 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 7 { return Err(DeError::custom("Root72ItemItem216531: integer below minimum")); }
        if x > 8 { return Err(DeError::custom("Root72ItemItem216531: integer above maximum")); }
        
        Ok(Root72ItemItem216531(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root72ItemItem216532(pub i64);
impl std::ops::Deref for Root72ItemItem216532 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root72ItemItem216532 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 4 { return Err(DeError::custom("Root72ItemItem216532: integer below minimum")); }
        if x > 4 { return Err(DeError::custom("Root72ItemItem216532: integer above maximum")); }
        
        Ok(Root72ItemItem216532(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root72ItemItem216533(pub i64);
impl std::ops::Deref for Root72ItemItem216533 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root72ItemItem216533 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 1 { return Err(DeError::custom("Root72ItemItem216533: integer below minimum")); }
        if x > 5 { return Err(DeError::custom("Root72ItemItem216533: integer above maximum")); }
        
        Ok(Root72ItemItem216533(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root72ItemItem216534(pub i64);
impl std::ops::Deref for Root72ItemItem216534 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root72ItemItem216534 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 2 { return Err(DeError::custom("Root72ItemItem216534: integer below minimum")); }
        if x > 3 { return Err(DeError::custom("Root72ItemItem216534: integer above maximum")); }
        
        Ok(Root72ItemItem216534(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root72ItemItem216535(pub i64);
impl std::ops::Deref for Root72ItemItem216535 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root72ItemItem216535 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 3 { return Err(DeError::custom("Root72ItemItem216535: integer below minimum")); }
        if x > 3 { return Err(DeError::custom("Root72ItemItem216535: integer above maximum")); }
        
        Ok(Root72ItemItem216535(x))
    }
}
/// tuple len=6 (required first 1 slots)
#[derive(Debug, Deserialize)]
pub struct Root72ItemItem21653(
    pub Root72ItemItem216530,
    pub Option<Root72ItemItem216531>,
    pub Option<Root72ItemItem216532>,
    pub Option<Root72ItemItem216533>,
    pub Option<Root72ItemItem216534>,
    pub Option<Root72ItemItem216535>,
);

/// tuple len=4 (required first 4 slots)
#[derive(Debug, Deserialize)]
pub struct Root72ItemItem2165(
    pub Null,
    pub Null,
    pub String,
    pub Root72ItemItem21653,
);

#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root72ItemItem21680(pub i64);
impl std::ops::Deref for Root72ItemItem21680 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root72ItemItem21680 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 2007 { return Err(DeError::custom("Root72ItemItem21680: integer below minimum")); }
        if x > 2025 { return Err(DeError::custom("Root72ItemItem21680: integer above maximum")); }
        
        Ok(Root72ItemItem21680(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root72ItemItem21681(pub i64);
impl std::ops::Deref for Root72ItemItem21681 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root72ItemItem21681 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 1 { return Err(DeError::custom("Root72ItemItem21681: integer below minimum")); }
        if x > 12 { return Err(DeError::custom("Root72ItemItem21681: integer above maximum")); }
        
        Ok(Root72ItemItem21681(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root72ItemItem21682(pub i64);
impl std::ops::Deref for Root72ItemItem21682 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root72ItemItem21682 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 1 { return Err(DeError::custom("Root72ItemItem21682: integer below minimum")); }
        if x > 31 { return Err(DeError::custom("Root72ItemItem21682: integer above maximum")); }
        
        Ok(Root72ItemItem21682(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root72ItemItem21683(pub i64);
impl std::ops::Deref for Root72ItemItem21683 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root72ItemItem21683 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 0 { return Err(DeError::custom("Root72ItemItem21683: integer below minimum")); }
        if x > 23 { return Err(DeError::custom("Root72ItemItem21683: integer above maximum")); }
        
        Ok(Root72ItemItem21683(x))
    }
}
/// tuple len=4 (required first 4 slots)
#[derive(Debug, Deserialize)]
pub struct Root72ItemItem2168(
    pub Root72ItemItem21680,
    pub Root72ItemItem21681,
    pub Root72ItemItem21682,
    pub Root72ItemItem21683,
);

/// tuple len=9 (required first 9 slots)
#[derive(Debug, Deserialize)]
pub struct Root72ItemItem216(
    pub Root72ItemItem2160,
    pub Null,
    pub Null,
    pub Option<Root72ItemItem2163>,
    pub Null,
    pub Root72ItemItem2165,
    pub Null,
    pub Null,
    pub Root72ItemItem2168,
);

/// tuple len=20 (required first 20 slots)
#[derive(Debug, Deserialize)]
pub struct Root72ItemItem21(
    pub Null,
    pub Root72ItemItem211,
    pub Root72ItemItem212,
    pub Null,
    pub Null,
    pub Vec<Vec<Root72ItemItem215ItemItem>>,
    pub Root72ItemItem216,
    pub Null,
    pub Null,
    pub Null,
    pub Null,
    pub Null,
    pub Null,
    pub Null,
    pub Null,
    pub Null,
    pub Null,
    pub Null,
    pub Null,
    pub Vec<String>,
);

#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root72ItemItem22(pub i64);
impl std::ops::Deref for Root72ItemItem22 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root72ItemItem22 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 0 { return Err(DeError::custom("Root72ItemItem22: integer below minimum")); }
        if x > 3 { return Err(DeError::custom("Root72ItemItem22: integer above maximum")); }
        
        Ok(Root72ItemItem22(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root72ItemItem260(pub i64);
impl std::ops::Deref for Root72ItemItem260 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root72ItemItem260 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 12388 { return Err(DeError::custom("Root72ItemItem260: integer below minimum")); }
        if x > 59499 { return Err(DeError::custom("Root72ItemItem260: integer above maximum")); }
        
        Ok(Root72ItemItem260(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root72ItemItem261Item0(pub i64);
impl std::ops::Deref for Root72ItemItem261Item0 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root72ItemItem261Item0 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 18 { return Err(DeError::custom("Root72ItemItem261Item0: integer below minimum")); }
        if x > 37 { return Err(DeError::custom("Root72ItemItem261Item0: integer above maximum")); }
        
        Ok(Root72ItemItem261Item0(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root72ItemItem261Item1(pub i64);
impl std::ops::Deref for Root72ItemItem261Item1 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root72ItemItem261Item1 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 640 { return Err(DeError::custom("Root72ItemItem261Item1: integer below minimum")); }
        if x > 1920 { return Err(DeError::custom("Root72ItemItem261Item1: integer above maximum")); }
        
        Ok(Root72ItemItem261Item1(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root72ItemItem261Item2(pub i64);
impl std::ops::Deref for Root72ItemItem261Item2 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root72ItemItem261Item2 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 360 { return Err(DeError::custom("Root72ItemItem261Item2: integer below minimum")); }
        if x > 1080 { return Err(DeError::custom("Root72ItemItem261Item2: integer above maximum")); }
        
        Ok(Root72ItemItem261Item2(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct Root72ItemItem261Item3(pub String);
impl std::ops::Deref for Root72ItemItem261Item3 {
    type Target = String;
    fn deref(&self) -> &Self::Target { &self.0 }
}
static RE_ROOT72ITEMITEM261ITEM3: Lazy<Regex> = Lazy::new(|| Regex::new("^https://lh3\\.googleusercontent\\.com/g.*").unwrap());
impl<'de> Deserialize<'de> for Root72ItemItem261Item3 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let s = String::deserialize(de)?;
        if !RE_ROOT72ITEMITEM261ITEM3.is_match(&s) {
            return Err(DeError::custom("Root72ItemItem261Item3: string failed pattern"));
        }
        Ok(Root72ItemItem261Item3(s))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root72ItemItem261Item4(pub i64);
impl std::ops::Deref for Root72ItemItem261Item4 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root72ItemItem261Item4 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 1 { return Err(DeError::custom("Root72ItemItem261Item4: integer below minimum")); }
        if x > 3 { return Err(DeError::custom("Root72ItemItem261Item4: integer above maximum")); }
        
        Ok(Root72ItemItem261Item4(x))
    }
}
/// tuple len=5 (required first 5 slots)
#[derive(Debug, Deserialize)]
pub struct Root72ItemItem261Item(
    pub Option<Root72ItemItem261Item0>,
    pub Root72ItemItem261Item1,
    pub Root72ItemItem261Item2,
    pub Root72ItemItem261Item3,
    pub Root72ItemItem261Item4,
);

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum Root72ItemItem262 {
    V7a63564fd79e308c,
    B0c7492059023d89,
}
impl<'de> Deserialize<'de> for Root72ItemItem262 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let s = String::deserialize(de)?;
        match s.as_str() {
            "7a63564fd79e308c" => Ok(Root72ItemItem262::V7a63564fd79e308c),
            "b0c7492059023d89" => Ok(Root72ItemItem262::B0c7492059023d89),
            _ => Err(DeError::unknown_variant(&s, &[])),
        }
    }
}
impl serde::Serialize for Root72ItemItem262 {
    fn serialize<S>(&self, ser: S) -> Result<S::Ok, S::Error> where S: serde::Serializer {
        match self {
            Root72ItemItem262::V7a63564fd79e308c => ser.serialize_str("7a63564fd79e308c"),
            Root72ItemItem262::B0c7492059023d89 => ser.serialize_str("b0c7492059023d89"),
        }
    }
}

/// tuple len=3 (required first 2 slots)
#[derive(Debug, Deserialize)]
pub struct Root72ItemItem26(
    pub Root72ItemItem260,
    pub Vec<Root72ItemItem261Item>,
    pub Option<Root72ItemItem262>,
);

/// tuple len=32 (required first 32 slots)
#[derive(Debug, Deserialize)]
pub struct Root72ItemItem(
    pub String,
    pub Root72ItemItem1,
    pub Root72ItemItem2,
    pub Option<String>,
    pub Null,
    pub Null,
    pub Root72ItemItem6,
    pub Null,
    pub Root72ItemItem8,
    pub String,
    pub String,
    pub Null,
    pub Null,
    pub Null,
    pub Null,
    pub Vec<Vec<Vec<Root72ItemItem15ItemItemItem>>>,
    pub Null,
    pub Option<Vec<String>>,
    pub Null,
    pub Null,
    pub Root72ItemItem20,
    pub Root72ItemItem21,
    pub Root72ItemItem22,
    pub Null,
    pub Null,
    pub Null,
    pub Option<Root72ItemItem26>,
    pub Null,
    pub Null,
    pub Vec<String>,
    pub Null,
    pub String,
);

#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root75ItemItem0(pub i64);
impl std::ops::Deref for Root75ItemItem0 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root75ItemItem0 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 3 { return Err(DeError::custom("Root75ItemItem0: integer below minimum")); }
        if x > 4 { return Err(DeError::custom("Root75ItemItem0: integer above maximum")); }
        
        Ok(Root75ItemItem0(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root75ItemItem2Item02ItemAlt1Item(pub i64);
impl std::ops::Deref for Root75ItemItem2Item02ItemAlt1Item {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root75ItemItem2Item02ItemAlt1Item {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 80 { return Err(DeError::custom("Root75ItemItem2Item02ItemAlt1Item: integer below minimum")); }
        if x > 80 { return Err(DeError::custom("Root75ItemItem2Item02ItemAlt1Item: integer above maximum")); }
        
        Ok(Root75ItemItem2Item02ItemAlt1Item(x))
    }
}
#[derive(Debug)]
pub enum Root75ItemItem2Item02Item {
    V0(String),
    V1(Vec<Root75ItemItem2Item02ItemAlt1Item>),
}

impl<'de> Deserialize<'de> for Root75ItemItem2Item02Item {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        // deserialize into a serde_json::Value once, then attempt each arm (strict)
        let val = serde_json::Value::deserialize(de)?;
        if let Ok(x) = <String as serde::Deserialize>::deserialize(val.clone()) { return Ok(Root75ItemItem2Item02Item::V0(x)); }
        if let Ok(x) = <Vec<Root75ItemItem2Item02ItemAlt1Item> as serde::Deserialize>::deserialize(val.clone()) { return Ok(Root75ItemItem2Item02Item::V1(x)); }
        Err(DeError::custom("no union arm matched"))
    }
}

#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root75ItemItem2Item03(pub i64);
impl std::ops::Deref for Root75ItemItem2Item03 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root75ItemItem2Item03 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 20000004 { return Err(DeError::custom("Root75ItemItem2Item03: integer below minimum")); }
        if x > 20000004 { return Err(DeError::custom("Root75ItemItem2Item03: integer above maximum")); }
        
        Ok(Root75ItemItem2Item03(x))
    }
}
/// tuple len=4 (required first 2 slots)
#[derive(Debug, Deserialize)]
pub struct Root75ItemItem2Item0(
    pub String,
    pub Null,
    pub Option<Vec<Root75ItemItem2Item02Item>>,
    pub Option<Root75ItemItem2Item03>,
);

#[repr(transparent)]
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct Root75ItemItem2Item120(pub String);
impl std::ops::Deref for Root75ItemItem2Item120 {
    type Target = String;
    fn deref(&self) -> &Self::Target { &self.0 }
}
static RE_ROOT75ITEMITEM2ITEM120: Lazy<Regex> = Lazy::new(|| Regex::new("^http.*").unwrap());
impl<'de> Deserialize<'de> for Root75ItemItem2Item120 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let s = String::deserialize(de)?;
        if !RE_ROOT75ITEMITEM2ITEM120.is_match(&s) {
            return Err(DeError::custom("Root75ItemItem2Item120: string failed pattern"));
        }
        Ok(Root75ItemItem2Item120(s))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct Root75ItemItem2Item1210(pub String);
impl std::ops::Deref for Root75ItemItem2Item1210 {
    type Target = String;
    fn deref(&self) -> &Self::Target { &self.0 }
}
static RE_ROOT75ITEMITEM2ITEM1210: Lazy<Regex> = Lazy::new(|| Regex::new("^http.*").unwrap());
impl<'de> Deserialize<'de> for Root75ItemItem2Item1210 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let s = String::deserialize(de)?;
        if !RE_ROOT75ITEMITEM2ITEM1210.is_match(&s) {
            return Err(DeError::custom("Root75ItemItem2Item1210: string failed pattern"));
        }
        Ok(Root75ItemItem2Item1210(s))
    }
}
/// tuple len=5 (required first 5 slots)
#[derive(Debug, Deserialize)]
pub struct Root75ItemItem2Item121(
    pub Root75ItemItem2Item1210,
    pub Null,
    pub Null,
    pub Null,
    pub String,
);

/// tuple len=2 (required first 2 slots)
#[derive(Debug, Deserialize)]
pub struct Root75ItemItem2Item12(
    pub Root75ItemItem2Item120,
    pub Root75ItemItem2Item121,
);

/// tuple len=3 (required first 3 slots)
#[derive(Debug, Deserialize)]
pub struct Root75ItemItem2Item1(
    pub Null,
    pub Null,
    pub Root75ItemItem2Item12,
);

#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root75ItemItem2Item2(pub i64);
impl std::ops::Deref for Root75ItemItem2Item2 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root75ItemItem2Item2 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 1 { return Err(DeError::custom("Root75ItemItem2Item2: integer below minimum")); }
        if x > 1 { return Err(DeError::custom("Root75ItemItem2Item2: integer above maximum")); }
        
        Ok(Root75ItemItem2Item2(x))
    }
}
/// tuple len=3 (required first 2 slots)
#[derive(Debug, Deserialize)]
pub struct Root75ItemItem2Item(
    pub Root75ItemItem2Item0,
    pub Root75ItemItem2Item1,
    pub Option<Root75ItemItem2Item2>,
);

#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root75ItemItem4(pub i64);
impl std::ops::Deref for Root75ItemItem4 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root75ItemItem4 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 21633 { return Err(DeError::custom("Root75ItemItem4: integer below minimum")); }
        if x > 21634 { return Err(DeError::custom("Root75ItemItem4: integer above maximum")); }
        
        Ok(Root75ItemItem4(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct Root75ItemItem50(pub String);
impl std::ops::Deref for Root75ItemItem50 {
    type Target = String;
    fn deref(&self) -> &Self::Target { &self.0 }
}
static RE_ROOT75ITEMITEM50: Lazy<Regex> = Lazy::new(|| Regex::new("^Book online.*").unwrap());
impl<'de> Deserialize<'de> for Root75ItemItem50 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let s = String::deserialize(de)?;
        if !RE_ROOT75ITEMITEM50.is_match(&s) {
            return Err(DeError::custom("Root75ItemItem50: string failed pattern"));
        }
        Ok(Root75ItemItem50(s))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct Root75ItemItem5120(pub String);
impl std::ops::Deref for Root75ItemItem5120 {
    type Target = String;
    fn deref(&self) -> &Self::Target { &self.0 }
}
static RE_ROOT75ITEMITEM5120: Lazy<Regex> = Lazy::new(|| Regex::new("^https://.*").unwrap());
impl<'de> Deserialize<'de> for Root75ItemItem5120 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let s = String::deserialize(de)?;
        if !RE_ROOT75ITEMITEM5120.is_match(&s) {
            return Err(DeError::custom("Root75ItemItem5120: string failed pattern"));
        }
        Ok(Root75ItemItem5120(s))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct Root75ItemItem51210(pub String);
impl std::ops::Deref for Root75ItemItem51210 {
    type Target = String;
    fn deref(&self) -> &Self::Target { &self.0 }
}
static RE_ROOT75ITEMITEM51210: Lazy<Regex> = Lazy::new(|| Regex::new("^https://.*").unwrap());
impl<'de> Deserialize<'de> for Root75ItemItem51210 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let s = String::deserialize(de)?;
        if !RE_ROOT75ITEMITEM51210.is_match(&s) {
            return Err(DeError::custom("Root75ItemItem51210: string failed pattern"));
        }
        Ok(Root75ItemItem51210(s))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct Root75ItemItem51214(pub String);
impl std::ops::Deref for Root75ItemItem51214 {
    type Target = String;
    fn deref(&self) -> &Self::Target { &self.0 }
}
static RE_ROOT75ITEMITEM51214: Lazy<Regex> = Lazy::new(|| Regex::new("^,AOvVaw.*").unwrap());
impl<'de> Deserialize<'de> for Root75ItemItem51214 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let s = String::deserialize(de)?;
        if !RE_ROOT75ITEMITEM51214.is_match(&s) {
            return Err(DeError::custom("Root75ItemItem51214: string failed pattern"));
        }
        Ok(Root75ItemItem51214(s))
    }
}
/// tuple len=5 (required first 5 slots)
#[derive(Debug, Deserialize)]
pub struct Root75ItemItem5121(
    pub Root75ItemItem51210,
    pub Null,
    pub Null,
    pub Null,
    pub Root75ItemItem51214,
);

/// tuple len=2 (required first 2 slots)
#[derive(Debug, Deserialize)]
pub struct Root75ItemItem512(
    pub Root75ItemItem5120,
    pub Root75ItemItem5121,
);

/// tuple len=3 (required first 3 slots)
#[derive(Debug, Deserialize)]
pub struct Root75ItemItem51(
    pub Null,
    pub Null,
    pub Root75ItemItem512,
);

#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root75ItemItem52(pub i64);
impl std::ops::Deref for Root75ItemItem52 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root75ItemItem52 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 0 { return Err(DeError::custom("Root75ItemItem52: integer below minimum")); }
        if x > 0 { return Err(DeError::custom("Root75ItemItem52: integer above maximum")); }
        
        Ok(Root75ItemItem52(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root75ItemItem53(pub i64);
impl std::ops::Deref for Root75ItemItem53 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root75ItemItem53 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 64 { return Err(DeError::custom("Root75ItemItem53: integer below minimum")); }
        if x > 64 { return Err(DeError::custom("Root75ItemItem53: integer above maximum")); }
        
        Ok(Root75ItemItem53(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root75ItemItem54(pub i64);
impl std::ops::Deref for Root75ItemItem54 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root75ItemItem54 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 155425 { return Err(DeError::custom("Root75ItemItem54: integer below minimum")); }
        if x > 155425 { return Err(DeError::custom("Root75ItemItem54: integer above maximum")); }
        
        Ok(Root75ItemItem54(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct Root75ItemItem57(pub String);
impl std::ops::Deref for Root75ItemItem57 {
    type Target = String;
    fn deref(&self) -> &Self::Target { &self.0 }
}
static RE_ROOT75ITEMITEM57: Lazy<Regex> = Lazy::new(|| Regex::new("^Schedule appointment with .*").unwrap());
impl<'de> Deserialize<'de> for Root75ItemItem57 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let s = String::deserialize(de)?;
        if !RE_ROOT75ITEMITEM57.is_match(&s) {
            return Err(DeError::custom("Root75ItemItem57: string failed pattern"));
        }
        Ok(Root75ItemItem57(s))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct Root75ItemItem59(pub String);
impl std::ops::Deref for Root75ItemItem59 {
    type Target = String;
    fn deref(&self) -> &Self::Target { &self.0 }
}
static RE_ROOT75ITEMITEM59: Lazy<Regex> = Lazy::new(|| Regex::new("^0ahUKEwiI98jJ6cKPAxVJD0QIHUurIJQQ0KoKC.*").unwrap());
impl<'de> Deserialize<'de> for Root75ItemItem59 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let s = String::deserialize(de)?;
        if !RE_ROOT75ITEMITEM59.is_match(&s) {
            return Err(DeError::custom("Root75ItemItem59: string failed pattern"));
        }
        Ok(Root75ItemItem59(s))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct Root75ItemItem510(pub String);
impl std::ops::Deref for Root75ItemItem510 {
    type Target = String;
    fn deref(&self) -> &Self::Target { &self.0 }
}
static RE_ROOT75ITEMITEM510: Lazy<Regex> = Lazy::new(|| Regex::new("^Book.*").unwrap());
impl<'de> Deserialize<'de> for Root75ItemItem510 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let s = String::deserialize(de)?;
        if !RE_ROOT75ITEMITEM510.is_match(&s) {
            return Err(DeError::custom("Root75ItemItem510: string failed pattern"));
        }
        Ok(Root75ItemItem510(s))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root75ItemItem5122(pub i64);
impl std::ops::Deref for Root75ItemItem5122 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root75ItemItem5122 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 0 { return Err(DeError::custom("Root75ItemItem5122: integer below minimum")); }
        if x > 0 { return Err(DeError::custom("Root75ItemItem5122: integer above maximum")); }
        
        Ok(Root75ItemItem5122(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root75ItemItem521(pub i64);
impl std::ops::Deref for Root75ItemItem521 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root75ItemItem521 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 0 { return Err(DeError::custom("Root75ItemItem521: integer below minimum")); }
        if x > 0 { return Err(DeError::custom("Root75ItemItem521: integer above maximum")); }
        
        Ok(Root75ItemItem521(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root75ItemItem5230(pub i64);
impl std::ops::Deref for Root75ItemItem5230 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root75ItemItem5230 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 1 { return Err(DeError::custom("Root75ItemItem5230: integer below minimum")); }
        if x > 1 { return Err(DeError::custom("Root75ItemItem5230: integer above maximum")); }
        
        Ok(Root75ItemItem5230(x))
    }
}
/// tuple len=1 (required first 1 slots)
#[derive(Debug, Deserialize)]
pub struct Root75ItemItem523(
    pub Root75ItemItem5230,
);

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum Root75ItemItem5240 {
    HousecallPro,
    LeadConnector,
}
impl<'de> Deserialize<'de> for Root75ItemItem5240 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let s = String::deserialize(de)?;
        match s.as_str() {
            "Housecall Pro" => Ok(Root75ItemItem5240::HousecallPro),
            "LeadConnector" => Ok(Root75ItemItem5240::LeadConnector),
            _ => Err(DeError::unknown_variant(&s, &[])),
        }
    }
}
impl serde::Serialize for Root75ItemItem5240 {
    fn serialize<S>(&self, ser: S) -> Result<S::Ok, S::Error> where S: serde::Serializer {
        match self {
            Root75ItemItem5240::HousecallPro => ser.serialize_str("Housecall Pro"),
            Root75ItemItem5240::LeadConnector => ser.serialize_str("LeadConnector"),
        }
    }
}

#[repr(transparent)]
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct Root75ItemItem52420(pub String);
impl std::ops::Deref for Root75ItemItem52420 {
    type Target = String;
    fn deref(&self) -> &Self::Target { &self.0 }
}
static RE_ROOT75ITEMITEM52420: Lazy<Regex> = Lazy::new(|| Regex::new("^https://lh3\\.googleusercontent\\.com/.*").unwrap());
impl<'de> Deserialize<'de> for Root75ItemItem52420 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let s = String::deserialize(de)?;
        if !RE_ROOT75ITEMITEM52420.is_match(&s) {
            return Err(DeError::custom("Root75ItemItem52420: string failed pattern"));
        }
        Ok(Root75ItemItem52420(s))
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum Root75ItemItem52421 {
    HousecallPro,
    LeadConnector,
}
impl<'de> Deserialize<'de> for Root75ItemItem52421 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let s = String::deserialize(de)?;
        match s.as_str() {
            "Housecall Pro" => Ok(Root75ItemItem52421::HousecallPro),
            "LeadConnector" => Ok(Root75ItemItem52421::LeadConnector),
            _ => Err(DeError::unknown_variant(&s, &[])),
        }
    }
}
impl serde::Serialize for Root75ItemItem52421 {
    fn serialize<S>(&self, ser: S) -> Result<S::Ok, S::Error> where S: serde::Serializer {
        match self {
            Root75ItemItem52421::HousecallPro => ser.serialize_str("Housecall Pro"),
            Root75ItemItem52421::LeadConnector => ser.serialize_str("LeadConnector"),
        }
    }
}

#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root75ItemItem524220(pub i64);
impl std::ops::Deref for Root75ItemItem524220 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root75ItemItem524220 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 80 { return Err(DeError::custom("Root75ItemItem524220: integer below minimum")); }
        if x > 80 { return Err(DeError::custom("Root75ItemItem524220: integer above maximum")); }
        
        Ok(Root75ItemItem524220(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root75ItemItem524221(pub i64);
impl std::ops::Deref for Root75ItemItem524221 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root75ItemItem524221 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 80 { return Err(DeError::custom("Root75ItemItem524221: integer below minimum")); }
        if x > 80 { return Err(DeError::custom("Root75ItemItem524221: integer above maximum")); }
        
        Ok(Root75ItemItem524221(x))
    }
}
/// tuple len=2 (required first 2 slots)
#[derive(Debug, Deserialize)]
pub struct Root75ItemItem52422(
    pub Root75ItemItem524220,
    pub Root75ItemItem524221,
);

/// tuple len=3 (required first 3 slots)
#[derive(Debug, Deserialize)]
pub struct Root75ItemItem5242(
    pub Root75ItemItem52420,
    pub Root75ItemItem52421,
    pub Root75ItemItem52422,
);

#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root75ItemItem5243(pub i64);
impl std::ops::Deref for Root75ItemItem5243 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root75ItemItem5243 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 20002114 { return Err(DeError::custom("Root75ItemItem5243: integer below minimum")); }
        if x > 20002200 { return Err(DeError::custom("Root75ItemItem5243: integer above maximum")); }
        
        Ok(Root75ItemItem5243(x))
    }
}
/// tuple len=4 (required first 4 slots)
#[derive(Debug, Deserialize)]
pub struct Root75ItemItem524(
    pub Root75ItemItem5240,
    pub Null,
    pub Root75ItemItem5242,
    pub Root75ItemItem5243,
);

/// tuple len=25 (required first 25 slots)
#[derive(Debug, Deserialize)]
pub struct Root75ItemItem5(
    pub Root75ItemItem50,
    pub Root75ItemItem51,
    pub Root75ItemItem52,
    pub Root75ItemItem53,
    pub Root75ItemItem54,
    pub Null,
    pub Null,
    pub Root75ItemItem57,
    pub Null,
    pub Root75ItemItem59,
    pub Root75ItemItem510,
    pub Null,
    pub Root75ItemItem5122,
    pub Null,
    pub Null,
    pub Null,
    pub Null,
    pub Null,
    pub Null,
    pub Null,
    pub Null,
    pub Root75ItemItem521,
    pub Null,
    pub Root75ItemItem523,
    pub Root75ItemItem524,
);

/// tuple len=6 (required first 5 slots)
#[derive(Debug, Deserialize)]
pub struct Root75ItemItem(
    pub Root75ItemItem0,
    pub Null,
    pub Option<Vec<Root75ItemItem2Item>>,
    pub Null,
    pub Root75ItemItem4,
    pub Option<Root75ItemItem5>,
);

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum Root76Item1 {
    FastFood,
    LiveMusic,
    Pizza,
    Seafood,
}
impl<'de> Deserialize<'de> for Root76Item1 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let s = String::deserialize(de)?;
        match s.as_str() {
            "Fast Food" => Ok(Root76Item1::FastFood),
            "Live Music" => Ok(Root76Item1::LiveMusic),
            "Pizza" => Ok(Root76Item1::Pizza),
            "Seafood" => Ok(Root76Item1::Seafood),
            _ => Err(DeError::unknown_variant(&s, &[])),
        }
    }
}
impl serde::Serialize for Root76Item1 {
    fn serialize<S>(&self, ser: S) -> Result<S::Ok, S::Error> where S: serde::Serializer {
        match self {
            Root76Item1::FastFood => ser.serialize_str("Fast Food"),
            Root76Item1::LiveMusic => ser.serialize_str("Live Music"),
            Root76Item1::Pizza => ser.serialize_str("Pizza"),
            Root76Item1::Seafood => ser.serialize_str("Seafood"),
        }
    }
}

#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root76Item2(pub i64);
impl std::ops::Deref for Root76Item2 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root76Item2 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 0 { return Err(DeError::custom("Root76Item2: integer below minimum")); }
        if x > 11 { return Err(DeError::custom("Root76Item2: integer above maximum")); }
        
        Ok(Root76Item2(x))
    }
}
/// tuple len=3 (required first 3 slots)
#[derive(Debug, Deserialize)]
pub struct Root76Item(
    pub String,
    pub Option<Root76Item1>,
    pub Root76Item2,
);

#[repr(transparent)]
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct Root860Item0(pub String);
impl std::ops::Deref for Root860Item0 {
    type Target = String;
    fn deref(&self) -> &Self::Target { &self.0 }
}
static RE_ROOT860ITEM0: Lazy<Regex> = Lazy::new(|| Regex::new("^\\$3\\..*").unwrap());
impl<'de> Deserialize<'de> for Root860Item0 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let s = String::deserialize(de)?;
        if !RE_ROOT860ITEM0.is_match(&s) {
            return Err(DeError::custom("Root860Item0: string failed pattern"));
        }
        Ok(Root860Item0(s))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root860Item1(pub i64);
impl std::ops::Deref for Root860Item1 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root860Item1 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 1 { return Err(DeError::custom("Root860Item1: integer below minimum")); }
        if x > 5 { return Err(DeError::custom("Root860Item1: integer above maximum")); }
        
        Ok(Root860Item1(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root860Item2(pub i64);
impl std::ops::Deref for Root860Item2 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root860Item2 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 1757054003 { return Err(DeError::custom("Root860Item2: integer below minimum")); }
        if x > 1757058051 { return Err(DeError::custom("Root860Item2: integer above maximum")); }
        
        Ok(Root860Item2(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct Root860Item3(pub String);
impl std::ops::Deref for Root860Item3 {
    type Target = String;
    fn deref(&self) -> &Self::Target { &self.0 }
}
static RE_ROOT860ITEM3: Lazy<Regex> = Lazy::new(|| Regex::new("^gallon.*").unwrap());
impl<'de> Deserialize<'de> for Root860Item3 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let s = String::deserialize(de)?;
        if !RE_ROOT860ITEM3.is_match(&s) {
            return Err(DeError::custom("Root860Item3: string failed pattern"));
        }
        Ok(Root860Item3(s))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root860Item4(pub i64);
impl std::ops::Deref for Root860Item4 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root860Item4 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 0 { return Err(DeError::custom("Root860Item4: integer below minimum")); }
        if x > 0 { return Err(DeError::custom("Root860Item4: integer above maximum")); }
        
        Ok(Root860Item4(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct Root860Item5(pub String);
impl std::ops::Deref for Root860Item5 {
    type Target = String;
    fn deref(&self) -> &Self::Target { &self.0 }
}
static RE_ROOT860ITEM5: Lazy<Regex> = Lazy::new(|| Regex::new("^USD.*").unwrap());
impl<'de> Deserialize<'de> for Root860Item5 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let s = String::deserialize(de)?;
        if !RE_ROOT860ITEM5.is_match(&s) {
            return Err(DeError::custom("Root860Item5: string failed pattern"));
        }
        Ok(Root860Item5(s))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub struct Root860Item6(pub f64);
impl std::ops::Deref for Root860Item6 {
    type Target = f64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root860Item6 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = f64::deserialize(de)?;
        if !x.is_finite() { return Err(DeError::custom("Root860Item6: non-finite number")); }
        if x < 3.18 { return Err(DeError::custom("Root860Item6: number below minimum")); }
        if x > 3.76 { return Err(DeError::custom("Root860Item6: number above maximum")); }
        
        Ok(Root860Item6(x))
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum Root860Item7 {
    Diesel,
    Midgrade,
    Premium,
    Regular,
}
impl<'de> Deserialize<'de> for Root860Item7 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let s = String::deserialize(de)?;
        match s.as_str() {
            "Diesel" => Ok(Root860Item7::Diesel),
            "Midgrade" => Ok(Root860Item7::Midgrade),
            "Premium" => Ok(Root860Item7::Premium),
            "Regular" => Ok(Root860Item7::Regular),
            _ => Err(DeError::unknown_variant(&s, &[])),
        }
    }
}
impl serde::Serialize for Root860Item7 {
    fn serialize<S>(&self, ser: S) -> Result<S::Ok, S::Error> where S: serde::Serializer {
        match self {
            Root860Item7::Diesel => ser.serialize_str("Diesel"),
            Root860Item7::Midgrade => ser.serialize_str("Midgrade"),
            Root860Item7::Premium => ser.serialize_str("Premium"),
            Root860Item7::Regular => ser.serialize_str("Regular"),
        }
    }
}

/// tuple len=8 (required first 8 slots)
#[derive(Debug, Deserialize)]
pub struct Root860Item(
    pub Root860Item0,
    pub Root860Item1,
    pub Root860Item2,
    pub Root860Item3,
    pub Root860Item4,
    pub Root860Item5,
    pub Root860Item6,
    pub Root860Item7,
);

#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root861(pub i64);
impl std::ops::Deref for Root861 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root861 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 3 { return Err(DeError::custom("Root861: integer below minimum")); }
        if x > 3 { return Err(DeError::custom("Root861: integer above maximum")); }
        
        Ok(Root861(x))
    }
}
/// tuple len=2 (required first 2 slots)
#[derive(Debug, Deserialize)]
pub struct Root86(
    pub Vec<Root860Item>,
    pub Root861,
);

#[repr(transparent)]
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct Root881(pub String);
impl std::ops::Deref for Root881 {
    type Target = String;
    fn deref(&self) -> &Self::Target { &self.0 }
}
static RE_ROOT881: Lazy<Regex> = Lazy::new(|| Regex::new("^SearchResult\\.TYPE_.*").unwrap());
impl<'de> Deserialize<'de> for Root881 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let s = String::deserialize(de)?;
        if !RE_ROOT881.is_match(&s) {
            return Err(DeError::custom("Root881: string failed pattern"));
        }
        Ok(Root881(s))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct Root8820(pub String);
impl std::ops::Deref for Root8820 {
    type Target = String;
    fn deref(&self) -> &Self::Target { &self.0 }
}
static RE_ROOT8820: Lazy<Regex> = Lazy::new(|| Regex::new("^SearchResult\\.TYPE_.*").unwrap());
impl<'de> Deserialize<'de> for Root8820 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let s = String::deserialize(de)?;
        if !RE_ROOT8820.is_match(&s) {
            return Err(DeError::custom("Root8820: string failed pattern"));
        }
        Ok(Root8820(s))
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum Root8821 {
    US,
}
impl<'de> Deserialize<'de> for Root8821 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let s = String::deserialize(de)?;
        match s.as_str() {
            "US" => Ok(Root8821::US),
            _ => Err(DeError::unknown_variant(&s, &[])),
        }
    }
}
impl serde::Serialize for Root8821 {
    fn serialize<S>(&self, ser: S) -> Result<S::Ok, S::Error> where S: serde::Serializer {
        match self {
            Root8821::US => ser.serialize_str("US"),
        }
    }
}

#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root8822(pub i64);
impl std::ops::Deref for Root8822 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root8822 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 32 { return Err(DeError::custom("Root8822: integer below minimum")); }
        if x > 74 { return Err(DeError::custom("Root8822: integer above maximum")); }
        
        Ok(Root8822(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root8823(pub i64);
impl std::ops::Deref for Root8823 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root8823 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 84 { return Err(DeError::custom("Root8823: integer below minimum")); }
        if x > 84 { return Err(DeError::custom("Root8823: integer above maximum")); }
        
        Ok(Root8823(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root8824(pub i64);
impl std::ops::Deref for Root8824 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root8824 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 85 { return Err(DeError::custom("Root8824: integer below minimum")); }
        if x > 85 { return Err(DeError::custom("Root8824: integer above maximum")); }
        
        Ok(Root8824(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root8825(pub i64);
impl std::ops::Deref for Root8825 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root8825 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 151 { return Err(DeError::custom("Root8825: integer below minimum")); }
        if x > 151 { return Err(DeError::custom("Root8825: integer above maximum")); }
        
        Ok(Root8825(x))
    }
}
/// tuple len=6 (required first 6 slots)
#[derive(Debug, Deserialize)]
pub struct Root882(
    pub Root8820,
    pub Root8821,
    pub Root8822,
    pub Root8823,
    pub Root8824,
    pub Root8825,
);

#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root8842(pub i64);
impl std::ops::Deref for Root8842 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root8842 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 188 { return Err(DeError::custom("Root8842: integer below minimum")); }
        if x > 669 { return Err(DeError::custom("Root8842: integer above maximum")); }
        
        Ok(Root8842(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root8843(pub i64);
impl std::ops::Deref for Root8843 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root8843 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 187 { return Err(DeError::custom("Root8843: integer below minimum")); }
        if x > 668 { return Err(DeError::custom("Root8843: integer above maximum")); }
        
        Ok(Root8843(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root8844(pub i64);
impl std::ops::Deref for Root8844 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root8844 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 1166 { return Err(DeError::custom("Root8844: integer below minimum")); }
        if x > 1238 { return Err(DeError::custom("Root8844: integer above maximum")); }
        
        Ok(Root8844(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root8845(pub i64);
impl std::ops::Deref for Root8845 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root8845 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 186 { return Err(DeError::custom("Root8845: integer below minimum")); }
        if x > 667 { return Err(DeError::custom("Root8845: integer above maximum")); }
        
        Ok(Root8845(x))
    }
}
/// tuple len=6 (required first 6 slots)
#[derive(Debug, Deserialize)]
pub struct Root884(
    pub Null,
    pub Null,
    pub Root8842,
    pub Root8843,
    pub Root8844,
    pub Root8845,
);

/// tuple len=5 (required first 5 slots)
#[derive(Debug, Deserialize)]
pub struct Root88(
    pub Option<String>,
    pub Option<Root881>,
    pub Option<Root882>,
    pub String,
    pub Root884,
);

#[repr(transparent)]
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct Root99ItemItem1Item200(pub String);
impl std::ops::Deref for Root99ItemItem1Item200 {
    type Target = String;
    fn deref(&self) -> &Self::Target { &self.0 }
}
static RE_ROOT99ITEMITEM1ITEM200: Lazy<Regex> = Lazy::new(|| Regex::new("^0ahUKEwj1x5fr9MKPAxWiEEQIHUTDLPsQjqADCO.*").unwrap());
impl<'de> Deserialize<'de> for Root99ItemItem1Item200 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let s = String::deserialize(de)?;
        if !RE_ROOT99ITEMITEM1ITEM200.is_match(&s) {
            return Err(DeError::custom("Root99ItemItem1Item200: string failed pattern"));
        }
        Ok(Root99ItemItem1Item200(s))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct Root99ItemItem1Item202(pub String);
impl std::ops::Deref for Root99ItemItem1Item202 {
    type Target = String;
    fn deref(&self) -> &Self::Target { &self.0 }
}
static RE_ROOT99ITEMITEM1ITEM202: Lazy<Regex> = Lazy::new(|| Regex::new("^0x87.*").unwrap());
impl<'de> Deserialize<'de> for Root99ItemItem1Item202 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let s = String::deserialize(de)?;
        if !RE_ROOT99ITEMITEM1ITEM202.is_match(&s) {
            return Err(DeError::custom("Root99ItemItem1Item202: string failed pattern"));
        }
        Ok(Root99ItemItem1Item202(s))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub struct Root99ItemItem1Item2032(pub f64);
impl std::ops::Deref for Root99ItemItem1Item2032 {
    type Target = f64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root99ItemItem1Item2032 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = f64::deserialize(de)?;
        if !x.is_finite() { return Err(DeError::custom("Root99ItemItem1Item2032: non-finite number")); }
        if x < 38.754999999999995 { return Err(DeError::custom("Root99ItemItem1Item2032: number below minimum")); }
        if x > 39.212710000000001 { return Err(DeError::custom("Root99ItemItem1Item2032: number above maximum")); }
        
        Ok(Root99ItemItem1Item2032(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub struct Root99ItemItem1Item2033(pub f64);
impl std::ops::Deref for Root99ItemItem1Item2033 {
    type Target = f64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root99ItemItem1Item2033 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = f64::deserialize(de)?;
        if !x.is_finite() { return Err(DeError::custom("Root99ItemItem1Item2033: non-finite number")); }
        if x < -111.196567099999996 { return Err(DeError::custom("Root99ItemItem1Item2033: number below minimum")); }
        if x > -109.754720000000006 { return Err(DeError::custom("Root99ItemItem1Item2033: number above maximum")); }
        
        Ok(Root99ItemItem1Item2033(x))
    }
}
/// tuple len=4 (required first 4 slots)
#[derive(Debug, Deserialize)]
pub struct Root99ItemItem1Item203(
    pub Null,
    pub Null,
    pub Root99ItemItem1Item2032,
    pub Root99ItemItem1Item2033,
);

#[repr(transparent)]
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct Root99ItemItem1Item206Item21(pub String);
impl std::ops::Deref for Root99ItemItem1Item206Item21 {
    type Target = String;
    fn deref(&self) -> &Self::Target { &self.0 }
}
static RE_ROOT99ITEMITEM1ITEM206ITEM21: Lazy<Regex> = Lazy::new(|| Regex::new("^http.*").unwrap());
impl<'de> Deserialize<'de> for Root99ItemItem1Item206Item21 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let s = String::deserialize(de)?;
        if !RE_ROOT99ITEMITEM1ITEM206ITEM21.is_match(&s) {
            return Err(DeError::custom("Root99ItemItem1Item206Item21: string failed pattern"));
        }
        Ok(Root99ItemItem1Item206Item21(s))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root99ItemItem1Item206Item22Item(pub i64);
impl std::ops::Deref for Root99ItemItem1Item206Item22Item {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root99ItemItem1Item206Item22Item {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 120 { return Err(DeError::custom("Root99ItemItem1Item206Item22Item: integer below minimum")); }
        if x > 282 { return Err(DeError::custom("Root99ItemItem1Item206Item22Item: integer above maximum")); }
        
        Ok(Root99ItemItem1Item206Item22Item(x))
    }
}
/// tuple len=3 (required first 3 slots)
#[derive(Debug, Deserialize)]
pub struct Root99ItemItem1Item206Item2(
    pub Null,
    pub Root99ItemItem1Item206Item21,
    pub Vec<Root99ItemItem1Item206Item22Item>,
);

/// tuple len=3 (required first 3 slots)
#[derive(Debug, Deserialize)]
pub struct Root99ItemItem1Item206Item(
    pub Null,
    pub Null,
    pub Root99ItemItem1Item206Item2,
);

#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub struct Root99ItemItem1Item207(pub f64);
impl std::ops::Deref for Root99ItemItem1Item207 {
    type Target = f64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root99ItemItem1Item207 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = f64::deserialize(de)?;
        if !x.is_finite() { return Err(DeError::custom("Root99ItemItem1Item207: non-finite number")); }
        if x < 4.5 { return Err(DeError::custom("Root99ItemItem1Item207: number below minimum")); }
        if x > 4.7 { return Err(DeError::custom("Root99ItemItem1Item207: number above maximum")); }
        
        Ok(Root99ItemItem1Item207(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root99ItemItem1Item208(pub i64);
impl std::ops::Deref for Root99ItemItem1Item208 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root99ItemItem1Item208 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 15 { return Err(DeError::custom("Root99ItemItem1Item208: integer below minimum")); }
        if x > 162 { return Err(DeError::custom("Root99ItemItem1Item208: integer above maximum")); }
        
        Ok(Root99ItemItem1Item208(x))
    }
}
/// tuple len=9 (required first 6 slots)
#[derive(Debug, Deserialize)]
pub struct Root99ItemItem1Item20(
    pub Root99ItemItem1Item200,
    pub Null,
    pub Root99ItemItem1Item202,
    pub Root99ItemItem1Item203,
    pub String,
    pub Null,
    pub Option<Vec<Root99ItemItem1Item206Item>>,
    pub Option<Root99ItemItem1Item207>,
    pub Option<Root99ItemItem1Item208>,
);

#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root99ItemItem1Item22ItemItemAlt0(pub i64);
impl std::ops::Deref for Root99ItemItem1Item22ItemItemAlt0 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root99ItemItem1Item22ItemItemAlt0 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 0 { return Err(DeError::custom("Root99ItemItem1Item22ItemItemAlt0: integer below minimum")); }
        if x > 0 { return Err(DeError::custom("Root99ItemItem1Item22ItemItemAlt0: integer above maximum")); }
        
        Ok(Root99ItemItem1Item22ItemItemAlt0(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct Root99ItemItem1Item22ItemItemAlt1(pub String);
impl std::ops::Deref for Root99ItemItem1Item22ItemItemAlt1 {
    type Target = String;
    fn deref(&self) -> &Self::Target { &self.0 }
}
static RE_ROOT99ITEMITEM1ITEM22ITEMITEMALT1: Lazy<Regex> = Lazy::new(|| Regex::new("^1 hr 39.*").unwrap());
impl<'de> Deserialize<'de> for Root99ItemItem1Item22ItemItemAlt1 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let s = String::deserialize(de)?;
        if !RE_ROOT99ITEMITEM1ITEM22ITEMITEMALT1.is_match(&s) {
            return Err(DeError::custom("Root99ItemItem1Item22ItemItemAlt1: string failed pattern"));
        }
        Ok(Root99ItemItem1Item22ItemItemAlt1(s))
    }
}
#[derive(Debug)]
pub enum Root99ItemItem1Item22ItemItem {
    V0(Root99ItemItem1Item22ItemItemAlt0),
    V1(Root99ItemItem1Item22ItemItemAlt1),
}

impl<'de> Deserialize<'de> for Root99ItemItem1Item22ItemItem {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        // deserialize into a serde_json::Value once, then attempt each arm (strict)
        let val = serde_json::Value::deserialize(de)?;
        if let Ok(x) = <Root99ItemItem1Item22ItemItemAlt0 as serde::Deserialize>::deserialize(val.clone()) { return Ok(Root99ItemItem1Item22ItemItem::V0(x)); }
        if let Ok(x) = <Root99ItemItem1Item22ItemItemAlt1 as serde::Deserialize>::deserialize(val.clone()) { return Ok(Root99ItemItem1Item22ItemItem::V1(x)); }
        Err(DeError::custom("no union arm matched"))
    }
}

#[repr(transparent)]
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct Root99ItemItem1Item23(pub String);
impl std::ops::Deref for Root99ItemItem1Item23 {
    type Target = String;
    fn deref(&self) -> &Self::Target { &self.0 }
}
static RE_ROOT99ITEMITEM1ITEM23: Lazy<Regex> = Lazy::new(|| Regex::new("^Canyon-view nature site beside a reservoir with fishing plus campsites, golf & mountain biking\\..*").unwrap());
impl<'de> Deserialize<'de> for Root99ItemItem1Item23 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let s = String::deserialize(de)?;
        if !RE_ROOT99ITEMITEM1ITEM23.is_match(&s) {
            return Err(DeError::custom("Root99ItemItem1Item23: string failed pattern"));
        }
        Ok(Root99ItemItem1Item23(s))
    }
}
/// tuple len=4 (required first 2 slots)
#[derive(Debug, Deserialize)]
pub struct Root99ItemItem1Item2(
    pub Root99ItemItem1Item20,
    pub Null,
    pub Option<Vec<Vec<Option<Root99ItemItem1Item22ItemItem>>>>,
    pub Option<Root99ItemItem1Item23>,
);

/// tuple len=3 (required first 3 slots)
#[derive(Debug, Deserialize)]
pub struct Root99ItemItem1Item(
    pub Null,
    pub Null,
    pub Root99ItemItem1Item2,
);

#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root99ItemItem3(pub i64);
impl std::ops::Deref for Root99ItemItem3 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root99ItemItem3 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 1 { return Err(DeError::custom("Root99ItemItem3: integer below minimum")); }
        if x > 3 { return Err(DeError::custom("Root99ItemItem3: integer above maximum")); }
        
        Ok(Root99ItemItem3(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub struct Root99ItemItem400(pub f64);
impl std::ops::Deref for Root99ItemItem400 {
    type Target = f64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root99ItemItem400 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = f64::deserialize(de)?;
        if !x.is_finite() { return Err(DeError::custom("Root99ItemItem400: non-finite number")); }
        if x < 99008.50644334127719 { return Err(DeError::custom("Root99ItemItem400: number below minimum")); }
        if x > 397318.780622586025856 { return Err(DeError::custom("Root99ItemItem400: number above maximum")); }
        
        Ok(Root99ItemItem400(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub struct Root99ItemItem401(pub f64);
impl std::ops::Deref for Root99ItemItem401 {
    type Target = f64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root99ItemItem401 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = f64::deserialize(de)?;
        if !x.is_finite() { return Err(DeError::custom("Root99ItemItem401: non-finite number")); }
        if x < -111.106986849999998 { return Err(DeError::custom("Root99ItemItem401: number below minimum")); }
        if x > -110.443300550000004 { return Err(DeError::custom("Root99ItemItem401: number above maximum")); }
        
        Ok(Root99ItemItem401(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub struct Root99ItemItem402(pub f64);
impl std::ops::Deref for Root99ItemItem402 {
    type Target = f64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root99ItemItem402 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = f64::deserialize(de)?;
        if !x.is_finite() { return Err(DeError::custom("Root99ItemItem402: non-finite number")); }
        if x < 38.922764599999994 { return Err(DeError::custom("Root99ItemItem402: number below minimum")); }
        if x > 39.151619599999997 { return Err(DeError::custom("Root99ItemItem402: number above maximum")); }
        
        Ok(Root99ItemItem402(x))
    }
}
/// tuple len=3 (required first 3 slots)
#[derive(Debug, Deserialize)]
pub struct Root99ItemItem40(
    pub Root99ItemItem400,
    pub Root99ItemItem401,
    pub Root99ItemItem402,
);

#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root99ItemItem410(pub i64);
impl std::ops::Deref for Root99ItemItem410 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root99ItemItem410 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 0 { return Err(DeError::custom("Root99ItemItem410: integer below minimum")); }
        if x > 0 { return Err(DeError::custom("Root99ItemItem410: integer above maximum")); }
        
        Ok(Root99ItemItem410(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root99ItemItem411(pub i64);
impl std::ops::Deref for Root99ItemItem411 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root99ItemItem411 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 0 { return Err(DeError::custom("Root99ItemItem411: integer below minimum")); }
        if x > 0 { return Err(DeError::custom("Root99ItemItem411: integer above maximum")); }
        
        Ok(Root99ItemItem411(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root99ItemItem412(pub i64);
impl std::ops::Deref for Root99ItemItem412 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root99ItemItem412 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 0 { return Err(DeError::custom("Root99ItemItem412: integer below minimum")); }
        if x > 0 { return Err(DeError::custom("Root99ItemItem412: integer above maximum")); }
        
        Ok(Root99ItemItem412(x))
    }
}
/// tuple len=3 (required first 3 slots)
#[derive(Debug, Deserialize)]
pub struct Root99ItemItem41(
    pub Root99ItemItem410,
    pub Root99ItemItem411,
    pub Root99ItemItem412,
);

#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root99ItemItem420(pub i64);
impl std::ops::Deref for Root99ItemItem420 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root99ItemItem420 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 1024 { return Err(DeError::custom("Root99ItemItem420: integer below minimum")); }
        if x > 1024 { return Err(DeError::custom("Root99ItemItem420: integer above maximum")); }
        
        Ok(Root99ItemItem420(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root99ItemItem421(pub i64);
impl std::ops::Deref for Root99ItemItem421 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root99ItemItem421 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 768 { return Err(DeError::custom("Root99ItemItem421: integer below minimum")); }
        if x > 768 { return Err(DeError::custom("Root99ItemItem421: integer above maximum")); }
        
        Ok(Root99ItemItem421(x))
    }
}
/// tuple len=2 (required first 2 slots)
#[derive(Debug, Deserialize)]
pub struct Root99ItemItem42(
    pub Root99ItemItem420,
    pub Root99ItemItem421,
);

#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub struct Root99ItemItem43(pub f64);
impl std::ops::Deref for Root99ItemItem43 {
    type Target = f64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root99ItemItem43 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = f64::deserialize(de)?;
        if !x.is_finite() { return Err(DeError::custom("Root99ItemItem43: non-finite number")); }
        if x < 13.1 { return Err(DeError::custom("Root99ItemItem43: number below minimum")); }
        if x > 13.1 { return Err(DeError::custom("Root99ItemItem43: number above maximum")); }
        
        Ok(Root99ItemItem43(x))
    }
}
/// tuple len=4 (required first 4 slots)
#[derive(Debug, Deserialize)]
pub struct Root99ItemItem4(
    pub Root99ItemItem40,
    pub Root99ItemItem41,
    pub Root99ItemItem42,
    pub Root99ItemItem43,
);

/// tuple len=5 (required first 5 slots)
#[derive(Debug, Deserialize)]
pub struct Root99ItemItem(
    pub Null,
    pub Vec<Root99ItemItem1Item>,
    pub Null,
    pub Root99ItemItem3,
    pub Root99ItemItem4,
);

#[repr(transparent)]
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct Root1000Item0(pub String);
impl std::ops::Deref for Root1000Item0 {
    type Target = String;
    fn deref(&self) -> &Self::Target { &self.0 }
}
static RE_ROOT1000ITEM0: Lazy<Regex> = Lazy::new(|| Regex::new("^/geo/type/establishment_poi/.*").unwrap());
impl<'de> Deserialize<'de> for Root1000Item0 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let s = String::deserialize(de)?;
        if !RE_ROOT1000ITEM0.is_match(&s) {
            return Err(DeError::custom("Root1000Item0: string failed pattern"));
        }
        Ok(Root1000Item0(s))
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum Root1000Item1 {
    DieselGas,
    GiftShop,
}
impl<'de> Deserialize<'de> for Root1000Item1 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let s = String::deserialize(de)?;
        match s.as_str() {
            "Diesel gas" => Ok(Root1000Item1::DieselGas),
            "Gift shop" => Ok(Root1000Item1::GiftShop),
            _ => Err(DeError::unknown_variant(&s, &[])),
        }
    }
}
impl serde::Serialize for Root1000Item1 {
    fn serialize<S>(&self, ser: S) -> Result<S::Ok, S::Error> where S: serde::Serializer {
        match self {
            Root1000Item1::DieselGas => ser.serialize_str("Diesel gas"),
            Root1000Item1::GiftShop => ser.serialize_str("Gift shop"),
        }
    }
}

#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root1000Item20(pub i64);
impl std::ops::Deref for Root1000Item20 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root1000Item20 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 1 { return Err(DeError::custom("Root1000Item20: integer below minimum")); }
        if x > 1 { return Err(DeError::custom("Root1000Item20: integer above maximum")); }
        
        Ok(Root1000Item20(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root1000Item21Item0(pub i64);
impl std::ops::Deref for Root1000Item21Item0 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root1000Item21Item0 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 1 { return Err(DeError::custom("Root1000Item21Item0: integer below minimum")); }
        if x > 1 { return Err(DeError::custom("Root1000Item21Item0: integer above maximum")); }
        
        Ok(Root1000Item21Item0(x))
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum Root1000Item21Item1 {
    DieselGas,
    GiftShop,
}
impl<'de> Deserialize<'de> for Root1000Item21Item1 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let s = String::deserialize(de)?;
        match s.as_str() {
            "Diesel gas" => Ok(Root1000Item21Item1::DieselGas),
            "Gift shop" => Ok(Root1000Item21Item1::GiftShop),
            _ => Err(DeError::unknown_variant(&s, &[])),
        }
    }
}
impl serde::Serialize for Root1000Item21Item1 {
    fn serialize<S>(&self, ser: S) -> Result<S::Ok, S::Error> where S: serde::Serializer {
        match self {
            Root1000Item21Item1::DieselGas => ser.serialize_str("Diesel gas"),
            Root1000Item21Item1::GiftShop => ser.serialize_str("Gift shop"),
        }
    }
}

/// tuple len=2 (required first 2 slots)
#[derive(Debug, Deserialize)]
pub struct Root1000Item21Item(
    pub Root1000Item21Item0,
    pub Root1000Item21Item1,
);

#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root1000Item220(pub i64);
impl std::ops::Deref for Root1000Item220 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root1000Item220 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 1 { return Err(DeError::custom("Root1000Item220: integer below minimum")); }
        if x > 1 { return Err(DeError::custom("Root1000Item220: integer above maximum")); }
        
        Ok(Root1000Item220(x))
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum Root1000Item221 {
    DieselGas,
    GiftShop,
}
impl<'de> Deserialize<'de> for Root1000Item221 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let s = String::deserialize(de)?;
        match s.as_str() {
            "Diesel gas" => Ok(Root1000Item221::DieselGas),
            "Gift shop" => Ok(Root1000Item221::GiftShop),
            _ => Err(DeError::unknown_variant(&s, &[])),
        }
    }
}
impl serde::Serialize for Root1000Item221 {
    fn serialize<S>(&self, ser: S) -> Result<S::Ok, S::Error> where S: serde::Serializer {
        match self {
            Root1000Item221::DieselGas => ser.serialize_str("Diesel gas"),
            Root1000Item221::GiftShop => ser.serialize_str("Gift shop"),
        }
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum Root1000Item222 {
    DieselGas,
    GiftShop,
}
impl<'de> Deserialize<'de> for Root1000Item222 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let s = String::deserialize(de)?;
        match s.as_str() {
            "Diesel gas" => Ok(Root1000Item222::DieselGas),
            "Gift shop" => Ok(Root1000Item222::GiftShop),
            _ => Err(DeError::unknown_variant(&s, &[])),
        }
    }
}
impl serde::Serialize for Root1000Item222 {
    fn serialize<S>(&self, ser: S) -> Result<S::Ok, S::Error> where S: serde::Serializer {
        match self {
            Root1000Item222::DieselGas => ser.serialize_str("Diesel gas"),
            Root1000Item222::GiftShop => ser.serialize_str("Gift shop"),
        }
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum Root1000Item223 {
    HasGiftShop,
    SellsDieselGas,
}
impl<'de> Deserialize<'de> for Root1000Item223 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let s = String::deserialize(de)?;
        match s.as_str() {
            "Has gift shop" => Ok(Root1000Item223::HasGiftShop),
            "Sells diesel gas" => Ok(Root1000Item223::SellsDieselGas),
            _ => Err(DeError::unknown_variant(&s, &[])),
        }
    }
}
impl serde::Serialize for Root1000Item223 {
    fn serialize<S>(&self, ser: S) -> Result<S::Ok, S::Error> where S: serde::Serializer {
        match self {
            Root1000Item223::HasGiftShop => ser.serialize_str("Has gift shop"),
            Root1000Item223::SellsDieselGas => ser.serialize_str("Sells diesel gas"),
        }
    }
}

/// tuple len=4 (required first 4 slots)
#[derive(Debug, Deserialize)]
pub struct Root1000Item22(
    pub Root1000Item220,
    pub Root1000Item221,
    pub Root1000Item222,
    pub Root1000Item223,
);

/// tuple len=3 (required first 3 slots)
#[derive(Debug, Deserialize)]
pub struct Root1000Item2(
    pub Root1000Item20,
    pub Vec<Root1000Item21Item>,
    pub Root1000Item22,
);

#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root1000Item4Item(pub i64);
impl std::ops::Deref for Root1000Item4Item {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root1000Item4Item {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 1 { return Err(DeError::custom("Root1000Item4Item: integer below minimum")); }
        if x > 54 { return Err(DeError::custom("Root1000Item4Item: integer above maximum")); }
        
        Ok(Root1000Item4Item(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root1000Item5(pub i64);
impl std::ops::Deref for Root1000Item5 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root1000Item5 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 0 { return Err(DeError::custom("Root1000Item5: integer below minimum")); }
        if x > 0 { return Err(DeError::custom("Root1000Item5: integer above maximum")); }
        
        Ok(Root1000Item5(x))
    }
}
/// tuple len=6 (required first 6 slots)
#[derive(Debug, Deserialize)]
pub struct Root1000Item(
    pub Root1000Item0,
    pub Root1000Item1,
    pub Root1000Item2,
    pub Null,
    pub Vec<Root1000Item4Item>,
    pub Root1000Item5,
);

#[repr(transparent)]
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct Root1001Item2Item0(pub String);
impl std::ops::Deref for Root1001Item2Item0 {
    type Target = String;
    fn deref(&self) -> &Self::Target { &self.0 }
}
static RE_ROOT1001ITEM2ITEM0: Lazy<Regex> = Lazy::new(|| Regex::new("^/geo/type/.*").unwrap());
impl<'de> Deserialize<'de> for Root1001Item2Item0 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let s = String::deserialize(de)?;
        if !RE_ROOT1001ITEM2ITEM0.is_match(&s) {
            return Err(DeError::custom("Root1001Item2Item0: string failed pattern"));
        }
        Ok(Root1001Item2Item0(s))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root1001Item2Item20(pub i64);
impl std::ops::Deref for Root1001Item2Item20 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root1001Item2Item20 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 1 { return Err(DeError::custom("Root1001Item2Item20: integer below minimum")); }
        if x > 3 { return Err(DeError::custom("Root1001Item2Item20: integer above maximum")); }
        
        Ok(Root1001Item2Item20(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root1001Item2Item21Item0(pub i64);
impl std::ops::Deref for Root1001Item2Item21Item0 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root1001Item2Item21Item0 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 0 { return Err(DeError::custom("Root1001Item2Item21Item0: integer below minimum")); }
        if x > 1 { return Err(DeError::custom("Root1001Item2Item21Item0: integer above maximum")); }
        
        Ok(Root1001Item2Item21Item0(x))
    }
}
/// tuple len=2 (required first 2 slots)
#[derive(Debug, Deserialize)]
pub struct Root1001Item2Item21Item(
    pub Root1001Item2Item21Item0,
    pub String,
);

#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root1001Item2Item220(pub i64);
impl std::ops::Deref for Root1001Item2Item220 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root1001Item2Item220 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 0 { return Err(DeError::custom("Root1001Item2Item220: integer below minimum")); }
        if x > 1 { return Err(DeError::custom("Root1001Item2Item220: integer above maximum")); }
        
        Ok(Root1001Item2Item220(x))
    }
}
/// tuple len=4 (required first 4 slots)
#[derive(Debug, Deserialize)]
pub struct Root1001Item2Item22(
    pub Root1001Item2Item220,
    pub String,
    pub String,
    pub String,
);

#[repr(transparent)]
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct Root1001Item2Item230(pub String);
impl std::ops::Deref for Root1001Item2Item230 {
    type Target = String;
    fn deref(&self) -> &Self::Target { &self.0 }
}
static RE_ROOT1001ITEM2ITEM230: Lazy<Regex> = Lazy::new(|| Regex::new("^/g/11g6nbss9b.*").unwrap());
impl<'de> Deserialize<'de> for Root1001Item2Item230 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let s = String::deserialize(de)?;
        if !RE_ROOT1001ITEM2ITEM230.is_match(&s) {
            return Err(DeError::custom("Root1001Item2Item230: string failed pattern"));
        }
        Ok(Root1001Item2Item230(s))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct Root1001Item2Item232(pub String);
impl std::ops::Deref for Root1001Item2Item232 {
    type Target = String;
    fn deref(&self) -> &Self::Target { &self.0 }
}
static RE_ROOT1001ITEM2ITEM232: Lazy<Regex> = Lazy::new(|| Regex::new("^Free Wi-Fi.*").unwrap());
impl<'de> Deserialize<'de> for Root1001Item2Item232 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let s = String::deserialize(de)?;
        if !RE_ROOT1001ITEM2ITEM232.is_match(&s) {
            return Err(DeError::custom("Root1001Item2Item232: string failed pattern"));
        }
        Ok(Root1001Item2Item232(s))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct Root1001Item2Item233(pub String);
impl std::ops::Deref for Root1001Item2Item233 {
    type Target = String;
    fn deref(&self) -> &Self::Target { &self.0 }
}
static RE_ROOT1001ITEM2ITEM233: Lazy<Regex> = Lazy::new(|| Regex::new("^Free Wi-Fi.*").unwrap());
impl<'de> Deserialize<'de> for Root1001Item2Item233 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let s = String::deserialize(de)?;
        if !RE_ROOT1001ITEM2ITEM233.is_match(&s) {
            return Err(DeError::custom("Root1001Item2Item233: string failed pattern"));
        }
        Ok(Root1001Item2Item233(s))
    }
}
/// tuple len=4 (required first 4 slots)
#[derive(Debug, Deserialize)]
pub struct Root1001Item2Item23(
    pub Root1001Item2Item230,
    pub Null,
    pub Root1001Item2Item232,
    pub Root1001Item2Item233,
);

/// tuple len=4 (required first 4 slots)
#[derive(Debug, Deserialize)]
pub struct Root1001Item2Item241Item0Item(
    pub String,
    pub Null,
    pub String,
    pub String,
);

#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root1001Item2Item241Item1(pub i64);
impl std::ops::Deref for Root1001Item2Item241Item1 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root1001Item2Item241Item1 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 1 { return Err(DeError::custom("Root1001Item2Item241Item1: integer below minimum")); }
        if x > 1 { return Err(DeError::custom("Root1001Item2Item241Item1: integer above maximum")); }
        
        Ok(Root1001Item2Item241Item1(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root1001Item2Item241Item2Item(pub i64);
impl std::ops::Deref for Root1001Item2Item241Item2Item {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root1001Item2Item241Item2Item {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 1 { return Err(DeError::custom("Root1001Item2Item241Item2Item: integer below minimum")); }
        if x > 2 { return Err(DeError::custom("Root1001Item2Item241Item2Item: integer above maximum")); }
        
        Ok(Root1001Item2Item241Item2Item(x))
    }
}
/// tuple len=3 (required first 3 slots)
#[derive(Debug, Deserialize)]
pub struct Root1001Item2Item241Item(
    pub Vec<Root1001Item2Item241Item0Item>,
    pub Option<Root1001Item2Item241Item1>,
    pub Vec<Root1001Item2Item241Item2Item>,
);

/// tuple len=2 (required first 2 slots)
#[derive(Debug, Deserialize)]
pub struct Root1001Item2Item24(
    pub Null,
    pub Vec<Option<Root1001Item2Item241Item>>,
);

/// tuple len=5 (required first 1 slots)
#[derive(Debug, Deserialize)]
pub struct Root1001Item2Item2(
    pub Root1001Item2Item20,
    pub Option<Vec<Root1001Item2Item21Item>>,
    pub Option<Root1001Item2Item22>,
    pub Option<Root1001Item2Item23>,
    pub Option<Root1001Item2Item24>,
);

#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root1001Item2Item3(pub i64);
impl std::ops::Deref for Root1001Item2Item3 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root1001Item2Item3 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 1 { return Err(DeError::custom("Root1001Item2Item3: integer below minimum")); }
        if x > 1 { return Err(DeError::custom("Root1001Item2Item3: integer above maximum")); }
        
        Ok(Root1001Item2Item3(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root1001Item2Item4Item(pub i64);
impl std::ops::Deref for Root1001Item2Item4Item {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root1001Item2Item4Item {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 1 { return Err(DeError::custom("Root1001Item2Item4Item: integer below minimum")); }
        if x > 125 { return Err(DeError::custom("Root1001Item2Item4Item: integer above maximum")); }
        
        Ok(Root1001Item2Item4Item(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root1001Item2Item5(pub i64);
impl std::ops::Deref for Root1001Item2Item5 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root1001Item2Item5 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 0 { return Err(DeError::custom("Root1001Item2Item5: integer below minimum")); }
        if x > 0 { return Err(DeError::custom("Root1001Item2Item5: integer above maximum")); }
        
        Ok(Root1001Item2Item5(x))
    }
}
/// tuple len=6 (required first 6 slots)
#[derive(Debug, Deserialize)]
pub struct Root1001Item2Item(
    pub Root1001Item2Item0,
    pub String,
    pub Root1001Item2Item2,
    pub Option<Root1001Item2Item3>,
    pub Vec<Root1001Item2Item4Item>,
    pub Root1001Item2Item5,
);

/// tuple len=3 (required first 3 slots)
#[derive(Debug, Deserialize)]
pub struct Root1001Item(
    pub String,
    pub String,
    pub Vec<Root1001Item2Item>,
);

#[repr(transparent)]
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct Root1003Item0(pub String);
impl std::ops::Deref for Root1003Item0 {
    type Target = String;
    fn deref(&self) -> &Self::Target { &self.0 }
}
static RE_ROOT1003ITEM0: Lazy<Regex> = Lazy::new(|| Regex::new("^/geo/type/establishment_poi/.*").unwrap());
impl<'de> Deserialize<'de> for Root1003Item0 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let s = String::deserialize(de)?;
        if !RE_ROOT1003ITEM0.is_match(&s) {
            return Err(DeError::custom("Root1003Item0: string failed pattern"));
        }
        Ok(Root1003Item0(s))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root1003Item20(pub i64);
impl std::ops::Deref for Root1003Item20 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root1003Item20 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 1 { return Err(DeError::custom("Root1003Item20: integer below minimum")); }
        if x > 1 { return Err(DeError::custom("Root1003Item20: integer above maximum")); }
        
        Ok(Root1003Item20(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root1003Item21Item0(pub i64);
impl std::ops::Deref for Root1003Item21Item0 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root1003Item21Item0 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 1 { return Err(DeError::custom("Root1003Item21Item0: integer below minimum")); }
        if x > 1 { return Err(DeError::custom("Root1003Item21Item0: integer above maximum")); }
        
        Ok(Root1003Item21Item0(x))
    }
}
/// tuple len=2 (required first 2 slots)
#[derive(Debug, Deserialize)]
pub struct Root1003Item21Item(
    pub Root1003Item21Item0,
    pub String,
);

#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root1003Item220(pub i64);
impl std::ops::Deref for Root1003Item220 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root1003Item220 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 1 { return Err(DeError::custom("Root1003Item220: integer below minimum")); }
        if x > 1 { return Err(DeError::custom("Root1003Item220: integer above maximum")); }
        
        Ok(Root1003Item220(x))
    }
}
/// tuple len=4 (required first 4 slots)
#[derive(Debug, Deserialize)]
pub struct Root1003Item22(
    pub Root1003Item220,
    pub String,
    pub String,
    pub String,
);

/// tuple len=3 (required first 3 slots)
#[derive(Debug, Deserialize)]
pub struct Root1003Item2(
    pub Root1003Item20,
    pub Vec<Root1003Item21Item>,
    pub Root1003Item22,
);

#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root1003Item4Item(pub i64);
impl std::ops::Deref for Root1003Item4Item {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root1003Item4Item {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 1 { return Err(DeError::custom("Root1003Item4Item: integer below minimum")); }
        if x > 85 { return Err(DeError::custom("Root1003Item4Item: integer above maximum")); }
        
        Ok(Root1003Item4Item(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root1003Item5(pub i64);
impl std::ops::Deref for Root1003Item5 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root1003Item5 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 0 { return Err(DeError::custom("Root1003Item5: integer below minimum")); }
        if x > 0 { return Err(DeError::custom("Root1003Item5: integer above maximum")); }
        
        Ok(Root1003Item5(x))
    }
}
/// tuple len=6 (required first 6 slots)
#[derive(Debug, Deserialize)]
pub struct Root1003Item(
    pub Root1003Item0,
    pub String,
    pub Root1003Item2,
    pub Null,
    pub Vec<Root1003Item4Item>,
    pub Root1003Item5,
);

#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root1005Item2Item20(pub i64);
impl std::ops::Deref for Root1005Item2Item20 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root1005Item2Item20 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 1 { return Err(DeError::custom("Root1005Item2Item20: integer below minimum")); }
        if x > 3 { return Err(DeError::custom("Root1005Item2Item20: integer above maximum")); }
        
        Ok(Root1005Item2Item20(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root1005Item2Item21Item0(pub i64);
impl std::ops::Deref for Root1005Item2Item21Item0 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root1005Item2Item21Item0 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 0 { return Err(DeError::custom("Root1005Item2Item21Item0: integer below minimum")); }
        if x > 1 { return Err(DeError::custom("Root1005Item2Item21Item0: integer above maximum")); }
        
        Ok(Root1005Item2Item21Item0(x))
    }
}
/// tuple len=2 (required first 2 slots)
#[derive(Debug, Deserialize)]
pub struct Root1005Item2Item21Item(
    pub Root1005Item2Item21Item0,
    pub String,
);

#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root1005Item2Item220(pub i64);
impl std::ops::Deref for Root1005Item2Item220 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root1005Item2Item220 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 0 { return Err(DeError::custom("Root1005Item2Item220: integer below minimum")); }
        if x > 1 { return Err(DeError::custom("Root1005Item2Item220: integer above maximum")); }
        
        Ok(Root1005Item2Item220(x))
    }
}
/// tuple len=4 (required first 1 slots)
#[derive(Debug, Deserialize)]
pub struct Root1005Item2Item22(
    pub Root1005Item2Item220,
    pub Option<String>,
    pub Option<String>,
    pub Option<String>,
);

#[repr(transparent)]
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct Root1005Item2Item230(pub String);
impl std::ops::Deref for Root1005Item2Item230 {
    type Target = String;
    fn deref(&self) -> &Self::Target { &self.0 }
}
static RE_ROOT1005ITEM2ITEM230: Lazy<Regex> = Lazy::new(|| Regex::new("^/g/11.*").unwrap());
impl<'de> Deserialize<'de> for Root1005Item2Item230 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let s = String::deserialize(de)?;
        if !RE_ROOT1005ITEM2ITEM230.is_match(&s) {
            return Err(DeError::custom("Root1005Item2Item230: string failed pattern"));
        }
        Ok(Root1005Item2Item230(s))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root1005Item2Item231(pub i64);
impl std::ops::Deref for Root1005Item2Item231 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root1005Item2Item231 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 2 { return Err(DeError::custom("Root1005Item2Item231: integer below minimum")); }
        if x > 2 { return Err(DeError::custom("Root1005Item2Item231: integer above maximum")); }
        
        Ok(Root1005Item2Item231(x))
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum Root1005Item2Item232 {
    V2Star,
    Expensive,
    Inexpensive,
    Moderate,
    SomeKosherFood,
}
impl<'de> Deserialize<'de> for Root1005Item2Item232 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let s = String::deserialize(de)?;
        match s.as_str() {
            "2-star" => Ok(Root1005Item2Item232::V2Star),
            "Expensive" => Ok(Root1005Item2Item232::Expensive),
            "Inexpensive" => Ok(Root1005Item2Item232::Inexpensive),
            "Moderate" => Ok(Root1005Item2Item232::Moderate),
            "Some kosher food" => Ok(Root1005Item2Item232::SomeKosherFood),
            _ => Err(DeError::unknown_variant(&s, &[])),
        }
    }
}
impl serde::Serialize for Root1005Item2Item232 {
    fn serialize<S>(&self, ser: S) -> Result<S::Ok, S::Error> where S: serde::Serializer {
        match self {
            Root1005Item2Item232::V2Star => ser.serialize_str("2-star"),
            Root1005Item2Item232::Expensive => ser.serialize_str("Expensive"),
            Root1005Item2Item232::Inexpensive => ser.serialize_str("Inexpensive"),
            Root1005Item2Item232::Moderate => ser.serialize_str("Moderate"),
            Root1005Item2Item232::SomeKosherFood => ser.serialize_str("Some kosher food"),
        }
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum Root1005Item2Item233 {
    V2Star,
    Expensive,
    Inexpensive,
    Moderate,
    SomeKosherFood,
}
impl<'de> Deserialize<'de> for Root1005Item2Item233 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let s = String::deserialize(de)?;
        match s.as_str() {
            "2-star" => Ok(Root1005Item2Item233::V2Star),
            "Expensive" => Ok(Root1005Item2Item233::Expensive),
            "Inexpensive" => Ok(Root1005Item2Item233::Inexpensive),
            "Moderate" => Ok(Root1005Item2Item233::Moderate),
            "Some kosher food" => Ok(Root1005Item2Item233::SomeKosherFood),
            _ => Err(DeError::unknown_variant(&s, &[])),
        }
    }
}
impl serde::Serialize for Root1005Item2Item233 {
    fn serialize<S>(&self, ser: S) -> Result<S::Ok, S::Error> where S: serde::Serializer {
        match self {
            Root1005Item2Item233::V2Star => ser.serialize_str("2-star"),
            Root1005Item2Item233::Expensive => ser.serialize_str("Expensive"),
            Root1005Item2Item233::Inexpensive => ser.serialize_str("Inexpensive"),
            Root1005Item2Item233::Moderate => ser.serialize_str("Moderate"),
            Root1005Item2Item233::SomeKosherFood => ser.serialize_str("Some kosher food"),
        }
    }
}

/// tuple len=4 (required first 4 slots)
#[derive(Debug, Deserialize)]
pub struct Root1005Item2Item23(
    pub Root1005Item2Item230,
    pub Option<Root1005Item2Item231>,
    pub Root1005Item2Item232,
    pub Root1005Item2Item233,
);

#[repr(transparent)]
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct Root1005Item2Item241Item0Item0(pub String);
impl std::ops::Deref for Root1005Item2Item241Item0Item0 {
    type Target = String;
    fn deref(&self) -> &Self::Target { &self.0 }
}
static RE_ROOT1005ITEM2ITEM241ITEM0ITEM0: Lazy<Regex> = Lazy::new(|| Regex::new("^/g/11tcz6y5yl.*").unwrap());
impl<'de> Deserialize<'de> for Root1005Item2Item241Item0Item0 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let s = String::deserialize(de)?;
        if !RE_ROOT1005ITEM2ITEM241ITEM0ITEM0.is_match(&s) {
            return Err(DeError::custom("Root1005Item2Item241Item0Item0: string failed pattern"));
        }
        Ok(Root1005Item2Item241Item0Item0(s))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct Root1005Item2Item241Item0Item2(pub String);
impl std::ops::Deref for Root1005Item2Item241Item0Item2 {
    type Target = String;
    fn deref(&self) -> &Self::Target { &self.0 }
}
static RE_ROOT1005ITEM2ITEM241ITEM0ITEM2: Lazy<Regex> = Lazy::new(|| Regex::new("^Moderna booster vaccine.*").unwrap());
impl<'de> Deserialize<'de> for Root1005Item2Item241Item0Item2 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let s = String::deserialize(de)?;
        if !RE_ROOT1005ITEM2ITEM241ITEM0ITEM2.is_match(&s) {
            return Err(DeError::custom("Root1005Item2Item241Item0Item2: string failed pattern"));
        }
        Ok(Root1005Item2Item241Item0Item2(s))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct Root1005Item2Item241Item0Item3(pub String);
impl std::ops::Deref for Root1005Item2Item241Item0Item3 {
    type Target = String;
    fn deref(&self) -> &Self::Target { &self.0 }
}
static RE_ROOT1005ITEM2ITEM241ITEM0ITEM3: Lazy<Regex> = Lazy::new(|| Regex::new("^Moderna booster vaccine.*").unwrap());
impl<'de> Deserialize<'de> for Root1005Item2Item241Item0Item3 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let s = String::deserialize(de)?;
        if !RE_ROOT1005ITEM2ITEM241ITEM0ITEM3.is_match(&s) {
            return Err(DeError::custom("Root1005Item2Item241Item0Item3: string failed pattern"));
        }
        Ok(Root1005Item2Item241Item0Item3(s))
    }
}
/// tuple len=4 (required first 4 slots)
#[derive(Debug, Deserialize)]
pub struct Root1005Item2Item241Item0Item(
    pub Root1005Item2Item241Item0Item0,
    pub Null,
    pub Root1005Item2Item241Item0Item2,
    pub Root1005Item2Item241Item0Item3,
);

#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root1005Item2Item241Item20(pub i64);
impl std::ops::Deref for Root1005Item2Item241Item20 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root1005Item2Item241Item20 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 1 { return Err(DeError::custom("Root1005Item2Item241Item20: integer below minimum")); }
        if x > 1 { return Err(DeError::custom("Root1005Item2Item241Item20: integer above maximum")); }
        
        Ok(Root1005Item2Item241Item20(x))
    }
}
/// tuple len=1 (required first 1 slots)
#[derive(Debug, Deserialize)]
pub struct Root1005Item2Item241Item2(
    pub Root1005Item2Item241Item20,
);

/// tuple len=3 (required first 3 slots)
#[derive(Debug, Deserialize)]
pub struct Root1005Item2Item241Item(
    pub Vec<Root1005Item2Item241Item0Item>,
    pub Null,
    pub Root1005Item2Item241Item2,
);

/// tuple len=2 (required first 2 slots)
#[derive(Debug, Deserialize)]
pub struct Root1005Item2Item24(
    pub Null,
    pub Vec<Root1005Item2Item241Item>,
);

/// tuple len=5 (required first 1 slots)
#[derive(Debug, Deserialize)]
pub struct Root1005Item2Item2(
    pub Root1005Item2Item20,
    pub Option<Vec<Root1005Item2Item21Item>>,
    pub Option<Root1005Item2Item22>,
    pub Option<Root1005Item2Item23>,
    pub Option<Root1005Item2Item24>,
);

#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root1005Item2Item3(pub i64);
impl std::ops::Deref for Root1005Item2Item3 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root1005Item2Item3 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 1 { return Err(DeError::custom("Root1005Item2Item3: integer below minimum")); }
        if x > 1 { return Err(DeError::custom("Root1005Item2Item3: integer above maximum")); }
        
        Ok(Root1005Item2Item3(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root1005Item2Item4Item(pub i64);
impl std::ops::Deref for Root1005Item2Item4Item {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root1005Item2Item4Item {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 1 { return Err(DeError::custom("Root1005Item2Item4Item: integer below minimum")); }
        if x > 30 { return Err(DeError::custom("Root1005Item2Item4Item: integer above maximum")); }
        
        Ok(Root1005Item2Item4Item(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root1005Item2Item5(pub i64);
impl std::ops::Deref for Root1005Item2Item5 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root1005Item2Item5 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 0 { return Err(DeError::custom("Root1005Item2Item5: integer below minimum")); }
        if x > 0 { return Err(DeError::custom("Root1005Item2Item5: integer above maximum")); }
        
        Ok(Root1005Item2Item5(x))
    }
}
/// tuple len=6 (required first 6 slots)
#[derive(Debug, Deserialize)]
pub struct Root1005Item2Item(
    pub String,
    pub String,
    pub Root1005Item2Item2,
    pub Option<Root1005Item2Item3>,
    pub Vec<Root1005Item2Item4Item>,
    pub Root1005Item2Item5,
);

/// tuple len=3 (required first 3 slots)
#[derive(Debug, Deserialize)]
pub struct Root1005Item(
    pub String,
    pub String,
    pub Vec<Root1005Item2Item>,
);

/// tuple len=6 (required first 5 slots)
#[derive(Debug, Deserialize)]
pub struct Root100(
    pub Option<Vec<Root1000Item>>,
    pub Vec<Root1001Item>,
    pub Null,
    pub Option<Vec<Root1003Item>>,
    pub Null,
    pub Option<Vec<Root1005Item>>,
);

#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root105ItemItem0Item0Alt0(pub i64);
impl std::ops::Deref for Root105ItemItem0Item0Alt0 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root105ItemItem0Item0Alt0 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 2 { return Err(DeError::custom("Root105ItemItem0Item0Alt0: integer below minimum")); }
        if x > 2 { return Err(DeError::custom("Root105ItemItem0Item0Alt0: integer above maximum")); }
        
        Ok(Root105ItemItem0Item0Alt0(x))
    }
}
#[derive(Debug)]
pub enum Root105ItemItem0Item0 {
    V0(Root105ItemItem0Item0Alt0),
    V1(String),
}

impl<'de> Deserialize<'de> for Root105ItemItem0Item0 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        // deserialize into a serde_json::Value once, then attempt each arm (strict)
        let val = serde_json::Value::deserialize(de)?;
        if let Ok(x) = <Root105ItemItem0Item0Alt0 as serde::Deserialize>::deserialize(val.clone()) { return Ok(Root105ItemItem0Item0::V0(x)); }
        if let Ok(x) = <String as serde::Deserialize>::deserialize(val.clone()) { return Ok(Root105ItemItem0Item0::V1(x)); }
        Err(DeError::custom("no union arm matched"))
    }
}

#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root105ItemItem0Item1(pub i64);
impl std::ops::Deref for Root105ItemItem0Item1 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root105ItemItem0Item1 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 10 { return Err(DeError::custom("Root105ItemItem0Item1: integer below minimum")); }
        if x > 10 { return Err(DeError::custom("Root105ItemItem0Item1: integer above maximum")); }
        
        Ok(Root105ItemItem0Item1(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root105ItemItem0Item2(pub i64);
impl std::ops::Deref for Root105ItemItem0Item2 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root105ItemItem0Item2 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 12 { return Err(DeError::custom("Root105ItemItem0Item2: integer below minimum")); }
        if x > 12 { return Err(DeError::custom("Root105ItemItem0Item2: integer above maximum")); }
        
        Ok(Root105ItemItem0Item2(x))
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum Root105ItemItem0Item3 {
    V,
}
impl<'de> Deserialize<'de> for Root105ItemItem0Item3 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let s = String::deserialize(de)?;
        match s.as_str() {
            "" => Ok(Root105ItemItem0Item3::V),
            _ => Err(DeError::unknown_variant(&s, &[])),
        }
    }
}
impl serde::Serialize for Root105ItemItem0Item3 {
    fn serialize<S>(&self, ser: S) -> Result<S::Ok, S::Error> where S: serde::Serializer {
        match self {
            Root105ItemItem0Item3::V => ser.serialize_str(""),
        }
    }
}

#[repr(transparent)]
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct Root105ItemItem0Item60(pub String);
impl std::ops::Deref for Root105ItemItem0Item60 {
    type Target = String;
    fn deref(&self) -> &Self::Target { &self.0 }
}
static RE_ROOT105ITEMITEM0ITEM60: Lazy<Regex> = Lazy::new(|| Regex::new("^https://lh3\\.googleusercontent\\.com/.*").unwrap());
impl<'de> Deserialize<'de> for Root105ItemItem0Item60 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let s = String::deserialize(de)?;
        if !RE_ROOT105ITEMITEM0ITEM60.is_match(&s) {
            return Err(DeError::custom("Root105ItemItem0Item60: string failed pattern"));
        }
        Ok(Root105ItemItem0Item60(s))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root105ItemItem0Item62Item(pub i64);
impl std::ops::Deref for Root105ItemItem0Item62Item {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root105ItemItem0Item62Item {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 640 { return Err(DeError::custom("Root105ItemItem0Item62Item: integer below minimum")); }
        if x > 5712 { return Err(DeError::custom("Root105ItemItem0Item62Item: integer above maximum")); }
        
        Ok(Root105ItemItem0Item62Item(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root105ItemItem0Item630(pub i64);
impl std::ops::Deref for Root105ItemItem0Item630 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root105ItemItem0Item630 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 203 { return Err(DeError::custom("Root105ItemItem0Item630: integer below minimum")); }
        if x > 203 { return Err(DeError::custom("Root105ItemItem0Item630: integer above maximum")); }
        
        Ok(Root105ItemItem0Item630(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root105ItemItem0Item631(pub i64);
impl std::ops::Deref for Root105ItemItem0Item631 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root105ItemItem0Item631 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 100 { return Err(DeError::custom("Root105ItemItem0Item631: integer below minimum")); }
        if x > 100 { return Err(DeError::custom("Root105ItemItem0Item631: integer above maximum")); }
        
        Ok(Root105ItemItem0Item631(x))
    }
}
/// tuple len=2 (required first 2 slots)
#[derive(Debug, Deserialize)]
pub struct Root105ItemItem0Item63(
    pub Root105ItemItem0Item630,
    pub Root105ItemItem0Item631,
);

/// tuple len=4 (required first 4 slots)
#[derive(Debug, Deserialize)]
pub struct Root105ItemItem0Item6(
    pub Root105ItemItem0Item60,
    pub String,
    pub Vec<Root105ItemItem0Item62Item>,
    pub Root105ItemItem0Item63,
);

#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root105ItemItem0Item800(pub i64);
impl std::ops::Deref for Root105ItemItem0Item800 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root105ItemItem0Item800 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 3 { return Err(DeError::custom("Root105ItemItem0Item800: integer below minimum")); }
        if x > 3 { return Err(DeError::custom("Root105ItemItem0Item800: integer above maximum")); }
        
        Ok(Root105ItemItem0Item800(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub struct Root105ItemItem0Item801(pub f64);
impl std::ops::Deref for Root105ItemItem0Item801 {
    type Target = f64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root105ItemItem0Item801 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = f64::deserialize(de)?;
        if !x.is_finite() { return Err(DeError::custom("Root105ItemItem0Item801: non-finite number")); }
        if x < -113.128302199999993 { return Err(DeError::custom("Root105ItemItem0Item801: number below minimum")); }
        if x > -111.824759400000005 { return Err(DeError::custom("Root105ItemItem0Item801: number above maximum")); }
        
        Ok(Root105ItemItem0Item801(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub struct Root105ItemItem0Item802(pub f64);
impl std::ops::Deref for Root105ItemItem0Item802 {
    type Target = f64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root105ItemItem0Item802 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = f64::deserialize(de)?;
        if !x.is_finite() { return Err(DeError::custom("Root105ItemItem0Item802: non-finite number")); }
        if x < 37.100494999999995 { return Err(DeError::custom("Root105ItemItem0Item802: number below minimum")); }
        if x > 40.433213100000003 { return Err(DeError::custom("Root105ItemItem0Item802: number above maximum")); }
        
        Ok(Root105ItemItem0Item802(x))
    }
}
/// tuple len=3 (required first 3 slots)
#[derive(Debug, Deserialize)]
pub struct Root105ItemItem0Item80(
    pub Root105ItemItem0Item800,
    pub Root105ItemItem0Item801,
    pub Root105ItemItem0Item802,
);

#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root105ItemItem0Item810(pub i64);
impl std::ops::Deref for Root105ItemItem0Item810 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root105ItemItem0Item810 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 0 { return Err(DeError::custom("Root105ItemItem0Item810: integer below minimum")); }
        if x > 0 { return Err(DeError::custom("Root105ItemItem0Item810: integer above maximum")); }
        
        Ok(Root105ItemItem0Item810(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root105ItemItem0Item811(pub i64);
impl std::ops::Deref for Root105ItemItem0Item811 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root105ItemItem0Item811 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 90 { return Err(DeError::custom("Root105ItemItem0Item811: integer below minimum")); }
        if x > 90 { return Err(DeError::custom("Root105ItemItem0Item811: integer above maximum")); }
        
        Ok(Root105ItemItem0Item811(x))
    }
}
/// tuple len=2 (required first 2 slots)
#[derive(Debug, Deserialize)]
pub struct Root105ItemItem0Item81(
    pub Root105ItemItem0Item810,
    pub Root105ItemItem0Item811,
);

#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root105ItemItem0Item82Item(pub i64);
impl std::ops::Deref for Root105ItemItem0Item82Item {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root105ItemItem0Item82Item {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 640 { return Err(DeError::custom("Root105ItemItem0Item82Item: integer below minimum")); }
        if x > 5712 { return Err(DeError::custom("Root105ItemItem0Item82Item: integer above maximum")); }
        
        Ok(Root105ItemItem0Item82Item(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root105ItemItem0Item83(pub i64);
impl std::ops::Deref for Root105ItemItem0Item83 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root105ItemItem0Item83 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 75 { return Err(DeError::custom("Root105ItemItem0Item83: integer below minimum")); }
        if x > 75 { return Err(DeError::custom("Root105ItemItem0Item83: integer above maximum")); }
        
        Ok(Root105ItemItem0Item83(x))
    }
}
/// tuple len=4 (required first 4 slots)
#[derive(Debug, Deserialize)]
pub struct Root105ItemItem0Item8(
    pub Root105ItemItem0Item80,
    pub Root105ItemItem0Item81,
    pub Vec<Root105ItemItem0Item82Item>,
    pub Root105ItemItem0Item83,
);

#[repr(transparent)]
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct Root105ItemItem0Item10(pub String);
impl std::ops::Deref for Root105ItemItem0Item10 {
    type Target = String;
    fn deref(&self) -> &Self::Target { &self.0 }
}
static RE_ROOT105ITEMITEM0ITEM10: Lazy<Regex> = Lazy::new(|| Regex::new("^0ahUKEw.*").unwrap());
impl<'de> Deserialize<'de> for Root105ItemItem0Item10 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let s = String::deserialize(de)?;
        if !RE_ROOT105ITEMITEM0ITEM10.is_match(&s) {
            return Err(DeError::custom("Root105ItemItem0Item10: string failed pattern"));
        }
        Ok(Root105ItemItem0Item10(s))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct Root105ItemItem0Item20(pub String);
impl std::ops::Deref for Root105ItemItem0Item20 {
    type Target = String;
    fn deref(&self) -> &Self::Target { &self.0 }
}
static RE_ROOT105ITEMITEM0ITEM20: Lazy<Regex> = Lazy::new(|| Regex::new("^Photo.*").unwrap());
impl<'de> Deserialize<'de> for Root105ItemItem0Item20 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let s = String::deserialize(de)?;
        if !RE_ROOT105ITEMITEM0ITEM20.is_match(&s) {
            return Err(DeError::custom("Root105ItemItem0Item20: string failed pattern"));
        }
        Ok(Root105ItemItem0Item20(s))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root105ItemItem0Item2110(pub i64);
impl std::ops::Deref for Root105ItemItem0Item2110 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root105ItemItem0Item2110 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 10 { return Err(DeError::custom("Root105ItemItem0Item2110: integer below minimum")); }
        if x > 10 { return Err(DeError::custom("Root105ItemItem0Item2110: integer above maximum")); }
        
        Ok(Root105ItemItem0Item2110(x))
    }
}
/// tuple len=2 (required first 2 slots)
#[derive(Debug, Deserialize)]
pub struct Root105ItemItem0Item211(
    pub Root105ItemItem0Item2110,
    pub String,
);

#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root105ItemItem0Item2120(pub i64);
impl std::ops::Deref for Root105ItemItem0Item2120 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root105ItemItem0Item2120 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 10 { return Err(DeError::custom("Root105ItemItem0Item2120: integer below minimum")); }
        if x > 10 { return Err(DeError::custom("Root105ItemItem0Item2120: integer above maximum")); }
        
        Ok(Root105ItemItem0Item2120(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root105ItemItem0Item2121(pub i64);
impl std::ops::Deref for Root105ItemItem0Item2121 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root105ItemItem0Item2121 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 3 { return Err(DeError::custom("Root105ItemItem0Item2121: integer below minimum")); }
        if x > 3 { return Err(DeError::custom("Root105ItemItem0Item2121: integer above maximum")); }
        
        Ok(Root105ItemItem0Item2121(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root105ItemItem0Item2122Item(pub i64);
impl std::ops::Deref for Root105ItemItem0Item2122Item {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root105ItemItem0Item2122Item {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 640 { return Err(DeError::custom("Root105ItemItem0Item2122Item: integer below minimum")); }
        if x > 5712 { return Err(DeError::custom("Root105ItemItem0Item2122Item: integer above maximum")); }
        
        Ok(Root105ItemItem0Item2122Item(x))
    }
}
/// tuple len=3 (required first 3 slots)
#[derive(Debug, Deserialize)]
pub struct Root105ItemItem0Item212(
    pub Root105ItemItem0Item2120,
    pub Root105ItemItem0Item2121,
    pub Vec<Root105ItemItem0Item2122Item>,
);

#[repr(transparent)]
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct Root105ItemItem0Item214ItemItemItemItem(pub String);
impl std::ops::Deref for Root105ItemItem0Item214ItemItemItemItem {
    type Target = String;
    fn deref(&self) -> &Self::Target { &self.0 }
}
static RE_ROOT105ITEMITEM0ITEM214ITEMITEMITEMITEM: Lazy<Regex> = Lazy::new(|| Regex::new("^Images may be subject to copyright\\..*").unwrap());
impl<'de> Deserialize<'de> for Root105ItemItem0Item214ItemItemItemItem {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let s = String::deserialize(de)?;
        if !RE_ROOT105ITEMITEM0ITEM214ITEMITEMITEMITEM.is_match(&s) {
            return Err(DeError::custom("Root105ItemItem0Item214ItemItemItemItem: string failed pattern"));
        }
        Ok(Root105ItemItem0Item214ItemItemItemItem(s))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root105ItemItem0Item215ItemItem0Alt0(pub i64);
impl std::ops::Deref for Root105ItemItem0Item215ItemItem0Alt0 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root105ItemItem0Item215ItemItem0Alt0 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 2 { return Err(DeError::custom("Root105ItemItem0Item215ItemItem0Alt0: integer below minimum")); }
        if x > 2 { return Err(DeError::custom("Root105ItemItem0Item215ItemItem0Alt0: integer above maximum")); }
        
        Ok(Root105ItemItem0Item215ItemItem0Alt0(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub struct Root105ItemItem0Item215ItemItem0Alt12(pub f64);
impl std::ops::Deref for Root105ItemItem0Item215ItemItem0Alt12 {
    type Target = f64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root105ItemItem0Item215ItemItem0Alt12 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = f64::deserialize(de)?;
        if !x.is_finite() { return Err(DeError::custom("Root105ItemItem0Item215ItemItem0Alt12: non-finite number")); }
        if x < 37.100494999999995 { return Err(DeError::custom("Root105ItemItem0Item215ItemItem0Alt12: number below minimum")); }
        if x > 40.433213100000003 { return Err(DeError::custom("Root105ItemItem0Item215ItemItem0Alt12: number above maximum")); }
        
        Ok(Root105ItemItem0Item215ItemItem0Alt12(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub struct Root105ItemItem0Item215ItemItem0Alt13(pub f64);
impl std::ops::Deref for Root105ItemItem0Item215ItemItem0Alt13 {
    type Target = f64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root105ItemItem0Item215ItemItem0Alt13 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = f64::deserialize(de)?;
        if !x.is_finite() { return Err(DeError::custom("Root105ItemItem0Item215ItemItem0Alt13: non-finite number")); }
        if x < -113.128302199999993 { return Err(DeError::custom("Root105ItemItem0Item215ItemItem0Alt13: number below minimum")); }
        if x > -111.824759400000005 { return Err(DeError::custom("Root105ItemItem0Item215ItemItem0Alt13: number above maximum")); }
        
        Ok(Root105ItemItem0Item215ItemItem0Alt13(x))
    }
}
/// tuple len=4 (required first 4 slots)
#[derive(Debug, Deserialize)]
pub struct Root105ItemItem0Item215ItemItem0Alt1(
    pub Null,
    pub Null,
    pub Root105ItemItem0Item215ItemItem0Alt12,
    pub Root105ItemItem0Item215ItemItem0Alt13,
);

#[derive(Debug)]
pub enum Root105ItemItem0Item215ItemItem0 {
    V0(Root105ItemItem0Item215ItemItem0Alt0),
    V1(Root105ItemItem0Item215ItemItem0Alt1),
}

impl<'de> Deserialize<'de> for Root105ItemItem0Item215ItemItem0 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        // deserialize into a serde_json::Value once, then attempt each arm (strict)
        let val = serde_json::Value::deserialize(de)?;
        if let Ok(x) = <Root105ItemItem0Item215ItemItem0Alt0 as serde::Deserialize>::deserialize(val.clone()) { return Ok(Root105ItemItem0Item215ItemItem0::V0(x)); }
        if let Ok(x) = <Root105ItemItem0Item215ItemItem0Alt1 as serde::Deserialize>::deserialize(val.clone()) { return Ok(Root105ItemItem0Item215ItemItem0::V1(x)); }
        Err(DeError::custom("no union arm matched"))
    }
}

/// tuple len=1 (required first 1 slots)
#[derive(Debug, Deserialize)]
pub struct Root105ItemItem0Item215ItemItem(
    pub Root105ItemItem0Item215ItemItem0,
);

#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root105ItemItem0Item2160(pub i64);
impl std::ops::Deref for Root105ItemItem0Item2160 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root105ItemItem0Item2160 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 1 { return Err(DeError::custom("Root105ItemItem0Item2160: integer below minimum")); }
        if x > 2 { return Err(DeError::custom("Root105ItemItem0Item2160: integer above maximum")); }
        
        Ok(Root105ItemItem0Item2160(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root105ItemItem0Item2163Item(pub i64);
impl std::ops::Deref for Root105ItemItem0Item2163Item {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root105ItemItem0Item2163Item {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 3 { return Err(DeError::custom("Root105ItemItem0Item2163Item: integer below minimum")); }
        if x > 8 { return Err(DeError::custom("Root105ItemItem0Item2163Item: integer above maximum")); }
        
        Ok(Root105ItemItem0Item2163Item(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root105ItemItem0Item216530(pub i64);
impl std::ops::Deref for Root105ItemItem0Item216530 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root105ItemItem0Item216530 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 6 { return Err(DeError::custom("Root105ItemItem0Item216530: integer below minimum")); }
        if x > 6 { return Err(DeError::custom("Root105ItemItem0Item216530: integer above maximum")); }
        
        Ok(Root105ItemItem0Item216530(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root105ItemItem0Item216531(pub i64);
impl std::ops::Deref for Root105ItemItem0Item216531 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root105ItemItem0Item216531 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 7 { return Err(DeError::custom("Root105ItemItem0Item216531: integer below minimum")); }
        if x > 7 { return Err(DeError::custom("Root105ItemItem0Item216531: integer above maximum")); }
        
        Ok(Root105ItemItem0Item216531(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root105ItemItem0Item216532(pub i64);
impl std::ops::Deref for Root105ItemItem0Item216532 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root105ItemItem0Item216532 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 4 { return Err(DeError::custom("Root105ItemItem0Item216532: integer below minimum")); }
        if x > 4 { return Err(DeError::custom("Root105ItemItem0Item216532: integer above maximum")); }
        
        Ok(Root105ItemItem0Item216532(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root105ItemItem0Item216533(pub i64);
impl std::ops::Deref for Root105ItemItem0Item216533 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root105ItemItem0Item216533 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 1 { return Err(DeError::custom("Root105ItemItem0Item216533: integer below minimum")); }
        if x > 1 { return Err(DeError::custom("Root105ItemItem0Item216533: integer above maximum")); }
        
        Ok(Root105ItemItem0Item216533(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root105ItemItem0Item216534(pub i64);
impl std::ops::Deref for Root105ItemItem0Item216534 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root105ItemItem0Item216534 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 3 { return Err(DeError::custom("Root105ItemItem0Item216534: integer below minimum")); }
        if x > 3 { return Err(DeError::custom("Root105ItemItem0Item216534: integer above maximum")); }
        
        Ok(Root105ItemItem0Item216534(x))
    }
}
/// tuple len=5 (required first 5 slots)
#[derive(Debug, Deserialize)]
pub struct Root105ItemItem0Item21653(
    pub Root105ItemItem0Item216530,
    pub Root105ItemItem0Item216531,
    pub Root105ItemItem0Item216532,
    pub Root105ItemItem0Item216533,
    pub Root105ItemItem0Item216534,
);

/// tuple len=4 (required first 4 slots)
#[derive(Debug, Deserialize)]
pub struct Root105ItemItem0Item2165(
    pub Null,
    pub Null,
    pub String,
    pub Root105ItemItem0Item21653,
);

#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root105ItemItem0Item21680(pub i64);
impl std::ops::Deref for Root105ItemItem0Item21680 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root105ItemItem0Item21680 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 2017 { return Err(DeError::custom("Root105ItemItem0Item21680: integer below minimum")); }
        if x > 2025 { return Err(DeError::custom("Root105ItemItem0Item21680: integer above maximum")); }
        
        Ok(Root105ItemItem0Item21680(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root105ItemItem0Item21681(pub i64);
impl std::ops::Deref for Root105ItemItem0Item21681 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root105ItemItem0Item21681 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 3 { return Err(DeError::custom("Root105ItemItem0Item21681: integer below minimum")); }
        if x > 11 { return Err(DeError::custom("Root105ItemItem0Item21681: integer above maximum")); }
        
        Ok(Root105ItemItem0Item21681(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root105ItemItem0Item21682(pub i64);
impl std::ops::Deref for Root105ItemItem0Item21682 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root105ItemItem0Item21682 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 7 { return Err(DeError::custom("Root105ItemItem0Item21682: integer below minimum")); }
        if x > 29 { return Err(DeError::custom("Root105ItemItem0Item21682: integer above maximum")); }
        
        Ok(Root105ItemItem0Item21682(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root105ItemItem0Item21683(pub i64);
impl std::ops::Deref for Root105ItemItem0Item21683 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root105ItemItem0Item21683 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 0 { return Err(DeError::custom("Root105ItemItem0Item21683: integer below minimum")); }
        if x > 23 { return Err(DeError::custom("Root105ItemItem0Item21683: integer above maximum")); }
        
        Ok(Root105ItemItem0Item21683(x))
    }
}
/// tuple len=4 (required first 4 slots)
#[derive(Debug, Deserialize)]
pub struct Root105ItemItem0Item2168(
    pub Root105ItemItem0Item21680,
    pub Root105ItemItem0Item21681,
    pub Root105ItemItem0Item21682,
    pub Root105ItemItem0Item21683,
);

/// tuple len=9 (required first 9 slots)
#[derive(Debug, Deserialize)]
pub struct Root105ItemItem0Item216(
    pub Root105ItemItem0Item2160,
    pub Null,
    pub Null,
    pub Option<Vec<Root105ItemItem0Item2163Item>>,
    pub Null,
    pub Root105ItemItem0Item2165,
    pub Null,
    pub Null,
    pub Root105ItemItem0Item2168,
);

/// tuple len=20 (required first 20 slots)
#[derive(Debug, Deserialize)]
pub struct Root105ItemItem0Item21(
    pub Null,
    pub Root105ItemItem0Item211,
    pub Root105ItemItem0Item212,
    pub Null,
    pub Vec<Vec<Vec<Vec<Root105ItemItem0Item214ItemItemItemItem>>>>,
    pub Vec<Vec<Root105ItemItem0Item215ItemItem>>,
    pub Root105ItemItem0Item216,
    pub Null,
    pub Null,
    pub Null,
    pub Null,
    pub Null,
    pub Null,
    pub Null,
    pub Null,
    pub Null,
    pub Null,
    pub Null,
    pub Null,
    pub Vec<String>,
);

#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root105ItemItem0Item22(pub i64);
impl std::ops::Deref for Root105ItemItem0Item22 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root105ItemItem0Item22 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 1 { return Err(DeError::custom("Root105ItemItem0Item22: integer below minimum")); }
        if x > 1 { return Err(DeError::custom("Root105ItemItem0Item22: integer above maximum")); }
        
        Ok(Root105ItemItem0Item22(x))
    }
}
/// tuple len=32 (required first 31 slots)
#[derive(Debug, Deserialize)]
pub struct Root105ItemItem0Item(
    pub Root105ItemItem0Item0,
    pub Option<Root105ItemItem0Item1>,
    pub Option<Root105ItemItem0Item2>,
    pub Option<Root105ItemItem0Item3>,
    pub Null,
    pub Null,
    pub Option<Root105ItemItem0Item6>,
    pub Null,
    pub Option<Root105ItemItem0Item8>,
    pub Option<String>,
    pub Option<Root105ItemItem0Item10>,
    pub Null,
    pub Null,
    pub Null,
    pub Null,
    pub Null,
    pub Null,
    pub Null,
    pub Null,
    pub Null,
    pub Option<Root105ItemItem0Item20>,
    pub Option<Root105ItemItem0Item21>,
    pub Option<Root105ItemItem0Item22>,
    pub Null,
    pub Null,
    pub Null,
    pub Null,
    pub Null,
    pub Null,
    pub Option<Vec<String>>,
    pub Null,
    pub Option<String>,
);

#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root105ItemItem1(pub i64);
impl std::ops::Deref for Root105ItemItem1 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root105ItemItem1 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 0 { return Err(DeError::custom("Root105ItemItem1: integer below minimum")); }
        if x > 1481 { return Err(DeError::custom("Root105ItemItem1: integer above maximum")); }
        
        Ok(Root105ItemItem1(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct Root105ItemItem5(pub String);
impl std::ops::Deref for Root105ItemItem5 {
    type Target = String;
    fn deref(&self) -> &Self::Target { &self.0 }
}
static RE_ROOT105ITEMITEM5: Lazy<Regex> = Lazy::new(|| Regex::new("^EvgDKYQi49-NlUMIDwAAAAEAAAMAAAAAAAAAAAAAAAAA.*").unwrap());
impl<'de> Deserialize<'de> for Root105ItemItem5 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let s = String::deserialize(de)?;
        if !RE_ROOT105ITEMITEM5.is_match(&s) {
            return Err(DeError::custom("Root105ItemItem5: string failed pattern"));
        }
        Ok(Root105ItemItem5(s))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root105ItemItem80Item0(pub i64);
impl std::ops::Deref for Root105ItemItem80Item0 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root105ItemItem80Item0 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 1 { return Err(DeError::custom("Root105ItemItem80Item0: integer below minimum")); }
        if x > 1 { return Err(DeError::custom("Root105ItemItem80Item0: integer above maximum")); }
        
        Ok(Root105ItemItem80Item0(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root105ItemItem80Item1(pub i64);
impl std::ops::Deref for Root105ItemItem80Item1 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root105ItemItem80Item1 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 0 { return Err(DeError::custom("Root105ItemItem80Item1: integer below minimum")); }
        if x > 5 { return Err(DeError::custom("Root105ItemItem80Item1: integer above maximum")); }
        
        Ok(Root105ItemItem80Item1(x))
    }
}
/// tuple len=2 (required first 2 slots)
#[derive(Debug, Deserialize)]
pub struct Root105ItemItem80Item(
    pub Root105ItemItem80Item0,
    pub Root105ItemItem80Item1,
);

#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root105ItemItem81(pub i64);
impl std::ops::Deref for Root105ItemItem81 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root105ItemItem81 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 0 { return Err(DeError::custom("Root105ItemItem81: integer below minimum")); }
        if x > 0 { return Err(DeError::custom("Root105ItemItem81: integer above maximum")); }
        
        Ok(Root105ItemItem81(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root105ItemItem83(pub i64);
impl std::ops::Deref for Root105ItemItem83 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root105ItemItem83 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 0 { return Err(DeError::custom("Root105ItemItem83: integer below minimum")); }
        if x > 1 { return Err(DeError::custom("Root105ItemItem83: integer above maximum")); }
        
        Ok(Root105ItemItem83(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root105ItemItem84(pub i64);
impl std::ops::Deref for Root105ItemItem84 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root105ItemItem84 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 0 { return Err(DeError::custom("Root105ItemItem84: integer below minimum")); }
        if x > 5 { return Err(DeError::custom("Root105ItemItem84: integer above maximum")); }
        
        Ok(Root105ItemItem84(x))
    }
}
/// tuple len=5 (required first 5 slots)
#[derive(Debug, Deserialize)]
pub struct Root105ItemItem8(
    pub Vec<Root105ItemItem80Item>,
    pub Root105ItemItem81,
    pub Null,
    pub Root105ItemItem83,
    pub Root105ItemItem84,
);

#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root105ItemItem10(pub i64);
impl std::ops::Deref for Root105ItemItem10 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root105ItemItem10 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 1 { return Err(DeError::custom("Root105ItemItem10: integer below minimum")); }
        if x > 1 { return Err(DeError::custom("Root105ItemItem10: integer above maximum")); }
        
        Ok(Root105ItemItem10(x))
    }
}
/// tuple len=11 (required first 10 slots)
#[derive(Debug, Deserialize)]
pub struct Root105ItemItem(
    pub Option<Vec<Root105ItemItem0Item>>,
    pub Option<Root105ItemItem1>,
    pub Null,
    pub Option<String>,
    pub Null,
    pub Option<Root105ItemItem5>,
    pub Null,
    pub Null,
    pub Option<Root105ItemItem8>,
    pub Null,
    pub Option<Root105ItemItem10>,
);

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum Root110 {
    En,
    Es,
}
impl<'de> Deserialize<'de> for Root110 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let s = String::deserialize(de)?;
        match s.as_str() {
            "en" => Ok(Root110::En),
            "es" => Ok(Root110::Es),
            _ => Err(DeError::unknown_variant(&s, &[])),
        }
    }
}
impl serde::Serialize for Root110 {
    fn serialize<S>(&self, ser: S) -> Result<S::Ok, S::Error> where S: serde::Serializer {
        match self {
            Root110::En => ser.serialize_str("en"),
            Root110::Es => ser.serialize_str("es"),
        }
    }
}

#[repr(transparent)]
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct Root112(pub String);
impl std::ops::Deref for Root112 {
    type Target = String;
    fn deref(&self) -> &Self::Target { &self.0 }
}
static RE_ROOT112: Lazy<Regex> = Lazy::new(|| Regex::new("^English.*").unwrap());
impl<'de> Deserialize<'de> for Root112 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let s = String::deserialize(de)?;
        if !RE_ROOT112.is_match(&s) {
            return Err(DeError::custom("Root112: string failed pattern"));
        }
        Ok(Root112(s))
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum Root113 {
    En,
}
impl<'de> Deserialize<'de> for Root113 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let s = String::deserialize(de)?;
        match s.as_str() {
            "en" => Ok(Root113::En),
            _ => Err(DeError::unknown_variant(&s, &[])),
        }
    }
}
impl serde::Serialize for Root113 {
    fn serialize<S>(&self, ser: S) -> Result<S::Ok, S::Error> where S: serde::Serializer {
        match self {
            Root113::En => ser.serialize_str("en"),
        }
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum Root118Item30Item0 {
    Friday,
    Monday,
    Saturday,
    Sunday,
    Thursday,
    Tuesday,
    Wednesday,
}
impl<'de> Deserialize<'de> for Root118Item30Item0 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let s = String::deserialize(de)?;
        match s.as_str() {
            "Friday" => Ok(Root118Item30Item0::Friday),
            "Monday" => Ok(Root118Item30Item0::Monday),
            "Saturday" => Ok(Root118Item30Item0::Saturday),
            "Sunday" => Ok(Root118Item30Item0::Sunday),
            "Thursday" => Ok(Root118Item30Item0::Thursday),
            "Tuesday" => Ok(Root118Item30Item0::Tuesday),
            "Wednesday" => Ok(Root118Item30Item0::Wednesday),
            _ => Err(DeError::unknown_variant(&s, &[])),
        }
    }
}
impl serde::Serialize for Root118Item30Item0 {
    fn serialize<S>(&self, ser: S) -> Result<S::Ok, S::Error> where S: serde::Serializer {
        match self {
            Root118Item30Item0::Friday => ser.serialize_str("Friday"),
            Root118Item30Item0::Monday => ser.serialize_str("Monday"),
            Root118Item30Item0::Saturday => ser.serialize_str("Saturday"),
            Root118Item30Item0::Sunday => ser.serialize_str("Sunday"),
            Root118Item30Item0::Thursday => ser.serialize_str("Thursday"),
            Root118Item30Item0::Tuesday => ser.serialize_str("Tuesday"),
            Root118Item30Item0::Wednesday => ser.serialize_str("Wednesday"),
        }
    }
}

#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root118Item30Item1(pub i64);
impl std::ops::Deref for Root118Item30Item1 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root118Item30Item1 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 1 { return Err(DeError::custom("Root118Item30Item1: integer below minimum")); }
        if x > 7 { return Err(DeError::custom("Root118Item30Item1: integer above maximum")); }
        
        Ok(Root118Item30Item1(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root118Item30Item20(pub i64);
impl std::ops::Deref for Root118Item30Item20 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root118Item30Item20 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 2025 { return Err(DeError::custom("Root118Item30Item20: integer below minimum")); }
        if x > 2025 { return Err(DeError::custom("Root118Item30Item20: integer above maximum")); }
        
        Ok(Root118Item30Item20(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root118Item30Item21(pub i64);
impl std::ops::Deref for Root118Item30Item21 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root118Item30Item21 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 9 { return Err(DeError::custom("Root118Item30Item21: integer below minimum")); }
        if x > 9 { return Err(DeError::custom("Root118Item30Item21: integer above maximum")); }
        
        Ok(Root118Item30Item21(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root118Item30Item22(pub i64);
impl std::ops::Deref for Root118Item30Item22 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root118Item30Item22 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 5 { return Err(DeError::custom("Root118Item30Item22: integer below minimum")); }
        if x > 11 { return Err(DeError::custom("Root118Item30Item22: integer above maximum")); }
        
        Ok(Root118Item30Item22(x))
    }
}
/// tuple len=3 (required first 3 slots)
#[derive(Debug, Deserialize)]
pub struct Root118Item30Item2(
    pub Root118Item30Item20,
    pub Root118Item30Item21,
    pub Root118Item30Item22,
);

#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root118Item30Item3Item1Item0(pub i64);
impl std::ops::Deref for Root118Item30Item3Item1Item0 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root118Item30Item3Item1Item0 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 6 { return Err(DeError::custom("Root118Item30Item3Item1Item0: integer below minimum")); }
        if x > 23 { return Err(DeError::custom("Root118Item30Item3Item1Item0: integer above maximum")); }
        
        Ok(Root118Item30Item3Item1Item0(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root118Item30Item3Item1Item1(pub i64);
impl std::ops::Deref for Root118Item30Item3Item1Item1 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root118Item30Item3Item1Item1 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 30 { return Err(DeError::custom("Root118Item30Item3Item1Item1: integer below minimum")); }
        if x > 30 { return Err(DeError::custom("Root118Item30Item3Item1Item1: integer above maximum")); }
        
        Ok(Root118Item30Item3Item1Item1(x))
    }
}
/// tuple len=2 (required first 0 slots)
#[derive(Debug, Deserialize)]
pub struct Root118Item30Item3Item1Item(
    pub Option<Root118Item30Item3Item1Item0>,
    pub Option<Root118Item30Item3Item1Item1>,
);

/// tuple len=2 (required first 1 slots)
#[derive(Debug, Deserialize)]
pub struct Root118Item30Item3Item(
    pub String,
    pub Option<Vec<Root118Item30Item3Item1Item>>,
);

#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root118Item30Item4(pub i64);
impl std::ops::Deref for Root118Item30Item4 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root118Item30Item4 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 0 { return Err(DeError::custom("Root118Item30Item4: integer below minimum")); }
        if x > 0 { return Err(DeError::custom("Root118Item30Item4: integer above maximum")); }
        
        Ok(Root118Item30Item4(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root118Item30Item5(pub i64);
impl std::ops::Deref for Root118Item30Item5 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root118Item30Item5 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 1 { return Err(DeError::custom("Root118Item30Item5: integer below minimum")); }
        if x > 2 { return Err(DeError::custom("Root118Item30Item5: integer above maximum")); }
        
        Ok(Root118Item30Item5(x))
    }
}
/// tuple len=6 (required first 6 slots)
#[derive(Debug, Deserialize)]
pub struct Root118Item30Item(
    pub Root118Item30Item0,
    pub Root118Item30Item1,
    pub Root118Item30Item2,
    pub Vec<Root118Item30Item3Item>,
    pub Root118Item30Item4,
    pub Root118Item30Item5,
);

#[repr(transparent)]
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct Root118Item3100(pub String);
impl std::ops::Deref for Root118Item3100 {
    type Target = String;
    fn deref(&self) -> &Self::Target { &self.0 }
}
static RE_ROOT118ITEM3100: Lazy<Regex> = Lazy::new(|| Regex::new("^Friday.*").unwrap());
impl<'de> Deserialize<'de> for Root118Item3100 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let s = String::deserialize(de)?;
        if !RE_ROOT118ITEM3100.is_match(&s) {
            return Err(DeError::custom("Root118Item3100: string failed pattern"));
        }
        Ok(Root118Item3100(s))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root118Item3101(pub i64);
impl std::ops::Deref for Root118Item3101 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root118Item3101 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 5 { return Err(DeError::custom("Root118Item3101: integer below minimum")); }
        if x > 5 { return Err(DeError::custom("Root118Item3101: integer above maximum")); }
        
        Ok(Root118Item3101(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root118Item31020(pub i64);
impl std::ops::Deref for Root118Item31020 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root118Item31020 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 2025 { return Err(DeError::custom("Root118Item31020: integer below minimum")); }
        if x > 2025 { return Err(DeError::custom("Root118Item31020: integer above maximum")); }
        
        Ok(Root118Item31020(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root118Item31021(pub i64);
impl std::ops::Deref for Root118Item31021 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root118Item31021 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 9 { return Err(DeError::custom("Root118Item31021: integer below minimum")); }
        if x > 9 { return Err(DeError::custom("Root118Item31021: integer above maximum")); }
        
        Ok(Root118Item31021(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root118Item31022(pub i64);
impl std::ops::Deref for Root118Item31022 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root118Item31022 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 5 { return Err(DeError::custom("Root118Item31022: integer below minimum")); }
        if x > 5 { return Err(DeError::custom("Root118Item31022: integer above maximum")); }
        
        Ok(Root118Item31022(x))
    }
}
/// tuple len=3 (required first 3 slots)
#[derive(Debug, Deserialize)]
pub struct Root118Item3102(
    pub Root118Item31020,
    pub Root118Item31021,
    pub Root118Item31022,
);

#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root118Item3103Item1Item0(pub i64);
impl std::ops::Deref for Root118Item3103Item1Item0 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root118Item3103Item1Item0 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 6 { return Err(DeError::custom("Root118Item3103Item1Item0: integer below minimum")); }
        if x > 23 { return Err(DeError::custom("Root118Item3103Item1Item0: integer above maximum")); }
        
        Ok(Root118Item3103Item1Item0(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root118Item3103Item1Item1(pub i64);
impl std::ops::Deref for Root118Item3103Item1Item1 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root118Item3103Item1Item1 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 30 { return Err(DeError::custom("Root118Item3103Item1Item1: integer below minimum")); }
        if x > 30 { return Err(DeError::custom("Root118Item3103Item1Item1: integer above maximum")); }
        
        Ok(Root118Item3103Item1Item1(x))
    }
}
/// tuple len=2 (required first 0 slots)
#[derive(Debug, Deserialize)]
pub struct Root118Item3103Item1Item(
    pub Option<Root118Item3103Item1Item0>,
    pub Option<Root118Item3103Item1Item1>,
);

/// tuple len=2 (required first 1 slots)
#[derive(Debug, Deserialize)]
pub struct Root118Item3103Item(
    pub String,
    pub Option<Vec<Root118Item3103Item1Item>>,
);

#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root118Item3104(pub i64);
impl std::ops::Deref for Root118Item3104 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root118Item3104 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 0 { return Err(DeError::custom("Root118Item3104: integer below minimum")); }
        if x > 0 { return Err(DeError::custom("Root118Item3104: integer above maximum")); }
        
        Ok(Root118Item3104(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root118Item3105(pub i64);
impl std::ops::Deref for Root118Item3105 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root118Item3105 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 1 { return Err(DeError::custom("Root118Item3105: integer below minimum")); }
        if x > 2 { return Err(DeError::custom("Root118Item3105: integer above maximum")); }
        
        Ok(Root118Item3105(x))
    }
}
/// tuple len=6 (required first 6 slots)
#[derive(Debug, Deserialize)]
pub struct Root118Item310(
    pub Root118Item3100,
    pub Root118Item3101,
    pub Root118Item3102,
    pub Vec<Root118Item3103Item>,
    pub Root118Item3104,
    pub Root118Item3105,
);

#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root118Item311(pub i64);
impl std::ops::Deref for Root118Item311 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root118Item311 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 0 { return Err(DeError::custom("Root118Item311: integer below minimum")); }
        if x > 1 { return Err(DeError::custom("Root118Item311: integer above maximum")); }
        
        Ok(Root118Item311(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root118Item312(pub i64);
impl std::ops::Deref for Root118Item312 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root118Item312 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 1 { return Err(DeError::custom("Root118Item312: integer below minimum")); }
        if x > 6 { return Err(DeError::custom("Root118Item312: integer above maximum")); }
        
        Ok(Root118Item312(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root118Item3141Item0(pub i64);
impl std::ops::Deref for Root118Item3141Item0 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root118Item3141Item0 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 0 { return Err(DeError::custom("Root118Item3141Item0: integer below minimum")); }
        if x > 0 { return Err(DeError::custom("Root118Item3141Item0: integer above maximum")); }
        
        Ok(Root118Item3141Item0(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root118Item3141Item1(pub i64);
impl std::ops::Deref for Root118Item3141Item1 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root118Item3141Item1 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 4 { return Err(DeError::custom("Root118Item3141Item1: integer below minimum")); }
        if x > 13 { return Err(DeError::custom("Root118Item3141Item1: integer above maximum")); }
        
        Ok(Root118Item3141Item1(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root118Item3141Item21Item(pub i64);
impl std::ops::Deref for Root118Item3141Item21Item {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root118Item3141Item21Item {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 4279862841 { return Err(DeError::custom("Root118Item3141Item21Item: integer below minimum")); }
        if x > 4294949673 { return Err(DeError::custom("Root118Item3141Item21Item: integer above maximum")); }
        
        Ok(Root118Item3141Item21Item(x))
    }
}
/// tuple len=2 (required first 2 slots)
#[derive(Debug, Deserialize)]
pub struct Root118Item3141Item2(
    pub Null,
    pub Vec<Root118Item3141Item21Item>,
);

/// tuple len=3 (required first 3 slots)
#[derive(Debug, Deserialize)]
pub struct Root118Item3141Item(
    pub Root118Item3141Item0,
    pub Root118Item3141Item1,
    pub Root118Item3141Item2,
);

/// tuple len=2 (required first 2 slots)
#[derive(Debug, Deserialize)]
pub struct Root118Item314(
    pub String,
    pub Vec<Root118Item3141Item>,
);

#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root118Item3151Item0(pub i64);
impl std::ops::Deref for Root118Item3151Item0 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root118Item3151Item0 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 0 { return Err(DeError::custom("Root118Item3151Item0: integer below minimum")); }
        if x > 0 { return Err(DeError::custom("Root118Item3151Item0: integer above maximum")); }
        
        Ok(Root118Item3151Item0(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root118Item3151Item1(pub i64);
impl std::ops::Deref for Root118Item3151Item1 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root118Item3151Item1 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 4 { return Err(DeError::custom("Root118Item3151Item1: integer below minimum")); }
        if x > 13 { return Err(DeError::custom("Root118Item3151Item1: integer above maximum")); }
        
        Ok(Root118Item3151Item1(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root118Item3151Item21Item(pub i64);
impl std::ops::Deref for Root118Item3151Item21Item {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root118Item3151Item21Item {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 4279862841 { return Err(DeError::custom("Root118Item3151Item21Item: integer below minimum")); }
        if x > 4294949673 { return Err(DeError::custom("Root118Item3151Item21Item: integer above maximum")); }
        
        Ok(Root118Item3151Item21Item(x))
    }
}
/// tuple len=2 (required first 2 slots)
#[derive(Debug, Deserialize)]
pub struct Root118Item3151Item2(
    pub Null,
    pub Vec<Root118Item3151Item21Item>,
);

/// tuple len=3 (required first 3 slots)
#[derive(Debug, Deserialize)]
pub struct Root118Item3151Item(
    pub Root118Item3151Item0,
    pub Root118Item3151Item1,
    pub Root118Item3151Item2,
);

/// tuple len=2 (required first 2 slots)
#[derive(Debug, Deserialize)]
pub struct Root118Item315(
    pub String,
    pub Vec<Root118Item3151Item>,
);

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum Root118Item3180 {
    Closed,
    Open,
}
impl<'de> Deserialize<'de> for Root118Item3180 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let s = String::deserialize(de)?;
        match s.as_str() {
            "Closed" => Ok(Root118Item3180::Closed),
            "Open" => Ok(Root118Item3180::Open),
            _ => Err(DeError::unknown_variant(&s, &[])),
        }
    }
}
impl serde::Serialize for Root118Item3180 {
    fn serialize<S>(&self, ser: S) -> Result<S::Ok, S::Error> where S: serde::Serializer {
        match self {
            Root118Item3180::Closed => ser.serialize_str("Closed"),
            Root118Item3180::Open => ser.serialize_str("Open"),
        }
    }
}

#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root118Item3181Item0(pub i64);
impl std::ops::Deref for Root118Item3181Item0 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root118Item3181Item0 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 0 { return Err(DeError::custom("Root118Item3181Item0: integer below minimum")); }
        if x > 0 { return Err(DeError::custom("Root118Item3181Item0: integer above maximum")); }
        
        Ok(Root118Item3181Item0(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root118Item3181Item1(pub i64);
impl std::ops::Deref for Root118Item3181Item1 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root118Item3181Item1 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 4 { return Err(DeError::custom("Root118Item3181Item1: integer below minimum")); }
        if x > 6 { return Err(DeError::custom("Root118Item3181Item1: integer above maximum")); }
        
        Ok(Root118Item3181Item1(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root118Item3181Item21Item(pub i64);
impl std::ops::Deref for Root118Item3181Item21Item {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root118Item3181Item21Item {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 4279862841 { return Err(DeError::custom("Root118Item3181Item21Item: integer below minimum")); }
        if x > 4294097077 { return Err(DeError::custom("Root118Item3181Item21Item: integer above maximum")); }
        
        Ok(Root118Item3181Item21Item(x))
    }
}
/// tuple len=2 (required first 2 slots)
#[derive(Debug, Deserialize)]
pub struct Root118Item3181Item2(
    pub Null,
    pub Vec<Root118Item3181Item21Item>,
);

/// tuple len=3 (required first 3 slots)
#[derive(Debug, Deserialize)]
pub struct Root118Item3181Item(
    pub Root118Item3181Item0,
    pub Root118Item3181Item1,
    pub Root118Item3181Item2,
);

/// tuple len=2 (required first 2 slots)
#[derive(Debug, Deserialize)]
pub struct Root118Item318(
    pub Root118Item3180,
    pub Vec<Root118Item3181Item>,
);

/// tuple len=9 (required first 9 slots)
#[derive(Debug, Deserialize)]
pub struct Root118Item31(
    pub Root118Item310,
    pub Option<Root118Item311>,
    pub Root118Item312,
    pub Null,
    pub Root118Item314,
    pub Root118Item315,
    pub Null,
    pub Null,
    pub Root118Item318,
);

#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root118Item32(pub i64);
impl std::ops::Deref for Root118Item32 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root118Item32 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 5 { return Err(DeError::custom("Root118Item32: integer below minimum")); }
        if x > 5 { return Err(DeError::custom("Root118Item32: integer above maximum")); }
        
        Ok(Root118Item32(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root118Item36(pub i64);
impl std::ops::Deref for Root118Item36 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root118Item36 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 1 { return Err(DeError::custom("Root118Item36: integer below minimum")); }
        if x > 1 { return Err(DeError::custom("Root118Item36: integer above maximum")); }
        
        Ok(Root118Item36(x))
    }
}
/// tuple len=7 (required first 7 slots)
#[derive(Debug, Deserialize)]
pub struct Root118Item3(
    pub Vec<Root118Item30Item>,
    pub Root118Item31,
    pub Root118Item32,
    pub Null,
    pub Null,
    pub Null,
    pub Root118Item36,
);

/// tuple len=4 (required first 4 slots)
#[derive(Debug, Deserialize)]
pub struct Root118Item(
    pub String,
    pub Null,
    pub Null,
    pub Root118Item3,
);

#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root1190(pub i64);
impl std::ops::Deref for Root1190 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root1190 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 1 { return Err(DeError::custom("Root1190: integer below minimum")); }
        if x > 1 { return Err(DeError::custom("Root1190: integer above maximum")); }
        
        Ok(Root1190(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub struct Root11912(pub f64);
impl std::ops::Deref for Root11912 {
    type Target = f64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root11912 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = f64::deserialize(de)?;
        if !x.is_finite() { return Err(DeError::custom("Root11912: non-finite number")); }
        if x < 37.660883699999999 { return Err(DeError::custom("Root11912: number below minimum")); }
        if x > 37.660883699999999 { return Err(DeError::custom("Root11912: number above maximum")); }
        
        Ok(Root11912(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub struct Root11913(pub f64);
impl std::ops::Deref for Root11913 {
    type Target = f64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root11913 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = f64::deserialize(de)?;
        if !x.is_finite() { return Err(DeError::custom("Root11913: non-finite number")); }
        if x < -113.068060299999999 { return Err(DeError::custom("Root11913: number below minimum")); }
        if x > -113.068060299999999 { return Err(DeError::custom("Root11913: number above maximum")); }
        
        Ok(Root11913(x))
    }
}
/// tuple len=4 (required first 4 slots)
#[derive(Debug, Deserialize)]
pub struct Root1191(
    pub Null,
    pub Null,
    pub Root11912,
    pub Root11913,
);

/// tuple len=2 (required first 2 slots)
#[derive(Debug, Deserialize)]
pub struct Root119(
    pub Root1190,
    pub Root1191,
);

/// tuple len=2 (required first 1 slots)
#[derive(Debug, Deserialize)]
pub struct Root125ItemItem1ItemItemItemAlt1ItemItem(
    pub String,
    pub Option<String>,
);

#[derive(Debug)]
pub enum Root125ItemItem1ItemItemItem {
    V0(String),
    V1(Vec<Vec<Root125ItemItem1ItemItemItemAlt1ItemItem>>),
}

impl<'de> Deserialize<'de> for Root125ItemItem1ItemItemItem {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        // deserialize into a serde_json::Value once, then attempt each arm (strict)
        let val = serde_json::Value::deserialize(de)?;
        if let Ok(x) = <String as serde::Deserialize>::deserialize(val.clone()) { return Ok(Root125ItemItem1ItemItemItem::V0(x)); }
        if let Ok(x) = <Vec<Vec<Root125ItemItem1ItemItemItemAlt1ItemItem>> as serde::Deserialize>::deserialize(val.clone()) { return Ok(Root125ItemItem1ItemItemItem::V1(x)); }
        Err(DeError::custom("no union arm matched"))
    }
}

#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root125ItemItem4(pub i64);
impl std::ops::Deref for Root125ItemItem4 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root125ItemItem4 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 4 { return Err(DeError::custom("Root125ItemItem4: integer below minimum")); }
        if x > 4 { return Err(DeError::custom("Root125ItemItem4: integer above maximum")); }
        
        Ok(Root125ItemItem4(x))
    }
}
/// tuple len=5 (required first 5 slots)
#[derive(Debug, Deserialize)]
pub struct Root125ItemItem(
    pub Null,
    pub Vec<Vec<Vec<Root125ItemItem1ItemItemItem>>>,
    pub Null,
    pub Null,
    pub Root125ItemItem4,
);

#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root130(pub i64);
impl std::ops::Deref for Root130 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root130 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 0 { return Err(DeError::custom("Root130: integer below minimum")); }
        if x > 0 { return Err(DeError::custom("Root130: integer above maximum")); }
        
        Ok(Root130(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct Root134Item0Item1(pub String);
impl std::ops::Deref for Root134Item0Item1 {
    type Target = String;
    fn deref(&self) -> &Self::Target { &self.0 }
}
static RE_ROOT134ITEM0ITEM1: Lazy<Regex> = Lazy::new(|| Regex::new("^0x87.*").unwrap());
impl<'de> Deserialize<'de> for Root134Item0Item1 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let s = String::deserialize(de)?;
        if !RE_ROOT134ITEM0ITEM1.is_match(&s) {
            return Err(DeError::custom("Root134Item0Item1: string failed pattern"));
        }
        Ok(Root134Item0Item1(s))
    }
}
/// tuple len=6 (required first 6 slots)
#[derive(Debug, Deserialize)]
pub struct Root134Item0Item(
    pub String,
    pub Root134Item0Item1,
    pub Null,
    pub Null,
    pub Null,
    pub String,
);

#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root134Item1(pub i64);
impl std::ops::Deref for Root134Item1 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root134Item1 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 2 { return Err(DeError::custom("Root134Item1: integer below minimum")); }
        if x > 2 { return Err(DeError::custom("Root134Item1: integer above maximum")); }
        
        Ok(Root134Item1(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root134Item2(pub i64);
impl std::ops::Deref for Root134Item2 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root134Item2 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 4 { return Err(DeError::custom("Root134Item2: integer below minimum")); }
        if x > 4 { return Err(DeError::custom("Root134Item2: integer above maximum")); }
        
        Ok(Root134Item2(x))
    }
}
/// tuple len=3 (required first 3 slots)
#[derive(Debug, Deserialize)]
pub struct Root134Item(
    pub Vec<Root134Item0Item>,
    pub Root134Item1,
    pub Root134Item2,
);

#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root136(pub i64);
impl std::ops::Deref for Root136 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root136 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 1 { return Err(DeError::custom("Root136: integer below minimum")); }
        if x > 1 { return Err(DeError::custom("Root136: integer above maximum")); }
        
        Ok(Root136(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root1421Item101Item0(pub i64);
impl std::ops::Deref for Root1421Item101Item0 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root1421Item101Item0 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 1 { return Err(DeError::custom("Root1421Item101Item0: integer below minimum")); }
        if x > 67 { return Err(DeError::custom("Root1421Item101Item0: integer above maximum")); }
        
        Ok(Root1421Item101Item0(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root1421Item101Item1(pub i64);
impl std::ops::Deref for Root1421Item101Item1 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root1421Item101Item1 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 5 { return Err(DeError::custom("Root1421Item101Item1: integer below minimum")); }
        if x > 72 { return Err(DeError::custom("Root1421Item101Item1: integer above maximum")); }
        
        Ok(Root1421Item101Item1(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root1421Item101Item2Item0(pub i64);
impl std::ops::Deref for Root1421Item101Item2Item0 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root1421Item101Item2Item0 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 5 { return Err(DeError::custom("Root1421Item101Item2Item0: integer below minimum")); }
        if x > 5 { return Err(DeError::custom("Root1421Item101Item2Item0: integer above maximum")); }
        
        Ok(Root1421Item101Item2Item0(x))
    }
}
/// tuple len=1 (required first 1 slots)
#[derive(Debug, Deserialize)]
pub struct Root1421Item101Item2Item(
    pub Root1421Item101Item2Item0,
);

/// tuple len=3 (required first 3 slots)
#[derive(Debug, Deserialize)]
pub struct Root1421Item101Item(
    pub Root1421Item101Item0,
    pub Root1421Item101Item1,
    pub Vec<Root1421Item101Item2Item>,
);

/// tuple len=2 (required first 1 slots)
#[derive(Debug, Deserialize)]
pub struct Root1421Item10(
    pub String,
    pub Option<Vec<Root1421Item101Item>>,
);

#[repr(transparent)]
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct Root1421Item12(pub String);
impl std::ops::Deref for Root1421Item12 {
    type Target = String;
    fn deref(&self) -> &Self::Target { &self.0 }
}
static RE_ROOT1421ITEM12: Lazy<Regex> = Lazy::new(|| Regex::new("^https://.*").unwrap());
impl<'de> Deserialize<'de> for Root1421Item12 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let s = String::deserialize(de)?;
        if !RE_ROOT1421ITEM12.is_match(&s) {
            return Err(DeError::custom("Root1421Item12: string failed pattern"));
        }
        Ok(Root1421Item12(s))
    }
}
/// tuple len=3 (required first 3 slots)
#[derive(Debug, Deserialize)]
pub struct Root1421Item1(
    pub Root1421Item10,
    pub Null,
    pub Root1421Item12,
);

#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root1421Item3(pub i64);
impl std::ops::Deref for Root1421Item3 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root1421Item3 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 71446 { return Err(DeError::custom("Root1421Item3: integer below minimum")); }
        if x > 210379 { return Err(DeError::custom("Root1421Item3: integer above maximum")); }
        
        Ok(Root1421Item3(x))
    }
}
/// tuple len=5 (required first 5 slots)
#[derive(Debug, Deserialize)]
pub struct Root1421Item6ItemItem(
    pub Vec<String>,
    pub Null,
    pub Null,
    pub Null,
    pub String,
);

#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root1421Item9(pub i64);
impl std::ops::Deref for Root1421Item9 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root1421Item9 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 1 { return Err(DeError::custom("Root1421Item9: integer below minimum")); }
        if x > 1 { return Err(DeError::custom("Root1421Item9: integer above maximum")); }
        
        Ok(Root1421Item9(x))
    }
}
/// tuple len=13 (required first 13 slots)
#[derive(Debug, Deserialize)]
pub struct Root1421Item(
    pub Null,
    pub Option<Root1421Item1>,
    pub Null,
    pub Root1421Item3,
    pub Null,
    pub Null,
    pub Option<Vec<Vec<Root1421Item6ItemItem>>>,
    pub Null,
    pub Null,
    pub Option<Root1421Item9>,
    pub Option<String>,
    pub Null,
    pub String,
);

/// tuple len=2 (required first 2 slots)
#[derive(Debug, Deserialize)]
pub struct Root142(
    pub Null,
    pub Vec<Root1421Item>,
);

#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root146Item(pub i64);
impl std::ops::Deref for Root146Item {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root146Item {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 0 { return Err(DeError::custom("Root146Item: integer below minimum")); }
        if x > 10 { return Err(DeError::custom("Root146Item: integer above maximum")); }
        
        Ok(Root146Item(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct Root157(pub String);
impl std::ops::Deref for Root157 {
    type Target = String;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root157 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let s = String::deserialize(de)?;
        if !(s.starts_with("http://") || s.starts_with("https://") || s.starts_with("mailto:") || s.starts_with("tel:")) {
            return Err(DeError::custom("Root157: expected URI scheme"));
        }
        Ok(Root157(s))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root1600(pub i64);
impl std::ops::Deref for Root1600 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root1600 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 1 { return Err(DeError::custom("Root1600: integer below minimum")); }
        if x > 1 { return Err(DeError::custom("Root1600: integer above maximum")); }
        
        Ok(Root1600(x))
    }
}
/// tuple len=1 (required first 1 slots)
#[derive(Debug, Deserialize)]
pub struct Root160(
    pub Root1600,
);

#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub struct Root161ItemItemItem(pub f64);
impl std::ops::Deref for Root161ItemItemItem {
    type Target = f64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root161ItemItemItem {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = f64::deserialize(de)?;
        if !x.is_finite() { return Err(DeError::custom("Root161ItemItemItem: non-finite number")); }
        if x < 0.0 { return Err(DeError::custom("Root161ItemItemItem: number below minimum")); }
        if x > 4.0 { return Err(DeError::custom("Root161ItemItemItem: number above maximum")); }
        
        Ok(Root161ItemItemItem(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root16400(pub i64);
impl std::ops::Deref for Root16400 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root16400 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 0 { return Err(DeError::custom("Root16400: integer below minimum")); }
        if x > 29 { return Err(DeError::custom("Root16400: integer above maximum")); }
        
        Ok(Root16400(x))
    }
}
/// tuple len=2 (required first 2 slots)
#[derive(Debug, Deserialize)]
pub struct Root1640(
    pub Root16400,
    pub String,
);

#[repr(transparent)]
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct Root1641(pub String);
impl std::ops::Deref for Root1641 {
    type Target = String;
    fn deref(&self) -> &Self::Target { &self.0 }
}
static RE_ROOT1641: Lazy<Regex> = Lazy::new(|| Regex::new("^See .*").unwrap());
impl<'de> Deserialize<'de> for Root1641 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let s = String::deserialize(de)?;
        if !RE_ROOT1641.is_match(&s) {
            return Err(DeError::custom("Root1641: string failed pattern"));
        }
        Ok(Root1641(s))
    }
}
/// tuple len=2 (required first 2 slots)
#[derive(Debug, Deserialize)]
pub struct Root164(
    pub Root1640,
    pub Root1641,
);

#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root165Item(pub i64);
impl std::ops::Deref for Root165Item {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root165Item {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 0 { return Err(DeError::custom("Root165Item: integer below minimum")); }
        if x > 1 { return Err(DeError::custom("Root165Item: integer above maximum")); }
        
        Ok(Root165Item(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root170(pub i64);
impl std::ops::Deref for Root170 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root170 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 1 { return Err(DeError::custom("Root170: integer below minimum")); }
        if x > 1 { return Err(DeError::custom("Root170: integer above maximum")); }
        
        Ok(Root170(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct Root174Item(pub String);
impl std::ops::Deref for Root174Item {
    type Target = String;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root174Item {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let s = String::deserialize(de)?;
        if !(s.starts_with("http://") || s.starts_with("https://") || s.starts_with("mailto:") || s.starts_with("tel:")) {
            return Err(DeError::custom("Root174Item: expected URI scheme"));
        }
        Ok(Root174Item(s))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root178Item1Item1(pub i64);
impl std::ops::Deref for Root178Item1Item1 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root178Item1Item1 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 1 { return Err(DeError::custom("Root178Item1Item1: integer below minimum")); }
        if x > 2 { return Err(DeError::custom("Root178Item1Item1: integer above maximum")); }
        
        Ok(Root178Item1Item1(x))
    }
}
/// tuple len=2 (required first 2 slots)
#[derive(Debug, Deserialize)]
pub struct Root178Item1Item(
    pub String,
    pub Root178Item1Item1,
);

#[repr(transparent)]
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct Root178Item50(pub String);
impl std::ops::Deref for Root178Item50 {
    type Target = String;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root178Item50 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let s = String::deserialize(de)?;
        if !(s.starts_with("http://") || s.starts_with("https://") || s.starts_with("mailto:") || s.starts_with("tel:")) {
            return Err(DeError::custom("Root178Item50: expected URI scheme"));
        }
        Ok(Root178Item50(s))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct Root178Item53(pub String);
impl std::ops::Deref for Root178Item53 {
    type Target = String;
    fn deref(&self) -> &Self::Target { &self.0 }
}
static RE_ROOT178ITEM53: Lazy<Regex> = Lazy::new(|| Regex::new("^0ahUKEw.*").unwrap());
impl<'de> Deserialize<'de> for Root178Item53 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let s = String::deserialize(de)?;
        if !RE_ROOT178ITEM53.is_match(&s) {
            return Err(DeError::custom("Root178Item53: string failed pattern"));
        }
        Ok(Root178Item53(s))
    }
}
/// tuple len=4 (required first 4 slots)
#[derive(Debug, Deserialize)]
pub struct Root178Item5(
    pub Root178Item50,
    pub Null,
    pub Null,
    pub Root178Item53,
);

/// tuple len=6 (required first 6 slots)
#[derive(Debug, Deserialize)]
pub struct Root178Item(
    pub String,
    pub Vec<Root178Item1Item>,
    pub Null,
    pub String,
    pub Null,
    pub Root178Item5,
);

/// tuple len=7 (required first 7 slots)
#[derive(Debug, Deserialize)]
pub struct Root181(
    pub Null,
    pub Null,
    pub Null,
    pub Null,
    pub Null,
    pub String,
    pub String,
);

#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root183Item0Alt10(pub i64);
impl std::ops::Deref for Root183Item0Alt10 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root183Item0Alt10 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 7 { return Err(DeError::custom("Root183Item0Alt10: integer below minimum")); }
        if x > 7 { return Err(DeError::custom("Root183Item0Alt10: integer above maximum")); }
        
        Ok(Root183Item0Alt10(x))
    }
}
/// tuple len=5 (required first 2 slots)
#[derive(Debug, Deserialize)]
pub struct Root183Item0Alt11(
    pub Vec<String>,
    pub Vec<String>,
    pub Option<Vec<String>>,
    pub Option<Vec<String>>,
    pub Option<Vec<String>>,
);

/// tuple len=2 (required first 2 slots)
#[derive(Debug, Deserialize)]
pub struct Root183Item0Alt1(
    pub Root183Item0Alt10,
    pub Root183Item0Alt11,
);

#[derive(Debug)]
pub enum Root183Item0 {
    V0(String),
    V1(Root183Item0Alt1),
}

impl<'de> Deserialize<'de> for Root183Item0 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        // deserialize into a serde_json::Value once, then attempt each arm (strict)
        let val = serde_json::Value::deserialize(de)?;
        if let Ok(x) = <String as serde::Deserialize>::deserialize(val.clone()) { return Ok(Root183Item0::V0(x)); }
        if let Ok(x) = <Root183Item0Alt1 as serde::Deserialize>::deserialize(val.clone()) { return Ok(Root183Item0::V1(x)); }
        Err(DeError::custom("no union arm matched"))
    }
}

#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root183Item1Alt10(pub i64);
impl std::ops::Deref for Root183Item1Alt10 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root183Item1Alt10 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 2 { return Err(DeError::custom("Root183Item1Alt10: integer below minimum")); }
        if x > 2 { return Err(DeError::custom("Root183Item1Alt10: integer above maximum")); }
        
        Ok(Root183Item1Alt10(x))
    }
}
/// tuple len=2 (required first 2 slots)
#[derive(Debug, Deserialize)]
pub struct Root183Item1Alt1(
    pub Root183Item1Alt10,
    pub Vec<Vec<String>>,
);

#[derive(Debug)]
pub enum Root183Item1 {
    V0(String),
    V1(Root183Item1Alt1),
}

impl<'de> Deserialize<'de> for Root183Item1 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        // deserialize into a serde_json::Value once, then attempt each arm (strict)
        let val = serde_json::Value::deserialize(de)?;
        if let Ok(x) = <String as serde::Deserialize>::deserialize(val.clone()) { return Ok(Root183Item1::V0(x)); }
        if let Ok(x) = <Root183Item1Alt1 as serde::Deserialize>::deserialize(val.clone()) { return Ok(Root183Item1::V1(x)); }
        Err(DeError::custom("no union arm matched"))
    }
}

#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root183Item2Alt10(pub i64);
impl std::ops::Deref for Root183Item2Alt10 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root183Item2Alt10 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 1 { return Err(DeError::custom("Root183Item2Alt10: integer below minimum")); }
        if x > 1 { return Err(DeError::custom("Root183Item2Alt10: integer above maximum")); }
        
        Ok(Root183Item2Alt10(x))
    }
}
/// tuple len=2 (required first 2 slots)
#[derive(Debug, Deserialize)]
pub struct Root183Item2Alt1(
    pub Root183Item2Alt10,
    pub Vec<Vec<String>>,
);

#[derive(Debug)]
pub enum Root183Item2 {
    V0(String),
    V1(Root183Item2Alt1),
}

impl<'de> Deserialize<'de> for Root183Item2 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        // deserialize into a serde_json::Value once, then attempt each arm (strict)
        let val = serde_json::Value::deserialize(de)?;
        if let Ok(x) = <String as serde::Deserialize>::deserialize(val.clone()) { return Ok(Root183Item2::V0(x)); }
        if let Ok(x) = <Root183Item2Alt1 as serde::Deserialize>::deserialize(val.clone()) { return Ok(Root183Item2::V1(x)); }
        Err(DeError::custom("no union arm matched"))
    }
}

#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root183Item3Alt10(pub i64);
impl std::ops::Deref for Root183Item3Alt10 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root183Item3Alt10 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 4 { return Err(DeError::custom("Root183Item3Alt10: integer below minimum")); }
        if x > 4 { return Err(DeError::custom("Root183Item3Alt10: integer above maximum")); }
        
        Ok(Root183Item3Alt10(x))
    }
}
/// tuple len=2 (required first 2 slots)
#[derive(Debug, Deserialize)]
pub struct Root183Item3Alt1(
    pub Root183Item3Alt10,
    pub Vec<Vec<String>>,
);

#[derive(Debug)]
pub enum Root183Item3 {
    V0(String),
    V1(Root183Item3Alt1),
}

impl<'de> Deserialize<'de> for Root183Item3 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        // deserialize into a serde_json::Value once, then attempt each arm (strict)
        let val = serde_json::Value::deserialize(de)?;
        if let Ok(x) = <String as serde::Deserialize>::deserialize(val.clone()) { return Ok(Root183Item3::V0(x)); }
        if let Ok(x) = <Root183Item3Alt1 as serde::Deserialize>::deserialize(val.clone()) { return Ok(Root183Item3::V1(x)); }
        Err(DeError::custom("no union arm matched"))
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum Root183Item6 {
    US,
}
impl<'de> Deserialize<'de> for Root183Item6 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let s = String::deserialize(de)?;
        match s.as_str() {
            "US" => Ok(Root183Item6::US),
            _ => Err(DeError::unknown_variant(&s, &[])),
        }
    }
}
impl serde::Serialize for Root183Item6 {
    fn serialize<S>(&self, ser: S) -> Result<S::Ok, S::Error> where S: serde::Serializer {
        match self {
            Root183Item6::US => ser.serialize_str("US"),
        }
    }
}

/// tuple len=7 (required first 0 slots)
#[derive(Debug, Deserialize)]
pub struct Root183Item(
    pub Option<Root183Item0>,
    pub Option<Root183Item1>,
    pub Option<Root183Item2>,
    pub Option<Root183Item3>,
    pub Option<String>,
    pub Option<String>,
    pub Option<Root183Item6>,
);

#[repr(transparent)]
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct Root1961Item0(pub String);
impl std::ops::Deref for Root1961Item0 {
    type Target = String;
    fn deref(&self) -> &Self::Target { &self.0 }
}
static RE_ROOT1961ITEM0: Lazy<Regex> = Lazy::new(|| Regex::new("^0ahUKEw.*").unwrap());
impl<'de> Deserialize<'de> for Root1961Item0 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let s = String::deserialize(de)?;
        if !RE_ROOT1961ITEM0.is_match(&s) {
            return Err(DeError::custom("Root1961Item0: string failed pattern"));
        }
        Ok(Root1961Item0(s))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct Root1961Item3(pub String);
impl std::ops::Deref for Root1961Item3 {
    type Target = String;
    fn deref(&self) -> &Self::Target { &self.0 }
}
static RE_ROOT1961ITEM3: Lazy<Regex> = Lazy::new(|| Regex::new("^https://gstatic\\.com/local/placeinfo/.*").unwrap());
impl<'de> Deserialize<'de> for Root1961Item3 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let s = String::deserialize(de)?;
        if !RE_ROOT1961ITEM3.is_match(&s) {
            return Err(DeError::custom("Root1961Item3: string failed pattern"));
        }
        Ok(Root1961Item3(s))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct Root1961Item4(pub String);
impl std::ops::Deref for Root1961Item4 {
    type Target = String;
    fn deref(&self) -> &Self::Target { &self.0 }
}
static RE_ROOT1961ITEM4: Lazy<Regex> = Lazy::new(|| Regex::new("^https://gstatic\\.com/local/placeinfo/.*").unwrap());
impl<'de> Deserialize<'de> for Root1961Item4 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let s = String::deserialize(de)?;
        if !RE_ROOT1961ITEM4.is_match(&s) {
            return Err(DeError::custom("Root1961Item4: string failed pattern"));
        }
        Ok(Root1961Item4(s))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct Root1961Item10ItemItem(pub String);
impl std::ops::Deref for Root1961Item10ItemItem {
    type Target = String;
    fn deref(&self) -> &Self::Target { &self.0 }
}
static RE_ROOT1961ITEM10ITEMITEM: Lazy<Regex> = Lazy::new(|| Regex::new("^Check-out time: 11:00\u{202f}AM.*").unwrap());
impl<'de> Deserialize<'de> for Root1961Item10ItemItem {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let s = String::deserialize(de)?;
        if !RE_ROOT1961ITEM10ITEMITEM.is_match(&s) {
            return Err(DeError::custom("Root1961Item10ItemItem: string failed pattern"));
        }
        Ok(Root1961Item10ItemItem(s))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root1961Item11(pub i64);
impl std::ops::Deref for Root1961Item11 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root1961Item11 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 1 { return Err(DeError::custom("Root1961Item11: integer below minimum")); }
        if x > 1 { return Err(DeError::custom("Root1961Item11: integer above maximum")); }
        
        Ok(Root1961Item11(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct Root1961Item12(pub String);
impl std::ops::Deref for Root1961Item12 {
    type Target = String;
    fn deref(&self) -> &Self::Target { &self.0 }
}
static RE_ROOT1961ITEM12: Lazy<Regex> = Lazy::new(|| Regex::new("^\u{e8b5}.*").unwrap());
impl<'de> Deserialize<'de> for Root1961Item12 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let s = String::deserialize(de)?;
        if !RE_ROOT1961ITEM12.is_match(&s) {
            return Err(DeError::custom("Root1961Item12: string failed pattern"));
        }
        Ok(Root1961Item12(s))
    }
}
/// tuple len=13 (required first 10 slots)
#[derive(Debug, Deserialize)]
pub struct Root1961Item(
    pub Root1961Item0,
    pub Vec<String>,
    pub Null,
    pub Root1961Item3,
    pub Root1961Item4,
    pub Null,
    pub Null,
    pub Null,
    pub Null,
    pub Null,
    pub Option<Vec<Vec<Root1961Item10ItemItem>>>,
    pub Option<Root1961Item11>,
    pub Option<Root1961Item12>,
);

#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root1963Item0(pub i64);
impl std::ops::Deref for Root1963Item0 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root1963Item0 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 4 { return Err(DeError::custom("Root1963Item0: integer below minimum")); }
        if x > 30 { return Err(DeError::custom("Root1963Item0: integer above maximum")); }
        
        Ok(Root1963Item0(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct Root1963Item10(pub String);
impl std::ops::Deref for Root1963Item10 {
    type Target = String;
    fn deref(&self) -> &Self::Target { &self.0 }
}
static RE_ROOT1963ITEM10: Lazy<Regex> = Lazy::new(|| Regex::new("^0ahUKEw.*").unwrap());
impl<'de> Deserialize<'de> for Root1963Item10 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let s = String::deserialize(de)?;
        if !RE_ROOT1963ITEM10.is_match(&s) {
            return Err(DeError::custom("Root1963Item10: string failed pattern"));
        }
        Ok(Root1963Item10(s))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct Root1963Item13(pub String);
impl std::ops::Deref for Root1963Item13 {
    type Target = String;
    fn deref(&self) -> &Self::Target { &self.0 }
}
static RE_ROOT1963ITEM13: Lazy<Regex> = Lazy::new(|| Regex::new("^https://gstatic\\.com/local/placeinfo/.*").unwrap());
impl<'de> Deserialize<'de> for Root1963Item13 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let s = String::deserialize(de)?;
        if !RE_ROOT1963ITEM13.is_match(&s) {
            return Err(DeError::custom("Root1963Item13: string failed pattern"));
        }
        Ok(Root1963Item13(s))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct Root1963Item14(pub String);
impl std::ops::Deref for Root1963Item14 {
    type Target = String;
    fn deref(&self) -> &Self::Target { &self.0 }
}
static RE_ROOT1963ITEM14: Lazy<Regex> = Lazy::new(|| Regex::new("^https://gstatic\\.com/local/placeinfo/.*").unwrap());
impl<'de> Deserialize<'de> for Root1963Item14 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let s = String::deserialize(de)?;
        if !RE_ROOT1963ITEM14.is_match(&s) {
            return Err(DeError::custom("Root1963Item14: string failed pattern"));
        }
        Ok(Root1963Item14(s))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct Root1963Item110ItemItem(pub String);
impl std::ops::Deref for Root1963Item110ItemItem {
    type Target = String;
    fn deref(&self) -> &Self::Target { &self.0 }
}
static RE_ROOT1963ITEM110ITEMITEM: Lazy<Regex> = Lazy::new(|| Regex::new("^Check-out time: 11:00\u{202f}AM.*").unwrap());
impl<'de> Deserialize<'de> for Root1963Item110ItemItem {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let s = String::deserialize(de)?;
        if !RE_ROOT1963ITEM110ITEMITEM.is_match(&s) {
            return Err(DeError::custom("Root1963Item110ItemItem: string failed pattern"));
        }
        Ok(Root1963Item110ItemItem(s))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root1963Item111(pub i64);
impl std::ops::Deref for Root1963Item111 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root1963Item111 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 1 { return Err(DeError::custom("Root1963Item111: integer below minimum")); }
        if x > 1 { return Err(DeError::custom("Root1963Item111: integer above maximum")); }
        
        Ok(Root1963Item111(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct Root1963Item112(pub String);
impl std::ops::Deref for Root1963Item112 {
    type Target = String;
    fn deref(&self) -> &Self::Target { &self.0 }
}
static RE_ROOT1963ITEM112: Lazy<Regex> = Lazy::new(|| Regex::new("^\u{e8b5}.*").unwrap());
impl<'de> Deserialize<'de> for Root1963Item112 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let s = String::deserialize(de)?;
        if !RE_ROOT1963ITEM112.is_match(&s) {
            return Err(DeError::custom("Root1963Item112: string failed pattern"));
        }
        Ok(Root1963Item112(s))
    }
}
/// tuple len=13 (required first 10 slots)
#[derive(Debug, Deserialize)]
pub struct Root1963Item1(
    pub Root1963Item10,
    pub Vec<String>,
    pub Null,
    pub Root1963Item13,
    pub Root1963Item14,
    pub Null,
    pub Null,
    pub Null,
    pub Null,
    pub Null,
    pub Option<Vec<Vec<Root1963Item110ItemItem>>>,
    pub Option<Root1963Item111>,
    pub Option<Root1963Item112>,
);

/// tuple len=2 (required first 2 slots)
#[derive(Debug, Deserialize)]
pub struct Root1963Item(
    pub Root1963Item0,
    pub Root1963Item1,
);

/// tuple len=4 (required first 4 slots)
#[derive(Debug, Deserialize)]
pub struct Root196(
    pub Null,
    pub Vec<Root1961Item>,
    pub Null,
    pub Vec<Root1963Item>,
);

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum Root2030Item0 {
    Friday,
    Monday,
    Saturday,
    Sunday,
    Thursday,
    Tuesday,
    Wednesday,
}
impl<'de> Deserialize<'de> for Root2030Item0 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let s = String::deserialize(de)?;
        match s.as_str() {
            "Friday" => Ok(Root2030Item0::Friday),
            "Monday" => Ok(Root2030Item0::Monday),
            "Saturday" => Ok(Root2030Item0::Saturday),
            "Sunday" => Ok(Root2030Item0::Sunday),
            "Thursday" => Ok(Root2030Item0::Thursday),
            "Tuesday" => Ok(Root2030Item0::Tuesday),
            "Wednesday" => Ok(Root2030Item0::Wednesday),
            _ => Err(DeError::unknown_variant(&s, &[])),
        }
    }
}
impl serde::Serialize for Root2030Item0 {
    fn serialize<S>(&self, ser: S) -> Result<S::Ok, S::Error> where S: serde::Serializer {
        match self {
            Root2030Item0::Friday => ser.serialize_str("Friday"),
            Root2030Item0::Monday => ser.serialize_str("Monday"),
            Root2030Item0::Saturday => ser.serialize_str("Saturday"),
            Root2030Item0::Sunday => ser.serialize_str("Sunday"),
            Root2030Item0::Thursday => ser.serialize_str("Thursday"),
            Root2030Item0::Tuesday => ser.serialize_str("Tuesday"),
            Root2030Item0::Wednesday => ser.serialize_str("Wednesday"),
        }
    }
}

#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root2030Item1(pub i64);
impl std::ops::Deref for Root2030Item1 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root2030Item1 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 1 { return Err(DeError::custom("Root2030Item1: integer below minimum")); }
        if x > 7 { return Err(DeError::custom("Root2030Item1: integer above maximum")); }
        
        Ok(Root2030Item1(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root2030Item20(pub i64);
impl std::ops::Deref for Root2030Item20 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root2030Item20 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 2025 { return Err(DeError::custom("Root2030Item20: integer below minimum")); }
        if x > 2025 { return Err(DeError::custom("Root2030Item20: integer above maximum")); }
        
        Ok(Root2030Item20(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root2030Item21(pub i64);
impl std::ops::Deref for Root2030Item21 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root2030Item21 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 9 { return Err(DeError::custom("Root2030Item21: integer below minimum")); }
        if x > 9 { return Err(DeError::custom("Root2030Item21: integer above maximum")); }
        
        Ok(Root2030Item21(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root2030Item22(pub i64);
impl std::ops::Deref for Root2030Item22 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root2030Item22 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 5 { return Err(DeError::custom("Root2030Item22: integer below minimum")); }
        if x > 11 { return Err(DeError::custom("Root2030Item22: integer above maximum")); }
        
        Ok(Root2030Item22(x))
    }
}
/// tuple len=3 (required first 3 slots)
#[derive(Debug, Deserialize)]
pub struct Root2030Item2(
    pub Root2030Item20,
    pub Root2030Item21,
    pub Root2030Item22,
);

#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root2030Item3Item1Item0(pub i64);
impl std::ops::Deref for Root2030Item3Item1Item0 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root2030Item3Item1Item0 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 5 { return Err(DeError::custom("Root2030Item3Item1Item0: integer below minimum")); }
        if x > 23 { return Err(DeError::custom("Root2030Item3Item1Item0: integer above maximum")); }
        
        Ok(Root2030Item3Item1Item0(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root2030Item3Item1Item1(pub i64);
impl std::ops::Deref for Root2030Item3Item1Item1 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root2030Item3Item1Item1 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 30 { return Err(DeError::custom("Root2030Item3Item1Item1: integer below minimum")); }
        if x > 59 { return Err(DeError::custom("Root2030Item3Item1Item1: integer above maximum")); }
        
        Ok(Root2030Item3Item1Item1(x))
    }
}
/// tuple len=2 (required first 0 slots)
#[derive(Debug, Deserialize)]
pub struct Root2030Item3Item1Item(
    pub Option<Root2030Item3Item1Item0>,
    pub Option<Root2030Item3Item1Item1>,
);

/// tuple len=2 (required first 1 slots)
#[derive(Debug, Deserialize)]
pub struct Root2030Item3Item(
    pub String,
    pub Option<Vec<Root2030Item3Item1Item>>,
);

#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root2030Item4(pub i64);
impl std::ops::Deref for Root2030Item4 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root2030Item4 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 0 { return Err(DeError::custom("Root2030Item4: integer below minimum")); }
        if x > 1 { return Err(DeError::custom("Root2030Item4: integer above maximum")); }
        
        Ok(Root2030Item4(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root2030Item5(pub i64);
impl std::ops::Deref for Root2030Item5 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root2030Item5 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 1 { return Err(DeError::custom("Root2030Item5: integer below minimum")); }
        if x > 2 { return Err(DeError::custom("Root2030Item5: integer above maximum")); }
        
        Ok(Root2030Item5(x))
    }
}
/// tuple len=6 (required first 6 slots)
#[derive(Debug, Deserialize)]
pub struct Root2030Item(
    pub Root2030Item0,
    pub Root2030Item1,
    pub Root2030Item2,
    pub Vec<Root2030Item3Item>,
    pub Root2030Item4,
    pub Root2030Item5,
);

#[repr(transparent)]
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct Root203100(pub String);
impl std::ops::Deref for Root203100 {
    type Target = String;
    fn deref(&self) -> &Self::Target { &self.0 }
}
static RE_ROOT203100: Lazy<Regex> = Lazy::new(|| Regex::new("^Friday.*").unwrap());
impl<'de> Deserialize<'de> for Root203100 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let s = String::deserialize(de)?;
        if !RE_ROOT203100.is_match(&s) {
            return Err(DeError::custom("Root203100: string failed pattern"));
        }
        Ok(Root203100(s))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root203101(pub i64);
impl std::ops::Deref for Root203101 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root203101 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 5 { return Err(DeError::custom("Root203101: integer below minimum")); }
        if x > 5 { return Err(DeError::custom("Root203101: integer above maximum")); }
        
        Ok(Root203101(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root2031020(pub i64);
impl std::ops::Deref for Root2031020 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root2031020 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 2025 { return Err(DeError::custom("Root2031020: integer below minimum")); }
        if x > 2025 { return Err(DeError::custom("Root2031020: integer above maximum")); }
        
        Ok(Root2031020(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root2031021(pub i64);
impl std::ops::Deref for Root2031021 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root2031021 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 9 { return Err(DeError::custom("Root2031021: integer below minimum")); }
        if x > 9 { return Err(DeError::custom("Root2031021: integer above maximum")); }
        
        Ok(Root2031021(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root2031022(pub i64);
impl std::ops::Deref for Root2031022 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root2031022 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 5 { return Err(DeError::custom("Root2031022: integer below minimum")); }
        if x > 5 { return Err(DeError::custom("Root2031022: integer above maximum")); }
        
        Ok(Root2031022(x))
    }
}
/// tuple len=3 (required first 3 slots)
#[derive(Debug, Deserialize)]
pub struct Root203102(
    pub Root2031020,
    pub Root2031021,
    pub Root2031022,
);

#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root203103Item1Item0(pub i64);
impl std::ops::Deref for Root203103Item1Item0 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root203103Item1Item0 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 5 { return Err(DeError::custom("Root203103Item1Item0: integer below minimum")); }
        if x > 23 { return Err(DeError::custom("Root203103Item1Item0: integer above maximum")); }
        
        Ok(Root203103Item1Item0(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root203103Item1Item1(pub i64);
impl std::ops::Deref for Root203103Item1Item1 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root203103Item1Item1 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 30 { return Err(DeError::custom("Root203103Item1Item1: integer below minimum")); }
        if x > 59 { return Err(DeError::custom("Root203103Item1Item1: integer above maximum")); }
        
        Ok(Root203103Item1Item1(x))
    }
}
/// tuple len=2 (required first 0 slots)
#[derive(Debug, Deserialize)]
pub struct Root203103Item1Item(
    pub Option<Root203103Item1Item0>,
    pub Option<Root203103Item1Item1>,
);

/// tuple len=2 (required first 1 slots)
#[derive(Debug, Deserialize)]
pub struct Root203103Item(
    pub String,
    pub Option<Vec<Root203103Item1Item>>,
);

#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root203104(pub i64);
impl std::ops::Deref for Root203104 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root203104 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 0 { return Err(DeError::custom("Root203104: integer below minimum")); }
        if x > 0 { return Err(DeError::custom("Root203104: integer above maximum")); }
        
        Ok(Root203104(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root203105(pub i64);
impl std::ops::Deref for Root203105 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root203105 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 1 { return Err(DeError::custom("Root203105: integer below minimum")); }
        if x > 2 { return Err(DeError::custom("Root203105: integer above maximum")); }
        
        Ok(Root203105(x))
    }
}
/// tuple len=6 (required first 6 slots)
#[derive(Debug, Deserialize)]
pub struct Root20310(
    pub Root203100,
    pub Root203101,
    pub Root203102,
    pub Vec<Root203103Item>,
    pub Root203104,
    pub Root203105,
);

#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root20311(pub i64);
impl std::ops::Deref for Root20311 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root20311 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 0 { return Err(DeError::custom("Root20311: integer below minimum")); }
        if x > 1 { return Err(DeError::custom("Root20311: integer above maximum")); }
        
        Ok(Root20311(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root20312(pub i64);
impl std::ops::Deref for Root20312 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root20312 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 1 { return Err(DeError::custom("Root20312: integer below minimum")); }
        if x > 6 { return Err(DeError::custom("Root20312: integer above maximum")); }
        
        Ok(Root20312(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root203141Item0(pub i64);
impl std::ops::Deref for Root203141Item0 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root203141Item0 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 0 { return Err(DeError::custom("Root203141Item0: integer below minimum")); }
        if x > 0 { return Err(DeError::custom("Root203141Item0: integer above maximum")); }
        
        Ok(Root203141Item0(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root203141Item1(pub i64);
impl std::ops::Deref for Root203141Item1 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root203141Item1 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 4 { return Err(DeError::custom("Root203141Item1: integer below minimum")); }
        if x > 13 { return Err(DeError::custom("Root203141Item1: integer above maximum")); }
        
        Ok(Root203141Item1(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root203141Item21Item(pub i64);
impl std::ops::Deref for Root203141Item21Item {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root203141Item21Item {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 4279862841 { return Err(DeError::custom("Root203141Item21Item: integer below minimum")); }
        if x > 4294949673 { return Err(DeError::custom("Root203141Item21Item: integer above maximum")); }
        
        Ok(Root203141Item21Item(x))
    }
}
/// tuple len=2 (required first 2 slots)
#[derive(Debug, Deserialize)]
pub struct Root203141Item2(
    pub Null,
    pub Vec<Root203141Item21Item>,
);

/// tuple len=3 (required first 3 slots)
#[derive(Debug, Deserialize)]
pub struct Root203141Item(
    pub Root203141Item0,
    pub Root203141Item1,
    pub Root203141Item2,
);

/// tuple len=2 (required first 2 slots)
#[derive(Debug, Deserialize)]
pub struct Root20314(
    pub String,
    pub Vec<Root203141Item>,
);

#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root203151Item0(pub i64);
impl std::ops::Deref for Root203151Item0 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root203151Item0 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 0 { return Err(DeError::custom("Root203151Item0: integer below minimum")); }
        if x > 0 { return Err(DeError::custom("Root203151Item0: integer above maximum")); }
        
        Ok(Root203151Item0(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root203151Item1(pub i64);
impl std::ops::Deref for Root203151Item1 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root203151Item1 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 4 { return Err(DeError::custom("Root203151Item1: integer below minimum")); }
        if x > 13 { return Err(DeError::custom("Root203151Item1: integer above maximum")); }
        
        Ok(Root203151Item1(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root203151Item21Item(pub i64);
impl std::ops::Deref for Root203151Item21Item {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root203151Item21Item {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 4279862841 { return Err(DeError::custom("Root203151Item21Item: integer below minimum")); }
        if x > 4294949673 { return Err(DeError::custom("Root203151Item21Item: integer above maximum")); }
        
        Ok(Root203151Item21Item(x))
    }
}
/// tuple len=2 (required first 2 slots)
#[derive(Debug, Deserialize)]
pub struct Root203151Item2(
    pub Null,
    pub Vec<Root203151Item21Item>,
);

/// tuple len=3 (required first 3 slots)
#[derive(Debug, Deserialize)]
pub struct Root203151Item(
    pub Root203151Item0,
    pub Root203151Item1,
    pub Root203151Item2,
);

/// tuple len=2 (required first 2 slots)
#[derive(Debug, Deserialize)]
pub struct Root20315(
    pub String,
    pub Vec<Root203151Item>,
);

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum Root203180 {
    Closed,
    Open,
}
impl<'de> Deserialize<'de> for Root203180 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let s = String::deserialize(de)?;
        match s.as_str() {
            "Closed" => Ok(Root203180::Closed),
            "Open" => Ok(Root203180::Open),
            _ => Err(DeError::unknown_variant(&s, &[])),
        }
    }
}
impl serde::Serialize for Root203180 {
    fn serialize<S>(&self, ser: S) -> Result<S::Ok, S::Error> where S: serde::Serializer {
        match self {
            Root203180::Closed => ser.serialize_str("Closed"),
            Root203180::Open => ser.serialize_str("Open"),
        }
    }
}

#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root203181Item0(pub i64);
impl std::ops::Deref for Root203181Item0 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root203181Item0 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 0 { return Err(DeError::custom("Root203181Item0: integer below minimum")); }
        if x > 0 { return Err(DeError::custom("Root203181Item0: integer above maximum")); }
        
        Ok(Root203181Item0(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root203181Item1(pub i64);
impl std::ops::Deref for Root203181Item1 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root203181Item1 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 4 { return Err(DeError::custom("Root203181Item1: integer below minimum")); }
        if x > 6 { return Err(DeError::custom("Root203181Item1: integer above maximum")); }
        
        Ok(Root203181Item1(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root203181Item21Item(pub i64);
impl std::ops::Deref for Root203181Item21Item {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root203181Item21Item {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 4279862841 { return Err(DeError::custom("Root203181Item21Item: integer below minimum")); }
        if x > 4294097077 { return Err(DeError::custom("Root203181Item21Item: integer above maximum")); }
        
        Ok(Root203181Item21Item(x))
    }
}
/// tuple len=2 (required first 2 slots)
#[derive(Debug, Deserialize)]
pub struct Root203181Item2(
    pub Null,
    pub Vec<Root203181Item21Item>,
);

/// tuple len=3 (required first 3 slots)
#[derive(Debug, Deserialize)]
pub struct Root203181Item(
    pub Root203181Item0,
    pub Root203181Item1,
    pub Root203181Item2,
);

/// tuple len=2 (required first 2 slots)
#[derive(Debug, Deserialize)]
pub struct Root20318(
    pub Root203180,
    pub Vec<Root203181Item>,
);

/// tuple len=9 (required first 9 slots)
#[derive(Debug, Deserialize)]
pub struct Root2031(
    pub Root20310,
    pub Option<Root20311>,
    pub Root20312,
    pub Null,
    pub Root20314,
    pub Root20315,
    pub Null,
    pub Null,
    pub Root20318,
);

#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root2032(pub i64);
impl std::ops::Deref for Root2032 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root2032 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 5 { return Err(DeError::custom("Root2032: integer below minimum")); }
        if x > 5 { return Err(DeError::custom("Root2032: integer above maximum")); }
        
        Ok(Root2032(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root2036(pub i64);
impl std::ops::Deref for Root2036 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root2036 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 1 { return Err(DeError::custom("Root2036: integer below minimum")); }
        if x > 1 { return Err(DeError::custom("Root2036: integer above maximum")); }
        
        Ok(Root2036(x))
    }
}
/// tuple len=7 (required first 7 slots)
#[derive(Debug, Deserialize)]
pub struct Root203(
    pub Vec<Root2030Item>,
    pub Root2031,
    pub Root2032,
    pub Null,
    pub Null,
    pub Null,
    pub Root2036,
);

#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root205(pub i64);
impl std::ops::Deref for Root205 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root205 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 2 { return Err(DeError::custom("Root205: integer below minimum")); }
        if x > 5 { return Err(DeError::custom("Root205: integer above maximum")); }
        
        Ok(Root205(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub struct Root208Item2(pub f64);
impl std::ops::Deref for Root208Item2 {
    type Target = f64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root208Item2 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = f64::deserialize(de)?;
        if !x.is_finite() { return Err(DeError::custom("Root208Item2: non-finite number")); }
        if x < 35.976768799999995 { return Err(DeError::custom("Root208Item2: number below minimum")); }
        if x > 42.395527000000001 { return Err(DeError::custom("Root208Item2: number above maximum")); }
        
        Ok(Root208Item2(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub struct Root208Item3(pub f64);
impl std::ops::Deref for Root208Item3 {
    type Target = f64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root208Item3 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = f64::deserialize(de)?;
        if !x.is_finite() { return Err(DeError::custom("Root208Item3: non-finite number")); }
        if x < -115.005679700000002 { return Err(DeError::custom("Root208Item3: number below minimum")); }
        if x > -106.677120000000002 { return Err(DeError::custom("Root208Item3: number above maximum")); }
        
        Ok(Root208Item3(x))
    }
}
/// tuple len=4 (required first 4 slots)
#[derive(Debug, Deserialize)]
pub struct Root208Item(
    pub Null,
    pub Null,
    pub Root208Item2,
    pub Root208Item3,
);

#[repr(transparent)]
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct Root209(pub String);
impl std::ops::Deref for Root209 {
    type Target = String;
    fn deref(&self) -> &Self::Target { &self.0 }
}
static RE_ROOT209: Lazy<Regex> = Lazy::new(|| Regex::new("^CgRndW5z.*").unwrap());
impl<'de> Deserialize<'de> for Root209 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let s = String::deserialize(de)?;
        if !RE_ROOT209.is_match(&s) {
            return Err(DeError::custom("Root209: string failed pattern"));
        }
        Ok(Root209(s))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root214(pub i64);
impl std::ops::Deref for Root214 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root214 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 2 { return Err(DeError::custom("Root214: integer below minimum")); }
        if x > 5 { return Err(DeError::custom("Root214: integer above maximum")); }
        
        Ok(Root214(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct Root2260(pub String);
impl std::ops::Deref for Root2260 {
    type Target = String;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root2260 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let s = String::deserialize(de)?;
        if !(s.starts_with("http://") || s.starts_with("https://") || s.starts_with("mailto:") || s.starts_with("tel:")) {
            return Err(DeError::custom("Root2260: expected URI scheme"));
        }
        Ok(Root2260(s))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Root2266(pub i64);
impl std::ops::Deref for Root2266 {
    type Target = i64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root2266 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = i64::deserialize(de)?;
        if x < 1 { return Err(DeError::custom("Root2266: integer below minimum")); }
        if x > 1 { return Err(DeError::custom("Root2266: integer above maximum")); }
        
        Ok(Root2266(x))
    }
}
/// tuple len=7 (required first 7 slots)
#[derive(Debug, Deserialize)]
pub struct Root226(
    pub Root2260,
    pub Null,
    pub Null,
    pub Null,
    pub Null,
    pub Null,
    pub Root2266,
);

/// tuple len=7 (required first 5 slots)
#[derive(Debug, Deserialize)]
pub struct Root227Item(
    pub String,
    pub Null,
    pub Null,
    pub String,
    pub String,
    pub Option<String>,
    pub Option<String>,
);

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum Root243 {
    US,
}
impl<'de> Deserialize<'de> for Root243 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let s = String::deserialize(de)?;
        match s.as_str() {
            "US" => Ok(Root243::US),
            _ => Err(DeError::unknown_variant(&s, &[])),
        }
    }
}
impl serde::Serialize for Root243 {
    fn serialize<S>(&self, ser: S) -> Result<S::Ok, S::Error> where S: serde::Serializer {
        match self {
            Root243::US => ser.serialize_str("US"),
        }
    }
}

/// tuple len=2 (required first 2 slots)
#[derive(Debug, Deserialize)]
pub struct Root245Item00(
    pub String,
    pub String,
);

#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub struct Root245Item01(pub f64);
impl std::ops::Deref for Root245Item01 {
    type Target = f64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root245Item01 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = f64::deserialize(de)?;
        if !x.is_finite() { return Err(DeError::custom("Root245Item01: non-finite number")); }
        if x < 0.75 { return Err(DeError::custom("Root245Item01: number below minimum")); }
        if x > 0.9 { return Err(DeError::custom("Root245Item01: number above maximum")); }
        
        Ok(Root245Item01(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct Root245Item02ItemItem(pub String);
impl std::ops::Deref for Root245Item02ItemItem {
    type Target = String;
    fn deref(&self) -> &Self::Target { &self.0 }
}
static RE_ROOT245ITEM02ITEMITEM: Lazy<Regex> = Lazy::new(|| Regex::new("^America.*").unwrap());
impl<'de> Deserialize<'de> for Root245Item02ItemItem {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let s = String::deserialize(de)?;
        if !RE_ROOT245ITEM02ITEMITEM.is_match(&s) {
            return Err(DeError::custom("Root245Item02ItemItem: string failed pattern"));
        }
        Ok(Root245Item02ItemItem(s))
    }
}
/// tuple len=3 (required first 3 slots)
#[derive(Debug, Deserialize)]
pub struct Root245Item0(
    pub Root245Item00,
    pub Root245Item01,
    pub Vec<Vec<Root245Item02ItemItem>>,
);

#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub struct Root245Item11(pub f64);
impl std::ops::Deref for Root245Item11 {
    type Target = f64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root245Item11 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = f64::deserialize(de)?;
        if !x.is_finite() { return Err(DeError::custom("Root245Item11: non-finite number")); }
        if x < 0.5 { return Err(DeError::custom("Root245Item11: number below minimum")); }
        if x > 1.0 { return Err(DeError::custom("Root245Item11: number above maximum")); }
        
        Ok(Root245Item11(x))
    }
}
/// tuple len=3 (required first 3 slots)
#[derive(Debug, Deserialize)]
pub struct Root245Item1(
    pub Vec<String>,
    pub Root245Item11,
    pub Vec<Vec<String>>,
);

#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub struct Root245Item21(pub f64);
impl std::ops::Deref for Root245Item21 {
    type Target = f64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root245Item21 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = f64::deserialize(de)?;
        if !x.is_finite() { return Err(DeError::custom("Root245Item21: non-finite number")); }
        if x < 0.5 { return Err(DeError::custom("Root245Item21: number below minimum")); }
        if x > 1.0 { return Err(DeError::custom("Root245Item21: number above maximum")); }
        
        Ok(Root245Item21(x))
    }
}
/// tuple len=3 (required first 3 slots)
#[derive(Debug, Deserialize)]
pub struct Root245Item2(
    pub Vec<String>,
    pub Root245Item21,
    pub Vec<Vec<String>>,
);

#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub struct Root245Item31(pub f64);
impl std::ops::Deref for Root245Item31 {
    type Target = f64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root245Item31 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = f64::deserialize(de)?;
        if !x.is_finite() { return Err(DeError::custom("Root245Item31: non-finite number")); }
        if x < 0.5 { return Err(DeError::custom("Root245Item31: number below minimum")); }
        if x > 1.0 { return Err(DeError::custom("Root245Item31: number above maximum")); }
        
        Ok(Root245Item31(x))
    }
}
/// tuple len=3 (required first 3 slots)
#[derive(Debug, Deserialize)]
pub struct Root245Item3(
    pub Vec<String>,
    pub Root245Item31,
    pub Vec<Vec<String>>,
);

#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub struct Root245Item41(pub f64);
impl std::ops::Deref for Root245Item41 {
    type Target = f64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root245Item41 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = f64::deserialize(de)?;
        if !x.is_finite() { return Err(DeError::custom("Root245Item41: non-finite number")); }
        if x < 0.5 { return Err(DeError::custom("Root245Item41: number below minimum")); }
        if x > 1.0 { return Err(DeError::custom("Root245Item41: number above maximum")); }
        
        Ok(Root245Item41(x))
    }
}
/// tuple len=3 (required first 3 slots)
#[derive(Debug, Deserialize)]
pub struct Root245Item4(
    pub Vec<String>,
    pub Root245Item41,
    pub Vec<Vec<String>>,
);

#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub struct Root245Item51(pub f64);
impl std::ops::Deref for Root245Item51 {
    type Target = f64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root245Item51 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = f64::deserialize(de)?;
        if !x.is_finite() { return Err(DeError::custom("Root245Item51: non-finite number")); }
        if x < 0.5 { return Err(DeError::custom("Root245Item51: number below minimum")); }
        if x > 1.0 { return Err(DeError::custom("Root245Item51: number above maximum")); }
        
        Ok(Root245Item51(x))
    }
}
/// tuple len=3 (required first 3 slots)
#[derive(Debug, Deserialize)]
pub struct Root245Item5(
    pub Vec<String>,
    pub Root245Item51,
    pub Vec<Vec<String>>,
);

#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub struct Root245Item61(pub f64);
impl std::ops::Deref for Root245Item61 {
    type Target = f64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root245Item61 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = f64::deserialize(de)?;
        if !x.is_finite() { return Err(DeError::custom("Root245Item61: non-finite number")); }
        if x < 0.75 { return Err(DeError::custom("Root245Item61: number below minimum")); }
        if x > 1.0 { return Err(DeError::custom("Root245Item61: number above maximum")); }
        
        Ok(Root245Item61(x))
    }
}
/// tuple len=3 (required first 3 slots)
#[derive(Debug, Deserialize)]
pub struct Root245Item6(
    pub Vec<String>,
    pub Root245Item61,
    pub Vec<Vec<String>>,
);

#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub struct Root245Item71(pub f64);
impl std::ops::Deref for Root245Item71 {
    type Target = f64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root245Item71 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = f64::deserialize(de)?;
        if !x.is_finite() { return Err(DeError::custom("Root245Item71: non-finite number")); }
        if x < 0.75 { return Err(DeError::custom("Root245Item71: number below minimum")); }
        if x > 1.0 { return Err(DeError::custom("Root245Item71: number above maximum")); }
        
        Ok(Root245Item71(x))
    }
}
/// tuple len=3 (required first 3 slots)
#[derive(Debug, Deserialize)]
pub struct Root245Item7(
    pub Vec<String>,
    pub Root245Item71,
    pub Vec<Vec<String>>,
);

#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub struct Root245Item81(pub f64);
impl std::ops::Deref for Root245Item81 {
    type Target = f64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root245Item81 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = f64::deserialize(de)?;
        if !x.is_finite() { return Err(DeError::custom("Root245Item81: non-finite number")); }
        if x < 0.75 { return Err(DeError::custom("Root245Item81: number below minimum")); }
        if x > 0.9 { return Err(DeError::custom("Root245Item81: number above maximum")); }
        
        Ok(Root245Item81(x))
    }
}
/// tuple len=3 (required first 3 slots)
#[derive(Debug, Deserialize)]
pub struct Root245Item8(
    pub Vec<String>,
    pub Root245Item81,
    pub Vec<Vec<String>>,
);

/// tuple len=9 (required first 5 slots)
#[derive(Debug, Deserialize)]
pub struct Root245Item(
    pub Root245Item0,
    pub Root245Item1,
    pub Root245Item2,
    pub Root245Item3,
    pub Root245Item4,
    pub Option<Root245Item5>,
    pub Option<Root245Item6>,
    pub Option<Root245Item7>,
    pub Option<Root245Item8>,
);

/// tuple len=246 (required first 245 slots)
#[derive(Debug, Deserialize)]
pub struct Root(
    pub String,
    pub String,
    pub Option<Root2>,
    pub Null,
    pub Option<Root4>,
    pub Null,
    pub Null,
    pub Option<Root7>,
    pub Null,
    pub Root9,
    pub String,
    pub String,
    pub Null,
    pub Option<Vec<String>>,
    pub Option<String>,
    pub Null,
    pub Null,
    pub Option<Root17>,
    pub Option<String>,
    pub Null,
    pub Null,
    pub Null,
    pub Null,
    pub Null,
    pub Option<Vec<Vec<Vec<Vec<Root24ItemItemItemItem>>>>>,
    pub Root25,
    pub Null,
    pub Null,
    pub Null,
    pub Null,
    pub Root30,
    pub Null,
    pub Option<Root32>,
    pub Null,
    pub Option<Root34>,
    pub Option<Vec<Option<Root35Item>>>,
    pub Null,
    pub Root37,
    pub Null,
    pub Option<String>,
    pub Option<Root40>,
    pub Null,
    pub Null,
    pub Null,
    pub Null,
    pub Null,
    pub Null,
    pub Null,
    pub Null,
    pub Option<Root49>,
    pub Null,
    pub Null,
    pub Null,
    pub Null,
    pub Null,
    pub Null,
    pub Null,
    pub Option<Root57>,
    pub Null,
    pub Null,
    pub Null,
    pub Root61,
    pub Null,
    pub Null,
    pub Option<Vec<Option<Root64Item>>>,
    pub Null,
    pub Null,
    pub Root67,
    pub Null,
    pub Null,
    pub Null,
    pub Null,
    pub Option<Vec<Vec<Root72ItemItem>>>,
    pub Null,
    pub Null,
    pub Option<Vec<Vec<Root75ItemItem>>>,
    pub Option<Vec<Root76Item>>,
    pub Null,
    pub String,
    pub Null,
    pub Null,
    pub Null,
    pub Option<Vec<Option<String>>>,
    pub Null,
    pub Null,
    pub Null,
    pub Option<Root86>,
    pub Null,
    pub Root88,
    pub String,
    pub Null,
    pub Null,
    pub Null,
    pub Null,
    pub Null,
    pub Null,
    pub Null,
    pub Null,
    pub Null,
    pub Option<Vec<Vec<Root99ItemItem>>>,
    pub Option<Root100>,
    pub Null,
    pub Null,
    pub Null,
    pub Null,
    pub Vec<Vec<Root105ItemItem>>,
    pub Null,
    pub Null,
    pub Null,
    pub Null,
    pub Root110,
    pub Null,
    pub Option<Root112>,
    pub Option<Root113>,
    pub Null,
    pub Null,
    pub Null,
    pub Null,
    pub Option<Vec<Root118Item>>,
    pub Option<Root119>,
    pub Null,
    pub Null,
    pub Null,
    pub Null,
    pub Null,
    pub Option<Vec<Vec<Root125ItemItem>>>,
    pub Null,
    pub Null,
    pub Null,
    pub Null,
    pub Root130,
    pub Null,
    pub Null,
    pub Null,
    pub Option<Vec<Root134Item>>,
    pub Null,
    pub Option<Root136>,
    pub Null,
    pub Null,
    pub Null,
    pub Null,
    pub Null,
    pub Option<Root142>,
    pub Null,
    pub Null,
    pub Null,
    pub Vec<Root146Item>,
    pub Null,
    pub Null,
    pub Null,
    pub Null,
    pub Null,
    pub Null,
    pub Null,
    pub Null,
    pub Null,
    pub Null,
    pub Option<Root157>,
    pub Null,
    pub Null,
    pub Option<Root160>,
    pub Option<Vec<Option<Vec<Vec<Root161ItemItemItem>>>>>,
    pub Null,
    pub Null,
    pub Option<Root164>,
    pub Option<Vec<Root165Item>>,
    pub Option<String>,
    pub Null,
    pub Null,
    pub Null,
    pub Option<Root170>,
    pub Null,
    pub Null,
    pub Null,
    pub Vec<Root174Item>,
    pub Null,
    pub Null,
    pub Null,
    pub Option<Vec<Root178Item>>,
    pub Null,
    pub Null,
    pub Option<Root181>,
    pub Null,
    pub Option<Vec<Root183Item>>,
    pub Null,
    pub Null,
    pub Null,
    pub Null,
    pub Null,
    pub Null,
    pub Null,
    pub Null,
    pub Null,
    pub Null,
    pub Null,
    pub Null,
    pub Option<Root196>,
    pub Null,
    pub Null,
    pub Null,
    pub Null,
    pub Null,
    pub Null,
    pub Option<Root203>,
    pub Null,
    pub Option<Root205>,
    pub Null,
    pub Null,
    pub Option<Vec<Root208Item>>,
    pub Root209,
    pub Null,
    pub Null,
    pub Null,
    pub Null,
    pub Option<Root214>,
    pub Null,
    pub Null,
    pub Null,
    pub Null,
    pub Null,
    pub Null,
    pub Null,
    pub Null,
    pub Null,
    pub Null,
    pub Null,
    pub Option<Root226>,
    pub Vec<Root227Item>,
    pub Null,
    pub Null,
    pub Null,
    pub Null,
    pub Null,
    pub Null,
    pub Null,
    pub Null,
    pub Null,
    pub Null,
    pub Null,
    pub Null,
    pub Null,
    pub Null,
    pub Null,
    pub Option<Root243>,
    pub Null,
    pub Option<Vec<Root245Item>>,
);

